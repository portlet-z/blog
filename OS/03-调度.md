## 基本概念

- 当又一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是调度研究的问题
- 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行



## 调度的三个层次

#### 高级调度

- 由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序
- 高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它们获得竞争处理机的权利
- 高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB。作业调出是才撤销PCB。高级调度主要是指调入的问题，因为只有调入的世纪需要操作系统来确定，但调出的时机必然是作业运行结束才调出

#### 中级调度

- 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。这么做的目的是为了提高内存利用率和系统吞吐量
- 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而会常驻内存。PCB中会记录进程数据在外存中存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控，管理。被挂起的进程PCB会被放到挂起队列中
- 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。

#### 低级调度

- 低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
- 进程调度是操作系统最基本的一种调度，在一般的操作系统中都必须配置进程调度
- 进程调度的频率很高，一般几十毫秒一次

#### 进程的挂起状态与七状态模型

- 暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）
- 挂起状态又可以进一步分为就绪挂起、阻塞挂起两种状态
- 注意挂起和阻塞的区别，两种状态都是暂时不能获得CPU的服务，但挂起状态是将进程映像调到外存去了，而阻塞态下进程映像还在内存
- 有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因再把阻塞挂起进程进一步细分为多个队列
- [七状态模型](http://assets.processon.com/chart_image/61fbc2ad6376890390ce4459.png)

#### 三层调度的联系、对比

| -                          | 要做什么                                                     | 调度发生在...                  | 发生频率 | 对进程状态的影响                             |
| :------------------------- | :----------------------------------------------------------- | :----------------------------- | :------- | :------------------------------------------- |
| 高级调度<br />（作业调度） | 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 | 外存->内存<br />（面向作业）   | 最低     | 无 -> 创建态 -> 就绪态                       |
| 中级调度<br />（内存调度） | 按照某种规则，从挂起对列中选择合适的进程将其数据调回内存     | 外存 -> 内存<br />（面向进程） | 中等     | 挂起态 -> 就绪态<br />（阻塞挂起 -> 阻塞态） |
| 低级调度<br />（进程调度） | 按照某种规则，从就绪队列中选择一个进程为其分配处理机         | 内存 -> CPU                    | 最高     | 就绪态 -> 运行态                             |



## 进程调度的时机

- 进程调度（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机
- 需要进行进程调度与切换的情况
  - 当前运行的进程主动放弃处理机
    1. 进程正常终止
    2. 运行过程中发生异常而终止
    3. 进程主动请求阻塞（如等待IO）
  - 当前运行的进程被动放弃处理机
    1. 分给进程的时间片用完
    2. 有更紧急的事需要处理（如IO中断）
    3. 有更高优先级的进程进入就绪队列
- 不能进行进程调度与切换的情况
  - 在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到中断处理过程中进行进程切换
  - 进程在操作系统内核程序临界区中
  - 在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）
- 进程在操作系统内核程序临界区中不能进行调度与切换✅
- 进程处于临界区时不能进程处理机调度❌
- 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源
- 临界区：访问临界资源地那段代码
- 内核程序临界区：一般是用来访问某种内核数据结构地，比如进程地就绪队列（由各就绪进程的PCB组成）
- 就绪队列：如果还没退出临界区（还没解锁）就进行进程调度，但是进程调度相关的程序也需要访问就绪队列，但此时就绪队列被锁住了，因此又无法顺利进行进程调度。内核程序临界区访问临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此访问内核程序临界区期间不能进行调度与切换
- 在打印机完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。普通临界区访问的临界资源不会直接影响操作系统内核的管理工作。因此在访问普通临界区时可以进程调度与切换



## 进程调度的方式

- 非剥夺调度方式，又称非抢占方式。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
- 剥夺调度方式，又称抢占方式。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的执行，将处理机分配给更重要紧迫的那个进程。可以优先处理更紧急的进程，也可以实现让各进程按时间骗轮流执行的功能（通过时钟中断）。适合于分时操作系统，实时操作系统



## 进程的切换与过程

- 侠义的进程调度与进程切换的区别
  - 侠义的进程调度指的是从就绪队列中选中一个要运行的进程（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）
  - 进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程
- 广义的进程调度包含了选择一个进程和进程切换两个步骤
- 进程切换的过程主要完成了
  - 对原来运行进程各种数据的保持
  - 对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）
- 注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少



## 调度算法的评价指标

#### CPU利用率

- 由于早期的CPU造价极其昂贵，因此人们会希望让CPU尽可能多地工作
- CPU利用率：指CPU忙碌地时间占总时间地比例
- 利用率 = 忙碌地时间 / 总时间

#### 系统吞吐量

- 对于计算机来说，希望能尽可能少地时间处理完尽可能多地作业
- 系统吞吐量：单位时间内完成作业的数量
- 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间

#### 周转时间

- 对于计算机用户来说，他很关心自己的作业提交到完成花了多少时间
- 周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔
- 它包括四个部分：作业从外存后备队列上等待作业调度（高级调度）的时间、进程在就绪队列上等待进程调度（低级调度）的时间、进程在CPU上执行的时间、进程等待IO操作完成的时间。后三项在一个作业的整个处理过程中，可能发生多次
- （作业周转时间） = 作业完成时间 - 作业提交时间  （对于用户来说，更关心自己的单个作业的周转时间）
- 平均周转时间 = 各作业周转时间之和 / 作业数 （对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值）
- 带权周转时间 = 作业周转时间 / 作业实际运行的时间 = （作业完成时间 - 作业提交时间） / 作业实际运行的时间 
- 平均带权周转时间 = 各作业带权周转时间之和 / 作业数
- 带权周转时间必然大于等于1
- 带权周转时间与周转时间都是越小越好
- 对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高
- 对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高

#### 等待时间

- 计算机的用户希望自己的作业尽可能少的等待处理机
- 等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低
- 对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待IO完成的期间其实进程也是被服务的，所以不计入等待时间
- 对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间
- 一个作业总共需要被CPU服务多久，被IO设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。当然，与前面指标类似，也有平均等待时间来评价整体性能

#### 响应时间

- 对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务，回应

- 响应时间，指从用户提交请求到首次产生响应所用地时间



## 调度算法

#### 先来先服务FCFS(First Come First Serve)

- 算法思想：主要从“公平”地角度考虑（类似于我们生活中排队买东西地例子）
- 算法规则：按照作业/进程到达地顺序进行服务
- 用于作业/进程调度：用于作业调度时，考虑地是哪个作业先到达后备队列；用于进程调度时，考虑地是哪个进程先到达就绪队列
- 是否可抢占？非抢占式地算法
- 优缺点：
  - 优点：公平，算法实现简单
  - 缺点：排在长作业（进程）后面地短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即，FCFS算法对长作业有利，对短作业不利
- 是否会导致饥饿（某进程/作业长期得不到服务）：不会

#### 短作业优先 SJF(Shortest Job First)

- 算法思想：追求最少地平均等待时间，最少地平均周转时间，最少地平均带权周转时间
- 算法规则：最短地作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）
- 用于作业/进程调度：既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先”(SPF, Shortest Process First)算法
- 是否可抢占？SJF和SPF都是非抢占式算法。但是也有抢占式地版本--最短剩余时间优先算法(SRTN, Shortest Remaining Time Next)
- 优缺点
  - 优点：最短地平均等待时间，平均周转时间
  - 缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程地运行时间是由用户提供地，并不一定真是，不一定能做到真正地短作业优先
- 是否会导致饥饿：会。如果有源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生饥饿现象。如果一直得不到服务，则称为“饿死”

#### 高响应比优先 HRRN(Highest Response Ration Next)

- 算法思想：要综合考虑作业/进程地等待时间和要求服务地时间
- 算法规则：在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。响应比 = （等待时间 + 要求服务时间） / 要求服务时间。响应比大于等于1
- 用于作业/进程调度：既可用于作业调度，也可用于进程调度
- 是否可抢占？非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比
- 优缺点：
  - 综合考虑了等待时间和运行时间（要求服务时间）
  - 等待时间相同时，要求服务时间短的优先（SJF的优点）
  - 要求服务时间相同时，等待时间长的优先（FCFS的优点）
  - 对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题
- 是否会导致饥饿：不会

#### FCFS,SJF/SPF,HRRN对比

| 算法 | 可抢占？ | 优点 | 缺点 | 考虑到等待时间&运行时间？ | 会导致饥饿？ |
| ---- | -------- | ---- | ---- | ------------------------- | ------------ |
| FCFS | 非抢占式 | 公平，实现简单 | 对短作业不利 | 等待时间✅<br />运行时间❌ | 不会 |
| SJF/SPF | 默认非抢占式，<br />也有SJF的抢占式版本<br />最短剩余时间优先算法(SRTN) | "最短的"平均等待/周转时间 | 对长作业不利，可能导致饥饿；<br />难以做到真正的短作业优先 | 等待时间❌<br />运行时间✅ | 会 |
| HRRN | 非抢占式 | 上述两种算法的权衡折中，<br />综合考虑的等待时间和运行时间 |  | 等待时间✅<br />运行时间✅ | 不会 |

- 注：这几种算法主要关心对用户的公平性，平均周转时间，平均等待时间来评价系统整体性能的指标，但是不关心”响应时间“，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合于早期的批处理系统。当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。

#### 习题

- 计算各个进程在不同算法下的等待时间，平均等待时间，周转时间，平均周转时间，带权周转时间，平均带权周转时间

| 进程 | 到达时间 | 运行时间 |
| ---- | -------- | -------- |
| P1   | 0        | 7        |
| P2   | 2        | 4        |
| P3   | 4        | 1        |
| P4   | 5        | 4        |

- FCFS
  - 先来先服务调度算法：按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务
  - [调度顺序](http://assets.processon.com/chart_image/61fdd9547d9c0806abaeb68d.png) ： P1 -> P2 -> P3 -> P4
  - 周转时间 = 完成时间 - 到达时间 P1=7-0=7; P2=11-2=9; P3=12-4=8; P4=16-5=11
  - 带权周转时间 = 周转时间/运行时间 P1=7/7=1; P2=9/4=2.25; P3=8/1=8; P4=11/4=2.75
  - 等待时间 = 周转时间 - 运行时间 P1=7-7=0; P2=9-4=5; P3=8-1=7; P4=11-4=7
  - 平均周转时间 = (7 + 9 + 8 + 11) / 4 = 8.75
  - 平均带权周转时间 = (1 + 2.25 + 8 + 2.75) / 4 = 3.5
  - 平均等待时间 = (0 + 5 + 7 + 7) / 4 = 4.75
- SPF
  - 短作业/进程优先算法：每次调度时选择当前已到达且运行时间最短的作业/进程
  - [调度顺序](http://assets.processon.com/chart_image/61fdd9547d9c0806abaeb68d.png) ：P1 -> P3 -> P2 -> P4
  - 周转时间 = 完成时间 - 到达时间 P1=7-0=7; P3=8-4=4; P2=12-2=10; P4=16-5=11
  - 带权周转时间=周转时间/运行时间 P1=7/7=1; P3=4/1=4; P2=10/4=2.5; P4=11/4=2.75
  - 等待时间=周转时间-运行时间 P1=7-7=0; P3=4-1=3; P2=10-4=6; P4=11-4=7
  - 平均周转时间 = (7+4+10+11)/4 = 8
  - 平均带权周转时间 = (1+4+2.5+2.75)/4 = 2.56
  - 平均等待时间 = (0+3+6+7)/4 = 4

