## 内存的基础知识

#### 什么是内存？有何作用

- 内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理
- 在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方呢？
  - 方案：给内存的存储单元编址。
  - 内存地址从0开始，每个地址对应一个存储单元
  - 内存中也有一个一个“小房间”，每个小房间就是一个“存储单元”
  - 如果计算机“按字节编址”则每个存储单元大小为1字节，即1B，即8个bit
  - 如果字长为16bit的计算机“按字编址”，则每个存储单元大小为一个字；每个字的大小为16bit

#### 指令

- 我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该取内存的哪个地址取数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址（物理地址）。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用逻辑地址（相对地址）

#### 逻辑地址VS物理地址

- 宿舍四个人一起去旅行，四个人的学号尾号分别是0，1，2，3。住酒店时酒店给你们安排了4个房间。四个人按学号递增依次入住房间。比如0，1，2，3👌同学分别入住了5，6，7，8号房间。四个人的编号0，1，2，3其实是一个“相对位置”，而各自入住的房间号是一个“绝对位置”
- 只要知道0号同学住的是房间号为N的房间，那么M号同学的房间号一定是N+M.也就是说，只要知道各个同学的“相对位置”和“起始房号”，就一定可以算出所有同学的“绝对位置”
- 指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始地址位置得到“绝对地址”
- 相对地址有称逻辑地址，绝对地址又称物理地址

#### [程序编译运行过程](http://assets.processon.com/chart_image/620321987d9c0806abb6e36b.png)

- 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）
- 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- 装入（装载）：由装入程序将装入模块装入内存运行

#### 装入的三种方式

- 绝对装入：单道程序阶段，此时还没产生操作系统
  - 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存
  - 绝对装入只适用于单道程序环境
  - 程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址
- 静态重定位：用于早期的多道批处理操作系统
  - 又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存当前情况，将装入模块装入到内存的适当位置。装入时对地址进行”重定位“，将逻辑地址变为物理地址（地址变换是在装入时一次完成的）
  - 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间
- 动态重定位：现代操作系统
  - 又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持
  - 重定位寄存器：存放装入模块存放的起始位置
  - 采用动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

#### 链接的三种方式

- 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件（装入模块），之后不再拆分
- 装入时动态链接：将各目标模块装入内存，边装入边链接的链接方式
- 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享



## 内存管理的概念

#### 概念

- 操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？
  - 操作系统负责内存空间的分配与回收
  - 操作系统需要提供某种技术从逻辑上对内存空间进行扩充
  - 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
  - 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

#### 内存保护

- 内存保护的两种方法
  - 在CPU中设置一对上，下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界
  - 采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址。



## 覆盖与交换

#### 覆盖技术

- 早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常出现内存大小不够的情况
- 后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题
- 覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段再需要时调入内存
- 内存中分为一个“固定区”和若干个“覆盖区”
- 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）
- 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存
- 必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：用用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史

#### 交换技术

- 交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）
- 暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起，阻塞挂起两种状态
- 应该在外存（磁盘）的什么位置保存被换出的进程？具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的IO速度比文件区的更快
- 什么时候应该交换？交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出
- 应该换出哪些进程？可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间
- 注意：PCB会常驻内存，不会被换出外存



## 连续分配管理方式

- 连续分配：指为用户进程分配的必须是一个连续的内存空间

#### 单一连续分配

#### 固定分区分配

- 20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的，最简单的一种可运行多道程序的内存管理方式。
- 分区大小相等：缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合（比如：钢厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域放n个炼钢炉控制程序）
- 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区，适量中等分区，少量大分区）
- 操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。数组或链表都可表示这个表
- 当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的，未分配的分区，将之分配给该程序，然后修改状态为“已分配”
- 优点：实现简单，无外部碎片
- 缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。

#### 动态分区分配

- 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。
- 系统要用什么样的数据结构记录内存的使用情况
  - 空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
  - 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息
- 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配
- 如何进行分区的回收操作
  - 情况一：回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个
  - 情况二：回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个
  - 情况三：回收的前后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个
  - 情况四：回收的前后都没有相邻的空闲分区，新增一个表项。
- 动态分区分配没有内部碎片，但是有外部碎片。
  - 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上
  - 外部碎片，是指内存中的某些空闲分区由于太小而难以利用
- 如果内存中空闲空间的总和本来可以满足某些进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片



## 动态分区分配算法

- 在动态分区分配方式中，当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

#### 首次适应算法(First Fit)

- 算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区
- 如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区

#### 最佳适应算法(Best Fit)

- 算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空姐必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空姐，可以尽可能的留下大片的空闲区，即优先使用更小的空闲区
- 如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区
- 缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块。因此这种方法会产生很大的外部碎片

#### 最坏适应算法(Worst Fit)

- 又称最大适应算法（Largest Fit）
- 算法思想：为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用
- 如何实现：空闲分区按容量递减次数链接。每次分配内存时按顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区
- 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了

#### 邻近适应算法(Next Fit)

- 算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从查找结束的位置开始检索，就能解决上述问题
- 如何实现：空闲分区以地址递增顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区
- 首次适应算法每次要求都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）
- 邻近适应算法的规则可能会导致无论高地址、低地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致了无大分区可用（最大使用算法的缺点）

#### 四种算法的对比

| 算法     | 算法思想                                           | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递增次序排列                   | 综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列                   | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的，难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递减次序排序                   | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程，算法开销大（原因同上）       |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列（可排列成循环表） | 不用每次都从低地址的小分区开始检索。算法开销小（原因通首次适应算法） | 会使高地址的大分区也被用完                                   |







