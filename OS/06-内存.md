## 内存的基础知识

#### 什么是内存？有何作用

- 内存是用于存放数据的硬件。程序执行前需要先放到内存中才能被CPU处理
- 在多道程序环境下，系统中会有多个程序并发执行，也就是说会有多个程序的数据需要同时放到内存中。那么，如何区分各个程序的数据是放在什么地方呢？
  - 方案：给内存的存储单元编址。
  - 内存地址从0开始，每个地址对应一个存储单元
  - 内存中也有一个一个“小房间”，每个小房间就是一个“存储单元”
  - 如果计算机“按字节编址”则每个存储单元大小为1字节，即1B，即8个bit
  - 如果字长为16bit的计算机“按字编址”，则每个存储单元大小为一个字；每个字的大小为16bit

#### 指令

- 我们写的代码要翻译成CPU能识别的指令。这些指令会告诉CPU应该取内存的哪个地址取数据，这个数据应该做什么样的处理。在这个例子中，指令中直接给出了变量x的实际存放地址（物理地址）。但实际在生成机器指令的时候并不知道该进程的数据会被放到什么位置。所以编译生成的指令中一般是使用逻辑地址（相对地址）

#### 逻辑地址VS物理地址

- 宿舍四个人一起去旅行，四个人的学号尾号分别是0，1，2，3。住酒店时酒店给你们安排了4个房间。四个人按学号递增依次入住房间。比如0，1，2，3👌同学分别入住了5，6，7，8号房间。四个人的编号0，1，2，3其实是一个“相对位置”，而各自入住的房间号是一个“绝对位置”
- 只要知道0号同学住的是房间号为N的房间，那么M号同学的房间号一定是N+M.也就是说，只要知道各个同学的“相对位置”和“起始房号”，就一定可以算出所有同学的“绝对位置”
- 指令中的地址也可以采用这种思想。编译时产生的指令只关心“相对地址”，实际放入内存中时再想办法根据起始地址位置得到“绝对地址”
- 相对地址有称逻辑地址，绝对地址又称物理地址

#### [程序编译运行过程](http://assets.processon.com/chart_image/620321987d9c0806abb6e36b.png)

- 编译：由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言）
- 链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- 装入（装载）：由装入程序将装入模块装入内存运行

#### 装入的三种方式

- 绝对装入：单道程序阶段，此时还没产生操作系统
  - 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存
  - 绝对装入只适用于单道程序环境
  - 程序中使用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。通常情况下都是编译或汇编时再转换为绝对地址
- 静态重定位：用于早期的多道批处理操作系统
  - 又称可重定位装入。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存当前情况，将装入模块装入到内存的适当位置。装入时对地址进行”重定位“，将逻辑地址变为物理地址（地址变换是在装入时一次完成的）
  - 静态重定位的特点是在一个作业装入内存时，必须分配其要求的全部内存空间，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，在运行期间就不能再移动，也不能再申请内存空间
- 动态重定位：现代操作系统
  - 又称动态运行时装入。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是把地址推迟到程序真正要执行时才进行。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个重定位寄存器的支持
  - 重定位寄存器：存放装入模块存放的起始位置
  - 采用动态重定位时允许程序在内存中发生移动，并且可将程序分配到不连续的存储区中；在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间

#### 链接的三种方式

- 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行文件（装入模块），之后不再拆分
- 装入时动态链接：将各目标模块装入内存，边装入边链接的链接方式
- 运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享



## 内存管理的概念

#### 概念

- 操作系统作为系统资源的管理者，当然也需要对内存进行管理，要管些什么呢？
  - 操作系统负责内存空间的分配与回收
  - 操作系统需要提供某种技术从逻辑上对内存空间进行扩充
  - 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
  - 操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰

#### 内存保护

- 内存保护的两种方法
  - 在CPU中设置一对上，下限寄存器，存放进程的上、下限地址。进程的指令要访问某个地址时，CPU检查是否越界
  - 采用重定位寄存器（又称基址寄存器）和界地址寄存器（又称限长寄存器）进行越界检查。重定位寄存器中存放的是进程的起始物理地址。界地址寄存器存放的是进程的最大逻辑地址。



## 覆盖与交换

#### 覆盖技术

- 早期的计算机内存很小，比如IBM推出的第一台PC机最大只支持1MB大小的内存。因此经常出现内存大小不够的情况
- 后来人们引入了覆盖技术，用来解决“程序大小超过物理内存总和”的问题
- 覆盖技术的思想：将程序分为多个段（多个模块）。常用的段常驻内存，不常用的段再需要时调入内存
- 内存中分为一个“固定区”和若干个“覆盖区”
- 需要常驻内存的段放在“固定区”中，调入后就不再调出（除非运行结束）
- 不常用的段放在“覆盖区”，需要用到时调入内存，用不到时调出内存
- 必须由程序员声明覆盖结构，操作系统完成自动覆盖。缺点：用用户不透明，增加了用户编程负担。覆盖技术只用于早期的操作系统中，现在已成为历史

#### 交换技术

- 交换（对换）技术的设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）
- 暂时换出外存等待的进程状态为挂起状态（挂起态，suspend）挂起态又可以进一步细分为就绪挂起，阻塞挂起两种状态
- 应该在外存（磁盘）的什么位置保存被换出的进程？具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式；对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式。总之，对换区的IO速度比文件区的更快
- 什么时候应该交换？交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如：在发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程；如果缺页率明显下降，就可以暂停换出
- 应该换出哪些进程？可优先换出阻塞进程；可换出优先级低的进程；为了防止优先级低的进程在被调入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间
- 注意：PCB会常驻内存，不会被换出外存



## 连续分配管理方式

- 连续分配：指为用户进程分配的必须是一个连续的内存空间

#### 单一连续分配

#### 固定分区分配

- 20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业，这样就形成了最早的，最简单的一种可运行多道程序的内存管理方式。
- 分区大小相等：缺乏灵活性，但是很适合用于一台计算机控制多个相同对象的场合（比如：钢厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域放n个炼钢炉控制程序）
- 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分（比如：划分多个小分区，适量中等分区，少量大分区）
- 操作系统需要建立一个数据结构--分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。数组或链表都可表示这个表
- 当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的，未分配的分区，将之分配给该程序，然后修改状态为“已分配”
- 优点：实现简单，无外部碎片
- 缺点：当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能；会产生内部碎片，内存利用率低。

#### 动态分区分配

- 动态分区分配又称为可变分区分配。这种分配方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。
- 系统要用什么样的数据结构记录内存的使用情况
  - 空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息
  - 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息
- 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配
- 如何进行分区的回收操作
  - 情况一：回收区的后面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个
  - 情况二：回收区的前面有一个相邻的空闲分区，两个相邻的空闲分区合并为一个
  - 情况三：回收的前后各有一个相邻的空闲分区，三个相邻的空闲分区合并为一个
  - 情况四：回收的前后都没有相邻的空闲分区，新增一个表项。
- 动态分区分配没有内部碎片，但是有外部碎片。
  - 内部碎片，分配给某进程的内存区域中，如果有些部分没有用上
  - 外部碎片，是指内存中的某些空闲分区由于太小而难以利用
- 如果内存中空闲空间的总和本来可以满足某些进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。可以通过紧凑（拼凑，Compaction）技术来解决外部碎片



## 动态分区分配算法

- 在动态分区分配方式中，当有很多个空闲分区都能满足需求时，应该选择哪个分区进行分配？

#### 首次适应算法(First Fit)

- 算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区
- 如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区

#### 最佳适应算法(Best Fit)

- 算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空姐必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空姐，可以尽可能的留下大片的空闲区，即优先使用更小的空闲区
- 如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链（或空闲分区表），找到大小能满足要求的第一个空闲分区
- 缺点：每次都选最小的分区进行分配，会留下越来越多的，很小的，难以利用的内存块。因此这种方法会产生很大的外部碎片

#### 最坏适应算法(Worst Fit)

- 又称最大适应算法（Largest Fit）
- 算法思想：为了解决最佳适应算法的问题--即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用
- 如何实现：空闲分区按容量递减次数链接。每次分配内存时按顺序查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区
- 缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了

#### 邻近适应算法(Next Fit)

- 算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从查找结束的位置开始检索，就能解决上述问题
- 如何实现：空闲分区以地址递增顺序排列（可排成一个循环链表）。每次分配内存时从上次查找结束的位置开始查找空闲分区链（空闲分区表），找到大小能满足要求的第一个空闲分区
- 首次适应算法每次要求都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来（最佳适应算法的优点）
- 邻近适应算法的规则可能会导致无论高地址、低地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致了无大分区可用（最大使用算法的缺点）

#### 四种算法的对比

| 算法     | 算法思想                                           | 分区排列顺序                                 | 优点                                                         | 缺点                                                         |
| -------- | -------------------------------------------------- | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 首次适应 | 从头到尾找适合的分区                               | 空闲分区以地址递增次序排列                   | 综合看性能最好，算法开销小，回收分区后一般不需要对空闲分区队列重新排序 |                                                              |
| 最佳适应 | 优先使用更小的分区，以保留更多大分区               | 空闲分区以容量递增次序排列                   | 会有更多的大分区被保留下来，更能满足大进程需求               | 会产生很多太小的，难以利用的碎片；算法开销大，回收分区后可能需要对空闲分区队列重新排序 |
| 最坏适应 | 优先使用更大的分区，以防止产生太小的不可用的碎片   | 空闲分区以容量递减次序排序                   | 可以减少难以利用的小碎片                                     | 大分区容易被用完，不利于大进程，算法开销大（原因同上）       |
| 邻近适应 | 由首次适应演变而来，每次从上次查找结束位置开始查找 | 空闲分区以地址递增次序排列（可排列成循环表） | 不用每次都从低地址的小分区开始检索。算法开销小（原因通首次适应算法） | 会使高地址的大分区也被用完                                   |



## 基本分页存储管理的概念

#### 思考：连续分配方式的缺点

- 固定分区分配：缺乏灵活性，会产生大量的内部碎片，内存的利用率很低
- 动态分区分配：会产生很多外部碎片，虽然可以用“紧凑”技术来处理，但是“紧凑”的时间代价很高
- 如果允许将一个进程分散的装入到许多不相邻的分区中，便可充分的利用内存，而无需再进行“紧凑”
- 基于这思想，产生了“非连续分配方式”，或者称为“离散分配方式”
- 连续分配：为用户进程分配的必须是一个连续的内存空间
- 非连续分配：为用户进程分配的可以是一些分散的内存空间

#### 把“固定分区分配”改造为“非连续分配版本”

- 假设进程A大小为23MB,但是每个分区大小只有10MB，如果进程只能占用一个分区，那显然放不下。
- 解决思路：如果允许进程占用多少个分区，那么可以把进程拆分成10MB+10MB+3MB三个部分，再把这三个部分分别放到三个分区中（这些分区不要求连续）。如果把分区大小设置的更小一些，内部碎片会更小，内存利用率会更高。
- 基本分页存储管理的思想--把内存分为一个个相等的小分区，再按照分区大小把进程拆分成一个个小部分

#### 分页存储管理基本概念

- 将内存空间分为一个个大小相等的分区（比如：每个分区4KB）,每个分区就是一个“页框”，或称“页帧”、内存块、物理块。每个页框有一个编号，即页框号（或内存块号，页帧号，物理块号）页框号从0开始
- 将用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或“页面”。每个页面也有一个编号，即页号，页号也是从0开始（注：进程的最后一个页面可能没有一个页框那么大。因此，页框不能太大，否则可能产生过大的内部碎片）
- 操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应关系
- 各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中

#### 思考：如何实现地址的转换

- 假设每页大小为50B, 逻辑地址为80的内存单元应该在1号页，该页在内存中的起始位置为450。计算出逻辑地址为80的实际物理地址为多少

  - 要算出逻辑地址对应的页号。页号 = 逻辑地址 / 页面长度 = 80 / 50 = 1
  - 要知道该页号对应页面在内存中的起始地址。450
  - 要算出逻辑地址在页面内的“偏移量”。页内偏移量 = 80 % 50 = 30
  - 物理地址 = 页面起始地址 + 页内偏移量 = 450 + 30 = 480

- 为了方便计算页号、页内偏移量，页面大小一般设为2的整数幂

  - 假设用32bit来表示逻辑地址，页面大小为2^12B = 4096B = 4KB
  - 0号页的逻辑地址空间应该是0-4095，用二进制表示为：

  00000000000000000000<u>000000000000</u> - 00000000000000000000<u>111111111111</u>

  - 1号页的逻辑地址空间应该是4096-8191，用二进制表示为：

  00000000000000000001<u>000000000000</u> - 00000000000000000001<u>111111111111</u>

  - 2号页的逻辑地址空间应该是8192-12287，用二进制表示为：

  00000000000000000010<u>000000000000</u> - 00000000000000000010<u>111111111111</u>

  - eg:逻辑地址2，用禁止表示应该是 00000000000000000000<u>000000000010</u>, 若0号页在内存中的起始地址为X,则逻辑地址2对应的物理地址应该是 X + <u>000000000010</u>

  - eg逻辑地址4097，用二进制表示是 00000000000000000001<u>000000000001</u>,若1号也在内存中的起始地址为X,则逻辑地址4097对应的物理地址应该是X+<u>000000000001</u>

  - 结论：如果每个页面大小为2^K B,用二进制数表示逻辑地址，则末尾K位即为页内偏移量，其余部分就是页号
  - 因此，如果让每个页面的大小为2的整数幂，计算机就可以很方便地得出一个逻辑地址对应的页号和页内偏移量
  
- 逻辑地址结构：分页存储管理的逻辑地址结构如下所示

| 31  ......  12 | 11  ......  0 |
| :------------: | :-----------: |
|     页号P      |  页内偏移量W  |

- 地址结构包含两个部分：前一部分为页号P，后一部分为页内偏移量W。在上图所示的例子中，地址长度为32位，其中0-11位为“页内偏移量”，或称“页内地址”；12-31位为“页号”
- 如果有K位表示“页内偏移量”，则说明系统中有一个页面的大小是2^K个内存单元
- 如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2^M个页面

#### [页表](http://assets.processon.com/chart_image/6205f8f0e401fd5e53be2e42.png)

- 为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表
- 一个进程对应一张页表
- 进程的每一页对应一个页表项
- 每个页表项由页号和块号组成
- 页表记录进程页面和实际存放的内存块之间的对应关系
- 每个页表项的长度是相同的，页号是“隐含的”



## 基本地址变换机构

#### [变换机构](http://assets.processon.com/chart_image/6205fb5b7d9c085d161f1faa.png)

- 基本地址变换机构可以借助进程的页表将逻辑地址转变为物理地址
- 通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F和页表长度M。进程未执行时，页表的其实地址和页表长度放在进程控制块（PCB）中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。（注：页面大小是2的整数幂）
- 设置页面大小未L，逻辑地址A到物理地址E的变换过程如下：
  - ①计算页号P和页内偏移量W(如果用十进制数手算，则P=A/L, W=A%L; 但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示地页号，页内偏移量)
  - ②比较页号P和页表长度M，若P>=M,则产生越界中断，否则继续执行（注：页号是从0开始地，而页表长度至少是1，因此P=M时也会越界）
  - ③页表中页号P对应的 页表项地址 = 页表起始地址F + 页号P * 页表项长度，取出该页表项内容b,即为内存块号（注意区分页表项长度，页表长度，页面大小的区别。页表长度指的是这个页表中总共又几个页表项，即总共有几个页；页表项长度指的是每个页表项占多大的存储空间；页表大小指的是一个页面占多大存储空间）
  - ④计算 E = b * L + W, 用得到的物理地址E去访存（如果内存块号，页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了）
- 例：若页面大小L为1K字节，页号2对应的内存块号为8，将逻辑地址A=2500转换为物理地址E。等价描述：某系统按字节寻址，逻辑地址结构中，页内偏移量占10位（说明一个页面的大小为2^10B = 1KB）,页号2对应的内存块号b=8, 将逻辑地址A=2500转换为物理地址E
  - ①计算页号，页内偏移量。页号P = A/L = 2500/1024=2; 页内偏移量 W = A%L = 2500%1024=452
  - ②根据题中条件可知，页号2没有越界，其存放的内存块号b=8
  - ③物理地址 E = b * L + W = 8 * 1024 + 452 = 8644
- 在分页存储管理（页式管理）的系统中，只要确定了每个页面的大小，逻辑地址结构就确定了。因此，页式管理中地址是一维的。即，只要给出一个逻辑地址，系统就可以自动的算出页号，页内偏移量两个部分，并不需要显示的告诉系统这个逻辑地址中，页内偏移量占多少位
- 对页表项大小的进一步探讨
  - 每个页表项的长度是相同的，页号是“隐含”的
  - eg:假设某系统物理内存大小位4GB，页面大小位4KB的内存总共会被分为2^32 / 2^12 = 2^20个内存块，因此内存块号的范围应该是0 - 2^20-1.因此至少要20个二进制位才能表示这么多的内存块号，因此至少要3字节才够（每个字节8个二进制位，3个字节共24个二进制位）
  - 各页表项会按顺序连续的存放在内存中，如果该页表在内存中存放的起始地址为X, 则M号页对应的页表项是存放在内存地址为X + 3*M
  - 一个页面为4KB, 则每个页框可以存放4096/3=1365个页表项，但是这个页框会剩余4096%3=1B页内碎片，因此1365号页表项存放的地址为 X + 3 * 1365 + 1
  - 如果每个页表项占4字节，则每个页框刚好可存放1024个页表项，1024号页表项虽然是存放在下一个页框中的，但是它的地址依然可以用 X + 4 * 1024得出
  - 结论：理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询，常常会让一个页表项占更多的字节，使得每个页面恰好可以装得下整数个页表项



## 具有快表的地址变换机构

- 是基本地址变换机构的改进版本

#### 局部性原理

```c
int i = 0;
int a[100];
while (i < 100) {
    a[i] = i;
    i++;
}
```

- 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很有可能再次被访问（因为程序中存在大量的循环）
- 空间局部性：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的）
- 上小节介绍的基本地址变换机构中，每次要访问一个逻辑地址，都需要查询内存中的页表。由于局部性原理，可能连续很多次查到的都是同一个页表项。既然如此，能否李彤这个特性减少访问页表的次数呢？

#### [快表](http://assets.processon.com/chart_image/62077beb0e3e7407d1ccea6a.png)

#### 引入块表后，地址的变换过程

- ①CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中所有页号进行比较。
- ②如果找到匹配的页号，说明要访问的页表项在快表中由副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表命中，则访问某个逻辑地址仅需一次访存即可
- ③如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，访问该物理地址对应的内存单元。因此，若快表未命中，则访问某个逻辑地址需要两次访存（注意：在找到页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换）
- 由于查询快表的速度比查询页表的速度快很多，因此只要快表命中，就可以节省很多时间。因为局部性原理，一般来说快表的命中率可以达到90%以上
- 例：某系统使用分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us, 访问一次内存耗时100us.若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少？
  - (1 + 100) * 0.9 + (1 + 100 + 100) * 0.1 = 111us
  - 若未采用快表机制，则访问一个逻辑地址需要 100 + 100 = 200us
  - 有的系统支持快表和慢表同时查找，如果是这样，平均耗时应该是(1 + 100) * 0.9 + (100 + 100) * 0.1 = 110.9us
  - 显然，引入快表机制后，访问一个逻辑地址的速度快多了

| -                      | 地址变换过程                                                 | 访问一个逻辑地址的访存次数                           |
| ---------------------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| 基本地址变换机构       | ①算页号、页内偏移量<br />②检查页号合法性<br />③查页表，找到页面存放的内存块号<br />④根据内存块号与页内偏移量得到物理地址<br />⑤访问目标内存单元 | 两次访存                                             |
| 具有快表的地址变换机构 | ①算页号、页内偏移量<br />②检查页号合法性<br />③查快表。若命中，即可知道页面存放的内存块号，可直接进行⑤<br />④查页表，找到页面存放的内存块号，并且将页表项复制到快表中<br />⑤根据内存块号与页内偏移量得到物理地址<br />⑥访问目标内存单元 | 快表命中，只需一次访存<br />快表未命中，需要两次访问 |



## 两级页表

#### 单极页表存在的问题 

- 某计算机系统按字节寻址，支持32位的逻辑地址，采用分页存储管理，页面大小位4KB，页表项长度为4B
- $4KB = 2^{12}B$,因此页内地址要用12位表示，剩余20位表示页号
- 因此，该系统中用户进程最多有$2^{20}$页。相应的，一个进程的页表中，最多会有$2^{20} = 1M = 1,048,576$个页表项，所以一个页表最大需要$2^{20} * 4B = 2^{22}B$,共需要$2^{22}/2^{12} = 2^{10}$个页框存储该页表
- 需要专门给进程分配1024个连续的页框来存放它的页表
- 根据页号查询页表的方法：K号页对应的页表项存放位置 = 页表起始地址 + K* 4.要在所有的页表项都连续存放的基础上才能用这种方法找到页表项
- 根据局部性原理可知，很多时候，进程在一段时间内只需要访问某几个页面就可以正常运行 。因此没有必要让整个页表都常驻内存

#### 如何解决单级页表的问题

- 问题一：页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框
- 问题二：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面
  - 可以在需要访问页面时才把页面调入内存（虚拟内存技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存
  - 若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存
- 思考：我们是如何解决进程在内存中必须连续存储的问题的？
  - 将进程地址空间分页，并为建立一张页表，记录各页面的存放位置
  - 同样的思路也可以用于解决“页表必须连续存放”的问题，把必须连续存放的页表再分页
- 可将长长的页表进行分组，使每个内存块刚好可以放入一个分组（比如上个例子中，页面大小4KB,每个页表项4B,每个页面可存放1K个页表项，因此1K个连续的页表项为一组，每组刚好占一个内存块，再将各组离散地放到各个内存块中）
- 另外，要为离散分散地页表再建立一张页表，称为页目录表，或称外层页表，或称顶层页表

#### 两级页表的原理、地址结构

- 两级也不结构的逻辑地址结构

| 31 ...... 22 | 21 ...... 12 | 11 ...... 0 |
| :----------: | :----------: | :---------: |
|   一级页号   |   二级页号   | 页内偏移量  |

#### 如何实现地址变换

- 将逻辑地址(0000000000, 0000000001, 1111111111)转换为物理地址（用十进制表示）
- ①按照地址结构讲逻辑地址拆分为三部分
- ②从PCB中读出页目录表起始地址，再根据一级页号查页目录表，找到下一级页表在内存中存放位置
- ③根据二级页号查表，找到最终想访问的内存块号
- ④结合页内偏移量得到物理地址

#### 两级页表问题需要注意的几个细节

- 若采用多级页表机制，则各级页表的大小不能超过一个页面。
  - 例：某系统按字节编址，采用40位逻辑地址，页面大小为4KB, 页表项大小为4B, 假设采用纯页式存储，则要采用几级页表，页内偏移量为多少位
  - 页面大小 = 4KB = 2^12B,按字节编址，因此页内偏移量为12位
  - 页号 = 40 - 12 = 28位
  - 页面大小 = 2^12B,页表项大小为4B, 则每个页面可存放2^12/4 = 2^10个页表项
  - 因此各级页表最多包含2^10个页表项，需要10位二进制才能映射到2^10个页表项，因此每一级的页表对应页号应为10位。总共28位需要分为三级
- 两级页表的访存次数
  - 第一次访存：访问内存中的页目录表
  - 第二次访存：访问内存中的二级页表
  - 第三次访存：访问目标内存单元

