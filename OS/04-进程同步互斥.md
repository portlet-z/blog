## 进程同步互斥概念

#### 什么是进程同步

- 知识点回顾：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的，不可预知的速度向前推进
- 进程通信--管道通信
  - 读进程和写进程并发地执行，由于并发必然导致异步性，因此写数据和对数据两个操作执行地先后顺序时不确定地。而实际应用中，又必须按照写数据->读数据地顺序来执行地。
  - 如何解决这种异步问题，就是进程同步所讨论的内容
- 同步亦称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作

#### 什么是进程互斥

- 进程的并发需要共享的支持。各个并发执行的进程不可避免的需要共享一些系统资源(比如内存，又比如打印机，摄像头这样的IO设备)
- 两种资源共享方式
  - 互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源
  - 同时共享方式：系统中某些资源，允许一个时间段内由多个进程”同时“对它们进行访问
- 我们把一个时间段内只允许一个进程使用的资源称为临界资源。许多物理设备（摄像头，打印机）都属于临界资源。此外还有许多变量，数据，内存缓冲区等都属于临界资源
- 对临界资源的访问，必须互斥地进行。互斥，亦称为间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源
- 对于临界资源的互斥访问，可以在逻辑上分为如下四个部分

```c
do {
    entry section; //进入区:负责检查是否可进入临界区，若可进入，则设置正在访问临界资源的标志（上锁），以阻止其他进程同时进入临界区
    critical section; //临界区：访问临界资源的那段代码
    exit section; //退出区：负责解除正在访问临界资源的标志（解锁）
    remainder section; //剩余区：做其他处理
} while (true)
```

- 注意：临界区时进程中访问临界资源的代码段。进入区和退出区是负责实现互斥的代码段。临界区也可称为临界段

- 为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则
  - 空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区
  - 忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待
  - 有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
  - 让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待



## 进程互斥的软件实现方法

#### 单标志法

- 算法思想：两个进程在访问完临界区后会把使用临界区的权限交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予

```c
int turn = 0; //turn 表示当前允许进入临界区的进程号
//P0 进程：
while (turn != 0);    //① 进入区
critical section;     //② 临界区
turn = 1;             //③ 退出区
remainder section;    //④ 剩余区

//P1 进程：
while (turn != 1);    //⑤ 进入区
critical section;     //⑥ 临界区
turn = 0;             //⑦ 退出区
remainder section;    //⑧ 剩余区
```

- turn的初值为0，即刚开始只允许0号进程进入临界区
- 若P1先上处理机运行，则会一直卡在⑤。直到P1的时间片用完，发生调度，切换P0上处理机运行。
- 代码①不会卡住P0,P0可以正常访问临界区，在P0访问临界区期间及时切换回P1,P1依然会卡在⑤。
- 只有P0在退出区将turn改为1后，P1才能进入临界区
- 因此，该算法可以实现“同一时刻最多只允许一个进程访问临界区”
- turn表示当前允许进入临界区的进程号，而只有当前允许进入临界区的进程在访问了临界区之后，才会修改turn的值。也就是说，对于临界区的访问，一定是按P0->P1->P0->P1->P0->....这样轮流访问。
- 这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是P0，而P0一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。
- 因此，单标志法存在的注意问题是：违背“空闲让进”原则

#### 双标志先检查

- 算法思想：设置一个布尔型数组flag[]，数组中各个元素用来标记各进程想进入临界区的意愿，比如"flag[0]=true"意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设为true，之后开始访问临界区。

```c
bool flag[2]; //表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false; //刚开始设置为两个进程都不想进入临界区
//P0进程
while(flag[1]);     //① 如果此时P1想进入临界区，P0就一直循环等待
flag[0] = true;     //② 标记为P0进程想要进入临界区
critical section;   //③ 访问临界区
flag[0] = false;     //④ 访问完临界区，修改标记为P0不想使用临界区
remainder section;

//P1进程
while(flag[0]);     //⑤ 如果此时P0想进入临界区，P1就一直循环等待
flag[1] = true;     //⑥ 标记为P1进程想要进入临界区
critical section;   //⑦ 访问临界区
flag[1] = false;     //⑧ 访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

- 若按照①⑤②⑥③⑦。。。的顺序执行，P0和P1将会同时访问临界区
- 因此，双标志先检查的主要问题是：违法“忙则等待”原则
- 原因在于，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后，“上锁”前可能发生进程切换。

#### 双标志后检查

- 双标志先检查法的改版。前一个算法的问题是先检查后上锁，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先上锁后检查的方法，来避免上述问题

```c
bool flag[2]; //表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false; //刚开始设置为两个进程都不想进入临界区
//P0进程
flag[0] = true;     //① 标记为P0进程想要进入临界区
while(flag[1]);     //② 如果此时P1想进入临界区，P0就一直循环等待
critical section;   //③ 访问临界区
flag[0] = false;     //④ 访问完临界区，修改标记为P0不想使用临界区
remainder section;

//P1进程
flag[1] = true;     //⑤ 标记为P1进程想要进入临界区
while(flag[0]);     //⑥ 如果此时P0想进入临界区，P1就一直循环等待
critical section;   //⑦ 访问临界区
flag[1] = false;    //⑧ 访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

- 若按照①⑤②⑥。。。的顺序执行，P0和P1将都无法进入临界区
- 因此，双标志后检查法虽然解决了忙则等待的问题，但是又违背了空闲让进和有限等待原则，会因各进程都长期无法访问临界资源而产生饥饿现象
- 两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区

#### Peterson算法

- 算法思想：双标志检查法中，两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。Gary L. Peterson想到了一种方法，如果双方都争着想进入临界区，那可以让进程尝试“孔融让梨”，主动让对方先使用临界区

```c
bool flag[2]; //表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false; //刚开始设置为两个进程都不想进入临界区
int turn = 0; //turn表示优先让哪个进程进入临界区

//P0进程
flag[0] = true;                  //① 标记为P0进程想要进入临界区
turn = 1;                        //② 可以优先让对方进入临界区
while(flag[1] && turn == 1);     //③ 对方想进，且最后一次是自己“让梨”，那自己就循环等待
critical section;                //④ 访问临界区
flag[0] = false;                 //⑤ 访问完临界区，修改标记为P0不想使用临界区
remainder section;

//P1进程
flag[1] = true;                  //⑥ 标记为P1进程想要进入临界区
turn = 0;                        //⑦ 可以优先让对方进入临界区
while(flag[0] && turn == 0);     //⑧ 对方想进，且最后一次是自己“让梨”，那自己就循环等待
critical section;                //⑨ 访问临界区
flag[1] = false;                 //⑩ 访问完临界区，修改标记为P1不想使用临界区
remainder section;
```

- 进入区：1.主动争取；2.主动谦让；3.检查对方是否也想使用，且最后一次不是自己说了”客气话“
- Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进，忙则等待，有限等待三个原则，但是依然未遵循让权等待的原则
- Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好



## 进程互斥的硬件实现方法

#### 中断屏蔽方法

- 利用“开/关中断指令”实现（与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况）

```c
//...
//关中断; 关中断后即不允许当前进程被中断，也必然不会发生进程切换
//临界区;
//开中断; 直到当前进程访问完临界区，再执行开中断指令，才有可能有别的进程上处理机访问临界区
//...
```

- 优点：简单，高效
- 缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

#### TestAndSet(TS指令/TSL指令)

- 简称TS指令，也有地方称为TestAndSetLock指令，或称TSL指令
- TSL指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是C语言描述的逻辑

```c
//布尔型共享变量lock表示当前临界区是否被加锁
//true表示已加锁，false表示未加锁
bool TestAndSet(bool *lock) {
    bool old;
    old = *lock;    //old用来存放lock原来的值
    *lock = true;   //无论之前是否已加锁，都将lock设为true
    return old;     //返回lock原来的值
}

//以下是使用TSL指令实现互斥的算法逻辑
while (TestAndSet(&lock)); //上锁并检查
//临界区代码段。。。
lock = false;    //解锁
//剩余区代码段
```

- 若刚开始lock是false,则TSL返回old的值是false,while循环条件不满足，直到跳过循环，进入临界区。若刚开始lock是true,则执行TSL后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区解锁
- 相比软件实现方法，TSL指令把上锁和检查操作用硬件的方式变成了一气呵成的原子操作。
- 优点：实现简单，无需像软件实现方法那些严格检查是否会有逻辑漏洞；适用于多处理机环境
- 缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL执行，从而导致忙等

#### Swap指令(XCHG指令)

- 有的地方也叫Exchange指令，或简称XCHG指令
- Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是C语言描述的逻辑

```c
//Swap指令的作用是交换两个变量的值
void Swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b; 
    *b = temp;
}

//以下是用Swap指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old = true;
while (old) {
    Swap(&lock, &old);
}
//临界区代码段
lock = false;
//剩余区代码段
```

- 逻辑上来看Swap和TSL并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true,最后检查old,如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区
- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境
- 缺点：不满足让权等待原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等



## 信号量机制

- 在双标志先检查法中，进入区的检查、上锁操作无法一气呵成，从而导致两个进程有可能同时进入临界区的问题
- 所有的解决方案都无法实现让权等待
- 1965年，荷兰学者Dijkstra提出了一种卓有成效的实现进程互斥，同步的方法--信号量机制
- 用户进程可以通过使用操作系统提供的一对原语来对信号量进程操作，从而很方便的实现了进程互斥，进程同步
- 信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量
- 原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用原语实现，使这些操作能一气呵成就能避免问题
- 一对原语：wait(S)原语和signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为wait和signal，括号里的信号量S其实就是函数调用时传入的一个参数
- wait,signal原语常简称为P,V操作（来自荷兰语proberen和verhogen）。因此，常把wait(S),signal(S)两个操作分别写为P(S),V(S)

#### 整型信号量

- 用一个整型的变量作为信号量，用来表示系统中某种资源的数量。
- 与普通整数变量区别：对信号量的操作只有三种，即初始化，P操作，V操作

```c
int S = 1;  //初始化整型信号量S，用来表示系统中可用打印机资源数

//检查和上锁一气呵成，避免了并发，异步导致的问题
//存在的问题：不满足让权等待原则，会发生忙等
void wait(int S) {    //wait原语，相当于进入区
    while(S <= 0);    // 如果资源数不够，就一直等待
    S--;              // 如果资源数够，则占用一个资源
}

void signal(int S) {  // signal原语，相当于退出区
    S++;              // 使用完资源后，在退出区释放资源
}

//进程P0
//...
wait(S);          //进入区，申请资源
//使用打印机资源    //临界区，访问资源
signal(S);       //退出区，释放资源
//...

//进程P1
//...
wait(S);          //进入区，申请资源
//使用打印机资源    //临界区，访问资源
signal(S);       //退出区，释放资源
//...

//进程Pn
//...
wait(S);          //进入区，申请资源
//使用打印机资源    //临界区，访问资源
signal(S);       //退出区，释放资源
//...
```

#### 记录型信号量

- 整型信号量的缺陷是存在忙等问题，因此人们又提出了记录型信号量，即用记录型数据结构表示的信号量

```c
//记录型信号量的定义
typedef struct {
    int value;           //剩余资源数
    struct process *L;   //等待队列
} semphore;

//某种进程需要使用资源时，通过wait原语申请
void wait(semphore S) {
    S.value--;
    if (S.value < 0) {
        block(S.L); //如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中
    }
}

//进程使用完资源后，通过signal原语释放
void signal(semphore S) {
    S.value++;
    if (S.value <= 0) {
        wakeup(S.L); //释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
    }
}
```

- S.value的初值表示系统中某种资源的数目
- 对信号量S的一次P操作意味着进程请求一个单位的该来资源，因此需要S.value--,表示资源数减1，当S.value<0时表示该类资源已分配完毕，因此进程应调用block原语进行自我阻塞（当前运行的进程从运行态->阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。可见，该机制遵循了让权等待原则，不会出现忙等现象
- 对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行S.value++，表示资源数加1，若加1后仍是S.value <=0 ,表示依然又进程在等待该类资源，因此调用wakeup原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态->就绪态）



