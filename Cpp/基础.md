### 常量的定义

- 使用#define, 如： #define PI 3.1415926

- 使用const, 如：const double PI = 3.1415926;

- 注：尽量使用const定义常量，#define不会出现在编译期

### 整数常量

- 整数常量可以是十进制、八进制或十六进制的常量

- 前缀指定基数：0x或0X表示十六进制，0表示八进制，不带前缀默认表示十进制

- 整数常量也可以带一个后缀，后缀是U和L的组合，U表示无符号整数(unsigned),L表示长整数(long).后缀可以是大写，也可以是小写，U和L的顺序任意

### 字符常量

- 字符常量是括在单引号中。如果常量以L(仅当大写时)开头，则表示它是一个宽字符常量(例如L'x'),此时它必须存储在wchar_t类型的变量中。否则，它就是一个窄字符常量(例如'x'),此时它可以存储在char类型的简单变量中

- 字符常量可以是一个普通的字符，一个转义序列，或一个通用的字符('\u02C0')

### 字符串的常见操作

- 字符串长度: strlen(s).注意s的长度不包括'\0'

- 字符串比较: strcmp(s1, s2). s1==s2返回0，s1 < s2返回小于0

- 字符串拷贝: strcpy(s1, s2).复制字符串s2到字符串s1

- 复制指定长度字符串： strncpy(s1, s2, n):将字符串s2中前n个字符拷贝到s1中

- 字符串拼接: strcat(s1, s2):将字符串s2接到s1后面

- 查找字符串：strchr(s1, ch):指向字符串s1中字符ch的第一次出现的位置

- strstr(s1, s2):指向字符串s1中字符串s2的第一次出现的位置

- 注：请使用strlen)s, strcpy_s, strncpy_s, strcat_s等API函数，更安全

### C++中的string

- C++标准库提供了string类型专门表示字符串：#include <string> 

- 使用string可以更方便和安全的管理字符串

- 定义字符串变量
  
  - string s;
  
  - string s = "hello world";
  
  - string s("hello world");
  
  - string s = string("hello world");

- 获取字符串的长度
  
  - std::cout << s1.length() << std::endl;
  
  - std::cout << s1.size() << std::endl;
  
  - std::cout << s1.capacity() << std::endl;

- 字符串比较
  
  - string s1 = "hello", s2 = "world";
  
  - std::cout << (s1 == s2) << std::endl;
  
  - std::cout << (s1 != s2) << std::endl;

- 转换为C风格的字符串
  
  - const char* c_str1 = s1.c_str();
  
  - std::cout << "The C-style string c_str1 is:" << c_str1 << std::endl;

- 随机访问(获取字符串中某个字符串)
  
  - string s = "hello"; std::cout << s[0] << std::endl;

- 字符串拷贝： string s1 = "hello"; string s2 = s1;

- 字符串连接：+， +=
  
  - string s1 = "hello", s2 = "world";
  
  - string s3 = s1 + s2; //s3 helloworld
  
  - s1 += s2; // s1 helloworld

- 总结：string结合了C++的新特性，使用起来比原始的C风格方法更安全和方便，对性能要求不是特别搞的场景可以使用



### 数组与指针

```cpp
int main() {
    char strHelloWorld[] = {"helloworld"};
    char* pStrHelloWorld = "helloworld";
    pStrHelloWorld = strHelloWorld; //指针变量的值允许改变
    //strHelloWorld = pStrHelloWorld; //数组变量的值不允许改变
    return 0;
}
```

- strHelloWorld不可变，strHelloWorld[index]的值可以变；

- pStrHelloWorld可变，pStrHelloWorld[index]的值可变不可变取决于所指区间的存储区是否可变



### 左值与右值

- 左值：一般说法，编译器为其单独分配了一块存储空间，可以取其地址的，左值可以放在赋值运算符左边

- 右值指的是数据本身，不能取到其自身地址，右值只能赋值运算右边

- 左值最常见的情况如函数和数据成员的名字；

- 右值是没有标识符、不可以取地址的表达式，一般也称之为”临时对象“

- 比如：a = b+c; &a是允许的操作；而&(b+c)不能通过编译，因此a是一个左值，而(b+c)是一个右值



### C++中的原始指针

- 一般类型指针T*, T是一个泛型，泛指任何一种类型

```cpp
int i=4; int* iP = &i; cout << (*iP) << endl;
```

- 指针的数组(array of pointers)与数组的指针(a pointer to an array):
  
  - 指针的数组 T* t[] 如int* a[4];
  
  - 数组的指针 T(*)t[] 如int(*)b[4]

```cpp
#include <iostream>
using namespace std;

int main() {
    int c[4] = {static_cast<int>(0x80000000), static_cast<int>(0xFFFFFFFF), 0x00000000, 0x7FFFFFFF};
    int* a[4]; //array of pointers
    int(*b)[4]; //a pointer to an array
    b = &c;
    for (int i = 0; i < 4; ++i) {
        a[i] = &(c[i]);
    }
    cout << *(a[0]) << endl;
    cout << (*b)[3] << endl;
    return 0;
}
```

- 未初始化和非法的指针
  
  - 如：int* a;  *a = 12;
  
  - 运气好的话：定位到一个非法地址，程序会出错，从而终止
  
  - 最坏的情况：定位到一个可以访问的地址，无意修改了它，这样的错误难以捕捉，引发的错误可能与原先用于操作的代码完全不相干！
  
  - 用指针进行间接访问之前，一定要非常小心，确保它已经初始化，并被恰当的赋值。

- NULL指针：一个特殊的指针变量，表示不指向任何东西。如：int* a = NULL;
  
  - NULL指针的概念非常有用：它给了一种方法，来表示特定的指针目前未指向任何东西
  
  - 使用的注意事项：对于一个指针，如果已经知道将被初始化为什么地址，那么请赋给它这个地址值，否则请把它设置为NULL.在对一个指针进行间接引用前，请先判断这个指针的值是否为NULL

```cpp
#include <iostream>
using namespace std;

int main() {
    //指针的指针
    int a = 123;
    int* b = &a;
    int** c = &b;

    //NULL的使用
    int* pA = NULL;
    pA = &a;
    if (pA != NULL) {
        cout << (*pA) << endl;
    }
    pA = NULL;
    return 0;
}
```

- 杜绝”野“指针：指向”垃圾“内存的指针。if等判断对它们不起作用，因为没有设置NULL;
  
  - 一般有三种情况：①指针变量没有初始化②已经释放不用的指针没有置NULL,如delete和free之后的指针③指针操作超越了变量的作用范围
  
  - 指针使用的注意事项：没有初始化的，不用的或者超出范围的指针请把值置为NULL
