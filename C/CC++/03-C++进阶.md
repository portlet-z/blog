# 函数模板
## 函数模板基本语法
```c++
#include <iostream>
using namespace std;

//让类型参数化，方便程序员进行编码
//泛型编程
template <typename T>
void swap0(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

void main() {
	int x = 10;
	int y = 20;
	//函数模板的调用
	//显示类型调用
	swap0<int>(x, y);
	cout << "x: " << x << ", y: " << y << endl;

	//自动类型推导
	char a = 'a';
	char b = 'b';
	swap0(a, b);
	cout << "a: " << a << ", b: " << b << endl;
	system("pause");
}
```
## 函数模板当函数参数
```c++
#include <iostream>
using namespace std;

template <typename T>
int sort(T* array, int size) {
	if (array == NULL) {
		return -1;
	}
	for (int i = 0; i < size; i++) {
		for (int j = i + 1; j < size; j++) {
			if (array[i] >= array[j]) {
				continue;
			}
			T tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
	}
	return 0;
}

template <typename T>
void print(T* array, int size) {
	for (int i = 0; i < size; i++) {
		cout << array[i] << " ";
	}
	cout << endl;
}

void main() {
	int array[] = { 11, 2, 23, 33, 12, 2, 6, 9 };
	int size = sizeof(array) / sizeof(int);
	sort(array, size);
	print(array, size);

	char c_arr[] = { 'a', 'd', 'b', 'c' };
	int c_size = sizeof(c_arr) / sizeof(char);
	sort(c_arr, c_size);
	print(c_arr, c_size);
	system("pause");
}
```
## 函数模板遇上函数重载
- 普通函数的调用：可以进行隐式的类型转换
- 模板函数的调用（本质：类型参数化）：将严格按照类型进行匹配，不会进行自动类型转换
- 当函数模板和普通函数都符合调用时，优先选择普通函数
```c++
#include <iostream>
using namespace std;

template <typename T>
void swap1(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "模板函数" << endl;
}

void swap1(int& a, int& b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "普通函数" << endl;
}

void main() {
	int x = 10;
	int y = 20;
	swap1(x, y); //普通函数
	cout << "x: " << x << ", y: " << y << endl;
	system("pause");
}
```
- 函数模板可以向普通函数一样被重载
- C++编译器优先考虑普通函数
- 如果函数模板可以产生一个更好的匹配，那么选择模板
- 可以通过空模板实参列表的语法限定编译器只通过模板匹配
```c++
#include <iostream>
using namespace std;

void max0(int a, int b) {
	cout << "普通函数" << endl;
}

template <typename T>
void max0(T a, T b) {
	cout << "模板函数" << endl;
}

void main() {
	int a = 1;
	int b = 2;
	max0(a, b);   // 当函数模板和普通函数都符合调用时，优先选择普通函数
	max0<>(a, b); //若显示使用函数模板，则使用<>类型列表
	max0(3.0, 4.0); //如果函数模板产生更好的匹配，使用函数模板
	max0('a', 100); //调用普通函数，可以隐式类型转换
	system("pause");
}
```
## 函数模板原理
- 编译器并不是把函数模板处理成能够处理任意类的函数
- 编译器从函数模板通过具体类型产生不同的函数
- 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译
# 类模板
## 类模板基本语法
```c++
#include <iostream>
using namespace std;

template <typename T>
class A {
private:
	T t;
public:
	A(T t) {
		this->t = t;
	}
	void print() {
		cout << "t:" << t << endl;
	}
};

//类模板做函数参数
//参数C++编译器要求具体的类，所以要A<int>& a
void useA(A<int>& a) {
	a.print();
}

void main() {
	A<int> a1(100);
	a1.print();
	useA(a1);

	A<char> a2('b');
	a2.print();

	A<string> a3("hello");
	a3.print();
	system("pause");
}
```
## 派生类类模板
- 子模版类派生时，需要具体化模板类，C++编译器需要知道父类的数据类型具体是什么样子的
- 要知道父类所占的内存大小是多少，只有数据类型固定下来，才知道如何分配内存
```c++
class B : public A<int> {
private:
	int b;
public:
	B(int a, int b) : A(a) {
		this->b = b;
	}
};
```
- 从模板类派生模板类
```c++
template <typename T>
class C : public A<T> {
private:
	T c;
public:
	C(T a, T c) : A<T>(a) {
		this->c = c;
	}
	void print() {
		cout << "c: " << c << endl;
	}
};
```
## 复数类
- Complex.h
```c++
#pragma once
#include <iostream>
using namespace std;

template <typename T>
class Complex {
private:
	T a;
	T b;
	friend ostream& operator<<<T>(ostream& out, Complex& c);
public:
	Complex(T a, T b);
	void print();
	Complex operator+(Complex& other);
	Complex operator-(Complex& other);
};
```
- Complex.hpp
```c++
#include <iostream>
#include "Complex.h"
using namespace std;

template <typename T>
Complex<T>::Complex(T a, T b) {
	this->a = a;
	this->b = b;
}

template <typename T>
void Complex<T>::print() {
	cout << "a: " << a << ", b: " << b << endl;
}

template <typename T>
Complex<T> Complex<T>::operator+(Complex<T>& other) {
	Complex tmp(a + other.a, b + other.b);
	return tmp;
}

template <typename T>
Complex<T> Complex<T>::operator-(Complex<T>& other) {
	Complex tmp(a - other.a, b - other.b);
	return tmp;
}

template <typename T>
ostream& operator<<(ostream& out, Complex<T>& c) {
	out << c.a << " + " << c.b << "i";
	return out;
}
```
- test.cpp
```c++
#include <iostream>
#include "Complex.hpp" //必须引进hpp文件 hpp可以理解为h头文件的增强
using namespace std;

void main() {
	Complex<int> c1(1, 2);
	Complex<int> c2(3, 4);
	Complex<int> c3 = c1 + c2;
	cout << c3 << endl;
	c3.print();

	Complex<int> c4 = c2 - c1;
	cout << c4 << endl;
	c4.print();
	system("pause");
}
```
## 类模板中的static关键字
```c++
#include <iostream>
using namespace std;

template <typename T>
class AA {
public:
	static T a;
};

template <typename T>
T AA<T>::a = 0;

void main() {
	AA<int> a1, a2, a3;
	a1.a = 10;
	a2.a++;
	a3.a++;
	cout << a1.a << endl; //12
	AA<double> a4, a5, a6;
	cout << a4.a << endl; //0 不同类型的类，不共用静态变量；相同类型的类共用同一个静态变量
	system("pause");
}
```
## 数组容器
- Vector.h
```c++
#include <iostream>
using namespace std;

template <typename T>
class Vector {
private:
	int len;
	T* space;
	friend ostream& operator<<<T>(ostream& out, Vector& v);
public:
	Vector(int size = 0);//构造函数
	Vector(const Vector& other);//拷贝构造函数
	~Vector();//析构函数
	int getLen() {
		return this->len;
	}
public:
	T& operator[](int index); //重载[]运算符
	Vector& operator=(const Vector& other);
};
```
- Vector.hpp
```c++
#include "Vector.h"

template <typename T>
Vector<T>::Vector(int size) {
	len = size;
	space = new T[len];
}

template <typename T>
Vector<T>::Vector(const Vector& other) {
	len = other.len;
	space = new T[other.len];
	for (int i = 0; i < other.len; i++) {
		space[i] = other.space[i];
	}
}

template <typename T>
Vector<T>::~Vector() {
	if (space != NULL) {
		delete[] space;
		space = NULL;
	}
	len = 0;
}

template <typename T>
T& Vector<T>::operator[](int index) {
	return space[index];
}

template <typename T>
Vector<T>& Vector<T>::operator=(const Vector<T>& other) {
	if (space != NULL) {
		delete[] space;
		space = NULL;
		len = 0;
	}
	len = other.len;
	space = new T[other.len];
	for (int i = 0; i < other.len; i++) {
		space[i] = other.space[i];
	}
	return *this;
}

template <typename T>
ostream& operator<<(ostream& out, Vector<T>& v) {
	for (int i = 0; i < v.getLen(); i++) {
		out << v[i] << " ";
	}
	return out;
}
```
- VectorTest.cpp
```c++
#include "Vector.hpp"

class Teacher {
private:
	int age;
	char first_name[32];
	char* second_name;
	friend ostream& operator<<(ostream& out, const Teacher& t);
public:
	Teacher() {
		age = 0;
		strcpy(first_name, "");
		second_name = new char[1];
		strcpy(second_name, "");
	}
	Teacher(int age, const char* first_name, const char* second_name) {
		this->age = age;
		strcpy(this->first_name, first_name);
		this->second_name = new char[strlen(second_name) + 1];
		strcpy(this->second_name, second_name);
	}
	Teacher(const Teacher& other) {
		age = other.age;
		strcpy(first_name, other.first_name);
		if (second_name != NULL) {
			delete[] second_name;
			second_name = NULL;
		}
		second_name = new char[strlen(other.second_name) + 1];
		strcpy(second_name, other.second_name);
	}
	//vector有析构函数delete[]space的时候会将second_name释放
	//~Teacher() {
	//	if (second_name != NULL) {
	//		delete[] second_name;
	//		second_name = NULL;
	//	}
	//}
	void print() {
		cout << first_name << "," << age << endl;
	}
	Teacher& operator=(const Teacher& other) {
		if (second_name != NULL) {
			delete[] second_name;
			second_name = NULL;
		}
		age = other.age;
		strcpy(first_name, other.first_name);
		second_name = new char(strlen(other.second_name) + 1);
		strcpy(second_name, other.second_name);
		return *this;
	}
};

ostream& operator<<(ostream& out, const Teacher& t) {
	out << t.first_name << " " << t.second_name << " " << t.age;
	return out;
}

void main() {
	Vector<int> v1(10);
	for (int i = 0; i < v1.getLen(); i++) {
		v1[i] = i + 1;
	}
	Vector<int> v2 = v1;
	for (int i = 0; i < v2.getLen(); i++) {
		cout << v2[i] << " ";
	}
	cout << endl;
	cout << v2 << endl;

	Teacher t1(31, "a", "aa");
	Vector<Teacher> vt(1);
	vt[0] = t1;
	/*vt[1] = t2;
	vt[2] = t3;*/
	cout << vt << endl;
	system("pause");
}
```
# C++的类型转换
## 类型转换基本语法
- C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是Type b = (Type)a;
- C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用
	- static_cast:静态类型转换。如int转换成char
	- reinterpret_cast:重新解释类型
	- dynamic_cast: 命名上理解是动态类型转换。如子类和父类之间的多态类型转换
	- const_cast: 字面上理解就是去const属性
```c++
#include <iostream>
using namespace std;

class Animal {
public:
	virtual void cry() = 0;
};

class Dog : public Animal {
public:
	void cry() {
		cout << "汪汪" << endl;
	}
	void doHome() {
		cout << "看家" << endl;
	}
};

class Cat : public Animal {
public:
	void cry() {
		cout << "喵喵" << endl;
	}
	void doCatch() {
		cout << "抓老鼠" << endl;
	}
};

class Tree {

};

void animal_play(Animal* base) {
	base->cry(); //1有继承 2虚函数重写 3父类指针指向子类对象 --> 多态
	//能识别子类对象
	// dynamic_cast 运行时类型识别
	Dog* dog = dynamic_cast<Dog*>(base);
	if (dog != NULL) {
		dog->doHome();
	}
	Cat* cat = dynamic_cast<Cat*>(base);
	if (cat != NULL) {
		cat->doCatch();
	}
}

void printBuf(const char* p) {
	//p[0] = 'z';//编译错误
	char* tmp = NULL;
	tmp = const_cast<char*>(p); //把只读属性去掉,得确定所指向的内存空间确实能够修改
	tmp[0] = 'z';
	cout << p << endl;
}

void main() {
	double pi = 3.1415926;
	int num1 = (int)pi; //C类型转换
	cout << num1 << endl;
	int num2 = pi; //隐式类型转换，隐式类型转换的地方均可使用static_cast<>()进行类型转换
	cout << num2 << endl;

	//静态类型转换：编译时编译器会做类型检查
	int num3 = static_cast<int>(pi); 
	cout << num3 << endl;

	//char* ===> int*
	const char* p1 = "hello";
	const int* p2 = NULL;
	// 使用static_cast编译时会做类型检查，下面编译时会报错
	//p2 = static_cast<const int*>(p1);
	//若不同类型之间，进行强制类型转换，用reinterpret_cast<>()进行重新解释
	p2 = reinterpret_cast<const int*>(p1);
	cout << p1 << endl;
	cout << p2 << endl;
	//总结：通过reinterpret_cast<>()和static_cast<>()把C语言的强制类型转换都覆盖了

	Dog d1;
	Cat c1;
	animal_play(&d1);
	animal_play(&c1);

	Animal* base = NULL;
	base = &d1;
	base = static_cast<Animal*>(&d1);
	base = reinterpret_cast<Animal*>(&d1);

	Tree* tree;
	//tree = static_cast<Tree*>(&d1); 编译时报错
	//base = static_cast<Animal*>(&tree); 编译时报错
	tree = reinterpret_cast<Tree*>(&d1);
	base = reinterpret_cast<Animal*>(&tree);

	char buf[] = "hello world";
	printBuf(buf);
	const char* p = "hello world";
	// printBuf(p); 运行出错，p所指向的内存空间不能修改
	system("pause");
}
```
# 异常处理
## 异常基本语法
```c++
#include <iostream>
using namespace std;

int divide(int x, int y) {
	if (y == 0) {
		throw x;
	}
	return x / y;
}

void main() {
	try {
		int i = divide(1, 0);
		cout << i << endl;
	}
	catch (int e) {
		cout << "被零除" << e << endl;
	} 
	catch (...) {
		cout << "未知异常" << endl;
	}
	system("pause");
}
```
## 栈解旋(unwinding)
- 异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋unwinding
```c++
#include <iostream>
using namespace std;

class Test {
private:
	int a;
public:
	Test(int a = 0) {
		this->a = a;
		cout << "Test Constructor:" << a << endl;
	}
	~Test() {
		cout << "Test Destrcutor:" << a << endl;
	}
};

void my_divide() {
	Test t1(1);
	Test t2(2);
	Test t3(3);
	cout << "发生异常" << endl;
	throw 1;
}

void main() {
	try {
		my_divide();
	}
	catch (int e) {
		cout << "异常" << e << endl;
	}
	system("pause");
}
```
## 异常接口声明
- void func() throw (A,B,C,D);//这个函数func能够且只能抛出A B C D及其子类型的异常
- void func(); //没有异常接口声明，可以抛出任意类型的异常
- 一个不抛任何类型异常的函数可以声明为: void func() throw();
## 异常变量的生命周期
```c++
#include <iostream>
using namespace std;

//传统错误处理
int my_strcpy(char* to, char* from) {
	if (from == NULL) {
		return 1;
	}
	if (to == NULL) {
		return 2;
	}
	if (*from == 'a') {
		return 3;
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
	return 0;
}

void main_() {
	int ret = 0;
	char buf1[] = "abcdefg";
	char buf2[1024] = { 0 };
	ret = my_strcpy(buf2, buf1);
	if (ret != 0) {
		switch (ret) {
		case 1:
			cout << "源buf出错" << endl;
			break;
		case 2:
			cout << "目的buf出错" << endl;
			break;
		case 3:
			cout << "copy过程出错" << endl;
			break; 
		default:
			cout << "未知错误" << endl;
			break;
		}
	}
	else {
		cout << buf2 << endl;
	}

	system("pause");
}

// throw int
void my_strcpy1(char* to, char* from) {
	if (from == NULL) {
		throw 1;
	}
	if (to == NULL) {
		throw 2;
	}
	if (*from == 'a') {
		throw 3;
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

// throw char*
void my_strcpy2(char* to, char* from) {
	if (from == NULL) {
		throw "源buf出错";
	}
	if (to == NULL) {
		throw "目的buf出错";
	}
	if (*from == 'a') {
		throw "copy过程出错";
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

class SourceError {

};

class DestinationError {

};

class ProcessError {
public:
	ProcessError() {
		cout << "ProcessError Constructor" << endl;
	}
	~ProcessError() {
		cout << "ProcessError Destructor" << endl;
	}
	ProcessError(ProcessError& other) {
		cout << "ProcessError Copy Constructor" << endl;
	}
};

// throw 类对象
void my_strcpy3(char* to, char* from) {
	if (from == NULL) {
		throw SourceError();
	}
	if (to == NULL) {
		throw DestinationError();
	}
	if (*from == 'a') {
		throw ProcessError(); //产生一个匿名对象
		//ProcessError e;
		//throw &e; //指针被抛出后，就会被析构，产生野指针
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

void main() {
	char buf1[] = "abcdefg";
	char buf2[1024] = { 0 };
	try {
		my_strcpy1(buf2, buf1);
		cout << buf2 << endl;
	}
	catch (int e) {
		cout << "int类型异常:" << e << endl;
	}
	catch (...) {
		cout << "未知异常" << endl;
	}
	try {
		my_strcpy2(buf2, buf1);
		cout << buf2 << endl;
	}
	catch (const char* e) {
		cout << e << endl;
	}
	catch (...) {
		cout << "未知异常" << endl;
	}
	try {
		my_strcpy3(buf2, buf1);
		cout << buf2 << endl;
	}
	catch (SourceError e) {
		cout << "SourceError" << endl;
	}
	catch (DestinationError e) {
		cout << "DestinationError" << endl;
	}
	//结论：1如果接受异常的时候使用一个异常变量，则copy构造异常变量
	catch (ProcessError e) { //是把匿名对象copy给e
		cout << "ProcessError" << endl;
	}
	//结论2：使用引用的话会使用throw时的那个对象
	//catch (ProcessError& e) { //不会发生copy构造
	//	cout << "ProcessError" << endl;
	//}
	//结论3:指针可以和引用/元素写在一起，但是元素和引用不能写在一块
	catch (ProcessError* e) {
		cout << "ProcessError *" << endl;
	}
	catch (...) {
		cout << "未知异常" << endl;
	}
	system("pause");
}
```
## 异常的层次结构
```c++
#include <iostream>
using namespace std;

class Array {
private:
	int* space;
	int len;
public:
	Array(int len);
	~Array();
	int& operator[](int index);
	int getLen();
	class eSize {
	protected:
		int size;
	public:
		eSize(int size) {
			this->size = size;
		}
		virtual void printErr() {
			cout << "size:" << size << endl;
		}
	};
	class eNegative : public eSize {
	public:
		eNegative(int size) : eSize(size) {

		}
		void printErr() {
			cout << "eNegative Error:" << size << endl;
		}
	};
	class eZero : public eSize {
	public:
		eZero(int size) : eSize(size) {

		}
		void printErr() {
			cout << "eZero Error:" << size << endl;
		}
	};
	class eTooBig : public eSize {
	public:
		eTooBig(int size) : eSize(size) {

		}
		void printErr() {
			cout << "eTooBig Error:" << size << endl;
		}
	};
	class eTooSmall : public eSize {
	public:
		eTooSmall(int size) : eSize(size) {

		}
		void printErr() {
			cout << "eTooSmall Error:" << size << endl;
		}
	};
};

Array::Array(int len) {
	if (len < 0) {
		throw eNegative(len);
	}
	else if (len == 0) {
		throw eZero(len);
	}
	else if (len > 1000) {
		throw eTooBig(len);
	}
	else if (len < 3) {
		throw eTooSmall(len);
	}
	space = new int[len];
	this->len = len;
}

Array::~Array() {
	if (space != NULL) {
		delete[] space;
		space = NULL;
	}
	len = 0;
}

int& Array::operator[](int index) {
	return space[index];
}

int Array::getLen() {
	return len;
}

// 不推荐的catch处理方式
void main120() {
	try {
		Array array(-5);
		for (int i = 0; i < array.getLen(); i++) {
			array[i] = i + 1;
			cout << array[i] << endl;
		}
	}
	catch (Array::eNegative& e) {
		cout << "eNegative Error" << endl;
	}
	catch (Array::eZero& e) {
		cout << "eZero Error" << endl;
	}
	catch (Array::eTooBig& e) {
		cout << "eTooBig Error" << endl;
	}
	catch (Array::eTooSmall& e) {
		cout << "eTooSmall Error" << endl;
	}
	catch (...) {
		cout << "Unknown Error" << endl;
	}
	
	system("pause");
}

void main() {
	try {
		Array array(-5);
		for (int i = 0; i < array.getLen(); i++) {
			array[i] = i + 1;
			cout << array[i] << endl;
		}
	}
	catch (Array::eSize& e) {
		e.printErr();
	}
	catch (...) {
		cout << "Unknown Error" << endl;
	}

	system("pause");
}
```
## 标准库中的异常
```c++
#include <iostream>
#include <stdexcept>
using namespace std;

class Student {
private:
	int age;
public:
	Student(int age) {
		if (age > 100) {
			/*
			explicit 关键字的作用是不让参数做隐式类型转换，强制完全匹配才行
			string message = "年龄太大";
			throw out_of_range(message);
			explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str()) {}
			throw out_of_range("年龄太大");
			explicit out_of_range(const char* _Message) : _Mybase(_Message) {}
			*/
			throw out_of_range("年龄太大");
		}
		this->age = age;
	}
};

void main130() {
	try {
		Student s1(110);
	}
	catch (out_of_range e) {
		cout << e.what() << endl;
	}
	
	system("pause");
}

class MyException : public exception {
private:
	const char* p;
public:
	MyException(const char* p) {
		this->p = p;
	}
	virtual const char* what() {
		cout << "MyException: " << p << endl;
		return p;
	}
};

void testMyException() {
	throw MyException("my error");
}

void main() {
	try {
		Student s1(110);
	}
	catch (out_of_range e) {
		cout << e.what() << endl;
	}
	try {
		testMyException();
	}
	catch (MyException e) {
		cout << e.what() << endl;
	}
	system("pause");
}
```
# 流
## 标准输入流
```c++
#include <iostream>
#include <string>
using namespace std;

/*
cin.get() //一次只能读取一个字符
cin.get(一个参数) //读一个字符
cin.get(三个参数) //可以的读取字符串
cin.getline()
cin.ignore()
cin.peek() //返回缓冲区的第一个数据
cin.putback()
*/

void main() {
	cout << "Please enter a numer or a word: ";
	char c = cin.get();
	if ((c >= '0') && (c <= '9')) {
		int n;
		cin.putback(c);
		cin >> n;
		cout << "You entered a number: " << n << endl;
	}
	else {
		string str;
		cin.putback(c);
		getline(cin, str);
		cout << "You entered a word: " << str << endl;
	}
	system("pause");
}

void main144() {
	char buf1[256] = { 0 };
	char buf2[256] = { 0 };
	cout << "请输入一个字符串含有多个空格aa bbccdd" << endl;
	cin >> buf1;
	cin.ignore(1);
	int myint = cin.peek();
	cout << "myint:" << myint << endl;
	cin >> buf2;
	cout << "buf1: " << buf1 << endl;
	cout << "buf2: " << buf2 << endl;
	system("pause");
}

void main143() {
	char buf1[256] = { 0 };
	char buf2[256] = { 0 };
	cout << "请输入一个字符串含有多个空格" << endl;
	cin >> buf1;
	cin.getline(buf2, 256);
	cout << "buf1: " << buf1 << endl;
	cout << "buf2: " << buf2 << endl;
	system("pause");
}

void main142() {
	char a, b, c;
	cout << "cin.get(a)如果缓冲区没有数据，则程序阻塞" << endl;
	cin.get(a);
	cin.get(b);
	cin.get(c);
	cout << a << b << c << endl;
	cin.get(a).get(b).get(c);
	cout << a << b << c << endl;
	system("pause");
}

void main141() {
	char ch;
	while ((ch = cin.get()) != EOF) {
		cout << ch << endl;
	}
}

void main140() {
	char myBuf[1024];
	int myInt;
	long myLong;
	cin >> myInt;
	cin >> myLong;
	cin >> myBuf; //遇见空格停止接受数据
	cout << "myInt: " << myInt << endl;
	cout << "myLong: " << myLong << endl;
	cout << "myBuf: " << myBuf << endl;
	system("pause");
}
```
## 标准输出流
```c++
#include <iostream>
using namespace std;
/*
标准输出流对象 cout
cout.flush()
cout.put()
cout.write()
cout.width()
cout.fill()
cout.self()
*/

void main() {
	cout << "hello" << endl;
	cout.put('h').put('e').put('l').put('l').put('o').put('\n');

	const char* p = "hello world";
	cout.write(p, strlen(p)).put('\n');
	cout.write(p, strlen(p) - 4).put('\n');

	cout << "start";
	cout.width(30);
	cout.fill('*');
	cout << "end" << endl;
	system("pause");
}
```
## 文件IO
```c++
#include <iostream>
#include <fstream>
using namespace std;

void main() {
	const char* fname = "D:/cfg.ini";
	ofstream fout(fname, ios::app); //建立一个输出流对象和文件关联, ios::app追加, ios::binary二进制文件
	if (!fout) {
		cout << "open file error" << endl;
		return;
	}
	fout << "hello...1" << endl; //写文件
	fout << "hello...2" << endl; //写文件
	fout << "hello...3" << endl; //写文件
	fout.close();

	ifstream fin(fname); //建立一个输入流对象和文件关联
	char ch;
	while ((ch = fin.get()) != EOF) { //读文件
		cout << ch;
	}
	fin.close();
	system("pause");
}
```
# STL(标准模板库)
## 容器算法迭代器入门
```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void vector_test1() {
	vector<int> v1; //1.容器
	v1.push_back(-1);
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(3);
	v1.push_back(5);
	for (int i = 0; i < v1.size(); i++) {
		cout << v1[i] << endl;
	}
	// 2.迭代器：相当于一个指针
	for (vector<int>::iterator it = v1.begin(); it != v1.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
	// 3.算法： 算法和迭代器无缝对接
	int num1 = count(v1.begin(), v1.end(), 3); //等于3的个数
	cout << num1 << endl;
}

class Teacher {
public:
	int age;
public:
	void print() {
		cout << "age: " << age << endl;
	}
};

void vector_test2() {
	Teacher t1, t2, t3;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	vector<Teacher> v1; //容器实现了数据类型和算法的分离
	v1.push_back(t1);
	v1.push_back(t2);
	v1.push_back(t3);
	for (vector<Teacher>::iterator it = v1.begin(); it != v1.end(); it++) {
		it->print();
	}
}

void vector_test3() {
	Teacher t1, t2, t3;
	t1.age = 31;
	t2.age = 32;
	t3.age = 33;
	vector<Teacher*> v1; //容器实现了数据类型和算法的分离
	v1.push_back(&t1);
	v1.push_back(&t2);
	v1.push_back(&t3);
	for (vector<Teacher*>::iterator it = v1.begin(); it != v1.end(); it++) {
		(*it)->print();
	}
}

int main() {
	vector_test1();
	vector_test2();
	vector_test3();

	cin.get();
	return 0;
}
```
## string
```c++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

//字符粗的初始化
void string_test1() {
	string s1 = "hello";
	string s2("world");
	string s3 = s2; //通过拷贝构造函数来初始化对象s3
	string s4(10, 'a');
	cout << "s1:" << s1 << endl;
	cout << "s2:" << s2 << endl;
	cout << "s3:" << s3 << endl;
	cout << "s4:" << s4 << endl;
}
//字符串的遍历
void string_test2() {
	string s1 = "hello world";
	//数组方式
	for (int i = 0; i < s1.length(); i++) {
		cout << s1[i] << " "; //[]出现错误时，不抛异常，引起程序的中断
	}
	cout << endl;
	//迭代器
	for (string::iterator it = s1.begin(); it != s1.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
	// at: at访问数据越界时可以抛出异常
	try {
		s1.at(20);
	}
	catch (...) {
		cout << "at error" << endl;
	}
	for (int i = 0; i < s1.length(); i++) {
		cout << s1.at(i) << " ";
	}
	cout << endl;
}
//字符指针和string的转换
void string_test3() {
	// const char* ===> string
	string s1 = "aaaaaa";
	// s1 ===> const char*
	const char* p = s1.c_str();
	cout << p << endl;
	// string copy 到 char buf[]中
	char buf[256] = { 0 };
	s1.copy(buf, s1.length(), 0);
	cout << "buf: " << buf << endl;
}
//字符串连接
void string_test4() {
	string s1 = "hello";
	string s2 = "world";
	s1 += s2;
	cout << "s1: " << s1 << endl;
	string s3 = "aaa";
	string s4 = "bbb";
	s3.append(s4);
	cout << "s3: " << s3 << endl;
}
//字符串查找和替换
void string_test5() {
	string s1 = "neo hello neo oneo hneollo eno www";
	int index = s1.find("neo", 0);
	cout << "one index:" << index << endl;
	// 求neo出现的次数
	// 把neo替换成NEO
	int num = 0;
	int off_index = s1.find("neo", 0);
	while (off_index != string::npos) {
		cout << "off_index:" << off_index << endl;
		s1.replace(off_index, 3, "NEO");
		off_index += 3;
		off_index = s1.find("neo", off_index);
		num++;
	}
	cout << num << endl;
	cout << s1 << endl;
	
}
//字符串的区间删除和插入
void string_test6() {
	string s1 = "hello1 hello2 hello3";
	string::iterator it = find(s1.begin(), s1.end(), 'l');
	if (it != s1.end()) {
		s1.erase(it);
	}
	cout << "s1: " << s1 << endl;
	//s1.erase(s1.begin(), s1.end());
	//cout << "s1: " << s1 << endl;
	s1.insert(0, "hello");
	cout << "s1: " << s1 << endl;
}
//字符串相关算法
void string_test7() {
	string s1 = "neo one neo one hello noe neo";
	transform(s1.begin(), s1.end(), s1.begin(), toupper);
	cout << "transform s1: " << s1 << endl;
}

int main() {
	string_test1();
	string_test2();
	string_test3();
	string_test4();
	string_test5();
	string_test6();
	string_test7();
	cin.get();
	return 0;
}
```
## vector: 动态数组
```c++
#include <iostream>
#include <vector>
using namespace std;

void vector_test1() {
	vector<int> v1;
	cout << "v1.size: " << v1.size() << endl;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(5);
	cout << "v1.size: " << v1.size() << endl;
	cout << "v1.front: " << v1.front() << endl;
	//修改头部元素,函数返回值当左值应该返回一个引用
	v1.front() = 11;
	v1.back() = 55;
	while (v1.size() > 0) {
		cout << "v1.tail:" << v1.back() << endl;; //获取尾部元素
		v1.pop_back(); //删除尾部元素
	}
}
//vector初始化
void vector_test2() {
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(5);
	v1.push_back(7);
	vector<int> v2 = v1; //拷贝构造函数
	vector<int> v3(v1.begin(), v1.begin() + 2);
	vector<int> v4(3, 9); //3个元素，每个元素都是9
}
void print_vector(vector<int>& v) {
	for (int i = 0; i < v.size(); i++) {
		cout << v[i] << " ";
	}
	cout << endl;
}
//vector的遍历
void vector_test3() {
	vector<int> v1(10); //用v[i]的形式赋值，需要提前把内存准备好
	for (int i = 0; i < 10; i++) {
		v1[i] = i + 1;
	}
	print_vector(v1);
}
//vector push_back的强化记忆
void vector_test4() {
	vector<int> v1(10);
	v1.push_back(100);
	v1.push_back(200);
	print_vector(v1);
}
//迭代器
//1    3    5
//▲           
//            ▲
//end()的位置时5的后面
//迭代器的种类
/*
using iterator               = _Vector_iterator<_Scary_val>;
using const_iterator         = _Vector_const_iterator<_Scary_val>;
using reverse_iterator       = _STD reverse_iterator<iterator>;
using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
*/
void vector_test5() {
	vector<int> v1(10);
	for (int i = 0; i < v1.size(); i++) {
		v1[i] = i + 1;
	}
	//正向遍历
	for (vector<int>::iterator it = v1.begin(); it != v1.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
	//逆向遍历
	for (vector<int>::reverse_iterator rit = v1.rbegin(); rit != v1.rend(); rit++) {
		cout << *rit << " ";
	}
	cout << endl;
}
//vector的删除元素
void vector_test6() {
	vector<int> v1(10);
	for (int i = 0; i < v1.size(); i++) {
		v1[i] = i + 1;
	}
	//区间删除
	v1.erase(v1.begin(), v1.begin() + 3); //删除前三个元素
	print_vector(v1);
	//根据元素的位置：指定位置删除
	v1.erase(v1.begin()); //在头部删除一个元素
	print_vector(v1);
	//根据元素的值 删除元素
	v1[1] = 2;
	v1[3] = 2;
	v1[5] = 2;
	print_vector(v1);
	for (vector<int>::iterator it = v1.begin(); it != v1.end(); ) {
		if (*it == 2) {
			it = v1.erase(it); //当删除迭代器所指向的元素的时候，erase会让it自动下移
		}
		else {
			it++;
		}
	}
	print_vector(v1);
	v1.insert(v1.begin(), 100); //头部插入100
	v1.insert(v1.end(), 200); //尾部插入200
	print_vector(v1);
}
int main() {
	vector_test1();
	vector_test2();
	vector_test3();
	vector_test4();
	vector_test5();
	vector_test6();
	cin.get();
	return 0;
}
```
## deque: 双端数组
```c++
#include <iostream>
#include <deque>
using namespace std;

void print_deque(deque<int>& d) {
	for (deque<int>::iterator it = d.begin(); it != d.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void deque_test1() {
	deque<int> d1;
	d1.push_back(1);
	d1.push_back(3);
	d1.push_back(5);
	d1.push_front(-1);
	d1.push_front(-3);
	d1.push_front(-5);
	print_deque(d1);
	cout << "d1.head: " << d1.front() << endl;
	cout << "d1.tail: " << d1.back() << endl;
	d1.pop_front();
	d1.pop_back();
	print_deque(d1);
	//查找-1在d1中的位置
	deque<int>::iterator it = find(d1.begin(), d1.end(), -1);
	if (it != d1.end()) {
		cout << "-1数组下标: " << distance(d1.begin(), it) << endl;
	}
}

int main() {
	deque_test1();
	cin.get();
	return 0;
}
```
## stack
```c++
#include <iostream>
#include <stack>
using namespace std;

void stack_test1() {
	stack<int> s;
	for (int i = 0; i < 10; i++) {
		s.push(i + 1); //入栈
	}
	cout << "s.size: " << s.size() << endl;
	//出栈
	while (!s.empty()) {
		int tmp = s.top(); //获取栈顶元素
		cout << tmp << " ";
		s.pop(); //弹出栈顶元素
	}
	cout << endl;
}

class Student {
public:
	int age;
	char name[32];
public:
	void print() {
		cout << "age: " << age << endl;
	}
};

void stack_test2() {
	Student s1, s2, s3;
	s1.age = 31;
	s2.age = 32;
	s3.age = 33;
	stack<Student> s;
	s.push(s1);
	s.push(s2);
	s.push(s3);
	while (!s.empty()) {
		Student tmp = s.top();
		tmp.print();
		s.pop();
	}
}

void stack_test3() {
	Student s1, s2, s3;
	s1.age = 31;
	s2.age = 32;
	s3.age = 33;
	stack<Student*> s;
	s.push(&s1);
	s.push(&s2);
	s.push(&s3);
	while (!s.empty()) {
		Student* tmp = s.top();
		tmp->print();
		s.pop();
	}
}

int main() {
	stack_test1();
	stack_test2();
	stack_test3();
	cin.get();
	return 0;
}
```
## queue
```c++
#include <iostream>
#include <queue>
using namespace std;

void queue_test1() {
	queue<int> q;
	q.push(1);
	q.push(2);
	q.push(3);
	cout << "q.head: " << q.front() << endl;
	cout << "q.size: " << q.size() << endl;
	while (!q.empty()) {
		cout << q.front() << " ";
		q.pop();
	}
	cout << endl;
}

class People {
public:
	int age;
	char name[32];
public:
	void print() {
		cout << "age: " << age << endl;
	}
};

void queue_test2() {
	People p1, p2, p3;
	p1.age = 31;
	p2.age = 32;
	p3.age = 33;
	queue<People> q;
	q.push(p1);
	q.push(p2);
	q.push(p3);
	while (!q.empty()) {
		People tmp = q.front();
		tmp.print();
		q.pop();
	}
}

void queue_test3() {
	People p1, p2, p3;
	p1.age = 31;
	p2.age = 32;
	p3.age = 33;
	queue<People*> q;
	q.push(&p1);
	q.push(&p2);
	q.push(&p3);
	while (!q.empty()) {
		People* tmp = q.front();
		tmp->print();
		q.pop();
	}
}

int main() {
	queue_test1();
	queue_test2();
	queue_test3();
	cin.get();
	return 0;
}
```
## list: 双向链表
```c++
#include <iostream>
#include <list>
using namespace std;

void print_list(list<int>& l) {
	for (list<int>::iterator it = l.begin(); it != l.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

void list_test1() {
	list<int> l;
	for (int i = 0; i < 10; i++) {
		l.push_back(i + 1);
	}
	cout << "l.size: " << l.size() << endl;
	print_list(l);
	//list不能随机访问，链表
	list<int>::iterator it = l.begin();
	it++;
	it++;
	it++;
	// it += 5; 不支持随机访问容器
	l.insert(it, 100);
	print_list(l);
}
//list的删除
void list_test2() {
	list<int> l;
	for (int i = 0; i < 10; i++) {
		l.push_back(i + 1);
	}
	list<int>::iterator it1 = l.begin();
	list<int>::iterator it2 = l.begin();
	it2++;
	it2++;
	it2++;
	l.erase(it1, it2);
	print_list(l);
	l.insert(l.begin(), 100);
	l.insert(l.begin(), 100);
	l.insert(l.begin(), 100);
	print_list(l);
	l.erase(l.begin());
	print_list(l);
	l.remove(100);
	print_list(l);
}

int main() {
	list_test1();
	list_test2();
	cin.get();
	return 0;
}
```
## priority_queue
```c++
#include <iostream>
#include <queue>
using namespace std;

void priority_queue_test1() {
	priority_queue<int> pq1; //默认情况下时最大值优先级队列
	priority_queue<int, vector<int>, less<int>> pq2; //less是提前定义好的预定义函数：谓词
	priority_queue<int, vector<int>, greater<int>> pq3; //最小值优先队列
	pq1.push(3);
	pq1.push(1);
	pq1.push(2);
	pq1.push(5);
	cout << "pq1.head: " << pq1.top() << endl;
	while (!pq1.empty()) {
		int tmp = pq1.top();
		cout << tmp << " ";
		pq1.pop();
	}
	cout << endl;

	pq3.push(3);
	pq3.push(1);
	pq3.push(2);
	pq3.push(5);
	cout << "pq3.head: " << pq3.top() << endl;
	while (!pq3.empty()) {
		int tmp = pq3.top();
		cout << tmp << " ";
		pq3.pop();
	}
	cout << endl;
}

int main() {
	priority_queue_test1();
	cin.get();
	return 0;
}
```
## set
```c++
#include <iostream>
#include <set>
using namespace std;

void print_set(set<int>& s) {
	for (set<int>::iterator it = s.begin(); it != s.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

//set采用红黑树实现，有顺序java中为TreeSet
void set_test1() {
	set<int> s;
	for (int i = 0; i < 5; i++) {
		int tmp = rand();
		s.insert(tmp);
	}
	s.insert(100);
	s.insert(100);
	s.insert(100);
	print_set(s);
	while (!s.empty()) {
		set<int>::iterator it = s.begin();
		cout << *it << " ";
		s.erase(s.begin());
	}
	cout << endl;
}
void set_test2() {
	// 从大到小
	set<int, greater<int>> s;
	for (int i = 0; i < 5; i++) {
		int tmp = rand();
		s.insert(tmp);
	}
	s.insert(100);
	for (set<int, greater<int>>::iterator it = s.begin(); it != s.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

class Man {
public:
	int age;
public:
	Man(int age) {
		this->age = age;
	}
	void print() {
		cout << "age: " << age << endl;
	}
};

//仿函数
struct FuncMan {
	bool operator()(const Man& m1, const Man& m2) const {
		return m1.age < m2.age;
	}
};

void set_test3() {
	set<Man, FuncMan> s;
	Man m1(31);
	Man m2(22);
	Man m3(32);
	Man m4(11);
	Man m5(31);
	s.insert(m1);
	s.insert(m2);
	s.insert(m3);
	s.insert(m4);
	s.insert(m5);
	for (set<Man, FuncMan>::iterator it = s.begin(); it != s.end(); it++) {
		cout << "age: " << it->age << endl;
	}
}
//如何判断set.insert的返回值
void set_test4() {
	set<Man, FuncMan> s;
	Man m1(31);
	Man m2(31);
	s.insert(m1);
	pair<set<Man, FuncMan>::iterator, bool> pair = s.insert(m2);
	if (pair.second) {
		cout << "m2 insert success" << endl;
	}
	else {
		cout << "m2 insert fail" << endl;
	}
	for (set<Man, FuncMan>::iterator it = s.begin(); it != s.end(); it++) {
		cout << "age: " << it->age << endl;
	}
}

void set_test5() {
	set<int> s;
	for (int i = 0; i < 10; i++) {
		s.insert(i+1);
	}
	set<int>::iterator it0 = s.find(5);
	cout << "it1: " << *it0 << endl;
	int num1 = s.count(5);
	cout << "num1: " << num1 << endl;
	set<int>::iterator it1 = s.lower_bound(5); //大于等于5的元素的迭代器的位置
	cout << "*it1: " << *it1 << endl;
	set<int>::iterator it2 = s.upper_bound(5); //大于5的元素的迭代器的位置
	cout << "*it2: " << *it2 << endl;
	// s.erase(5); 5删除前 *it3=5 *it4=6,5删除后*it3=6 *it4=6 
	pair<set<int>::iterator, set<int>::iterator> p0 = s.equal_range(5);
	set<int>::iterator it3 = p0.first;
	set<int>::iterator it4 = p0.second;
	cout << "*it3: " << *it3 << endl;
	cout << "*it4: " << *it4 << endl;
}

int main() {
	set_test1();
	set_test2();
	set_test3();
	set_test4();
	set_test5();
	cin.get();
	return 0;
}
```
## multiset
```c++
#include <iostream>
#include <set>
using namespace std;

void multiset_test1() {
	multiset<int> s;
	s.insert(1);
	s.insert(7);
	s.insert(7);
	s.insert(5);
	s.insert(5);
	s.insert(5);
	for (multiset<int>::iterator it = s.begin(); it != s.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
	while (!s.empty()) {
		multiset<int>::iterator it = s.begin();
		cout << *it << " ";
		s.erase(s.begin());
	}
	cout << endl;
}

int main() {
	multiset_test1();
	cin.get();
	return 0;
}
```
- c++中hashset使用unordered_set, #include<unordered_set>
## map
```c++
#include <iostream>
#include <map>
#include <string>
using namespace std;

void map_test1() {
	map<string, string> m;
	m.insert(pair<string, string>("England", "London"));
	m.insert(make_pair("Japan", "Tokyo"));
	m.insert(map<string, string>::value_type("France", "Paris"));
	m["China"] = "BeiJing";
	m["USA"] = "Washton";
	for (map<string, string>::iterator it = m.begin(); it != m.end(); it++) {
		cout << it->first << "\t" << it->second << endl;
	}
	cout << endl;
	while (!m.empty()) {
		map<string, string>::iterator it = m.begin();
		cout << it->first << "\t" << it->second << endl;
		m.erase(it);
	}
}
//插入的四种方法比较
//前三种返回的都是pair<iterator,bool> 若key已经存在，则插入失败
//方法四m[key]=value：若key已经存在，则覆盖
void map_test2() {
	map<string, string> m;
	pair<map<string, string>::iterator, bool> pair1 = m.insert(pair<string, string>("England", "London"));
	pair<map<string, string>::iterator, bool> pair2 = m.insert(make_pair("Japan", "Tokyo"));
	pair<map<string, string>::iterator, bool> pair3 = m.insert(map<string, string>::value_type("France", "Paris"));
	pair<map<string, string>::iterator, bool> pair4 = m.insert(map<string, string>::value_type("France", "Paris"));
	cout << "pair3 insert result: " << pair3.second << endl;
	cout << "pair4 insert result: " << pair4.second << endl;
	m["China"] = "BeiJing";
	m["USA"] = "Washton";
	m["USA"] = "Washton111"; //覆盖
	for (map<string, string>::iterator it = m.begin(); it != m.end(); it++) {
		cout << it->first << "\t" << it->second << endl;
	}
}
//查找
void map_test3() {
	map<string, string> m;
	m.insert(pair<string, string>("England", "London"));
	m.insert(make_pair("Japan", "Tokyo"));
	m.insert(map<string, string>::value_type("France", "Paris"));
	m["China"] = "BeiJing";
	m["USA"] = "Washton";
	//find
	cout << "find...." << endl;
	map<string, string>::iterator it = m.find("China");
	if (it == m.end()) {
		cout << "key China not exist" << endl;
	}
	else {
		cout << it->first << "\t" << it->second << endl;
	}
	//equal_range
	cout << "equal_range..." << endl;
	pair<map<string, string>::iterator, map<string, string>::iterator> pair = m.equal_range("England");
	//第一个迭代器 >= E的位置, 第二个迭代器 > E的位置
	if (pair.first == m.end()) {
		cout << "第一个迭代器>=England的位置不存在" << endl;
	}
	else {
		cout << pair.first->first << "\t" << pair.first->second << endl;
	}
	if (pair.first == m.end()) {
		cout << "第二个迭代器>England的位置不存在" << endl;
	}
	else {
		cout << pair.second->first << "\t" << pair.second->second << endl;
	}
}

int main() {
	map_test1();
	map_test2();
	map_test3();
	cin.get();
	return 0;
}
```
- c++中的map是有序的，对应Java中的TreeMap
- c++中hashmap使用unordered_map, #include<unordered_map>
## multimap
```c++
#include <iostream>
#include <map>
#include <string>
using namespace std;

class Person {
public:
	string name;
	int age;
	string phone;
	double salary;
};

void multimap_test1() {
	Person p1, p2, p3, p4, p5;
	p1.name = "Mr1";
	p1.age = 31;
	p2.name = "Mr2";
	p2.age = 32;
	p3.name = "Mr3";
	p3.age = 33;
	p4.name = "Mr4";
	p4.age = 34;
	p5.name = "Mr5";
	p5.age = 35;
	multimap<string, Person> m;
	m.insert(make_pair("sale", p1));
	m.insert(make_pair("sale", p2));
	m.insert(make_pair("development", p3));
	m.insert(make_pair("development", p4));
	m.insert(make_pair("financial", p5));
	for (multimap<string, Person>::iterator it = m.begin(); it != m.end(); it++) {
		cout << it->first << "\t" << it->second.name << endl;
	}
	cout << "development size: " << m.count("development") << endl;
	multimap<string, Person>::iterator it = m.find("development");
	while (it != m.end() && it->first == "development") {
		cout << it->first << "\t" << it->second.name << endl;
		it++;
	}
	cout << "age=32 modify" << endl;
	for (multimap<string, Person>::iterator it = m.begin(); it != m.end(); it++) {
		if (it->second.age == 32) {
			it->second.name = "Mr32";
		}
	}
	for (multimap<string, Person>::iterator it = m.begin(); it != m.end(); it++) {
		cout << it->first << "\t" << it->second.name << endl;
	}
}

int main() {
	multimap_test1();
	cin.get();
	return 1;
}
```
## 容器的值语义
```c++
#include <iostream>
#include <vector>
using namespace std;

class Dog {
private:
	int age;
	char* name;
public:
	Dog(int age, const char* name) {
		this->name = new char[strlen(name) + 1];
		strcpy(this->name, name);
		this->age = age;
	}
	Dog(const Dog& other) {
		this->name = new char[strlen(other.name) + 1];
		strcpy(this->name, other.name);
		this->age = other.age;
	}
	~Dog() {
		if (name != NULL) {
			delete[] name;
			name = NULL;
			age = 0;
		}
	}
	//重载=操作符
	Dog& operator=(const Dog& other) {
		if (name != NULL) {
			delete[] name;
			name = NULL;
			age = 0;
		}
		this->name = new char[strlen(other.name) + 1];
		strcpy(this->name, other.name);
		this->age = other.age;
		return *this;
	}
};

int main() {
	Dog d1(11, "Dog1");
	vector<Dog> v;
	v.push_back(d1); //把d1拷贝了一份存入到了容器中,执行了Dog的拷贝构造函数
	cin.get();
	return 0;
}
```
## 函数对象和谓词
```c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

//函数对象，类重载了()
template <typename T>
class ShowElement {
private:
	int n;
public:
	ShowElement() {
		n = 0;
	}
	void operator()(T& t) {
		n++;
		cout << t << " ";
	}
	void printN() {
		cout << "n: " << n << endl;
	}
};

template <typename T>
void FuncShowElement(T& t) {
	cout << t << " ";
}

//普通函数
void FuncShowElement2(int& t) {
	cout << t << " ";
}

//函数对象 定义
//函数对象和普通函数的异同
void show_test1() {
	int a = 10;
	ShowElement<int> showElement;
	showElement(a); //函数对象的()执行很像一个函数 //仿函数

	FuncShowElement<int>(a);
	FuncShowElement2(a);
	cout << endl;
}
//函数对象是属于类对象，
//能突破函数的概念，能保持调用状态信息
//函数对象的好处
//for_each算法中，函数对象做函数参数
//for_each算法中，函数对象当返回值
void show_test2() {
	vector<int> v1;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(5);
	for_each(v1.begin(), v1.end(), ShowElement<int>()); //匿名函数对象 匿名仿函数
	cout << endl;
	for_each(v1.begin(), v1.end(), FuncShowElement2); //通过回调函数，谁使用for_each谁去填写回调函数的入口地址
	cout << endl;

	ShowElement<int> show1;
	//for_each算法的函数对象的传递是元素值传递，不是引用
	show1 = for_each(v1.begin(), v1.end(), show1);
	show1.printN();
	//结论：分清楚stl算法返回的值是迭代器还是谓词（函数对象）是stl算法入门的重要要点
}

template <typename T>
class IsDiv {
private:
	T divisor;
public:
	IsDiv(const T& divisor) {
		this->divisor = divisor;
	}
	//一元谓词,返回值bool 函数参数有一个
	bool operator()(T& t) const {
		return t % divisor == 0;
	}
};
//一元函数对象和一元谓词
void show_test3() {
	vector<int> v1;
	for (int i = 10; i < 33; i++) {
		v1.push_back(i);
	}
	int a = 4;
	IsDiv<int> div(a);
	find_if(v1.begin(), v1.end(), div);

	//find_if返回的是一个迭代器
	vector<int>::iterator it;
	it = find_if(v1.begin(), v1.end(), IsDiv<int>(4));
	if (it == v1.end()) {
		cout << "容器中没有是4的倍数" << endl;
	}
	else {
		cout << "第一个被4整除的元素为: " << *it << endl;
	}
}

template <typename T>
class SumAdd {
private:
	T a;
	T b;
public:
	//二元函数对象
	T operator()(T a, T b) const {
		return a + b;
	}
};
//二元函数对象
void show_test4() {
	vector<int> v1, v2, v3;
	v1.push_back(1);
	v1.push_back(3);
	v1.push_back(5);

	v2.push_back(2);
	v2.push_back(4);
	v2.push_back(6);

	v3.resize(10);
	//transform把运算结果的迭代器的开始位置返回回来
	transform(v1.begin(), v1.end(), v2.begin(), v3.begin(), SumAdd<int>());
	for (vector<int>::iterator it = v3.begin(); it != v3.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
}

template <typename T>
class Comparator {
private:
	T a;
	T b;
public:
	//二元谓词
	bool operator()(T a, T b) const {
		return a < b;
	}
};
//二元谓词
void show_test5() {
	vector<int> v(10);
	for (int i = 0; i < 10; i++) {
		int tmp = rand() % 100;
		v[i] = tmp;
	}
	for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
		cout << *it << " ";
	}
	cout << endl;
	for_each(v.begin(), v.end(), FuncShowElement2);
	cout << endl;
	for_each(v.begin(), v.end(), FuncShowElement<int>);
	cout << endl;
	for_each(v.begin(), v.end(), ShowElement<int>());
	cout << endl;
	sort(v.begin(), v.end(), Comparator<int>());
	for_each(v.begin(), v.end(), ShowElement<int>());
	cout << endl;
}
int main() {
	show_test1();
	show_test2();
	show_test3();
	show_test4();
	show_test5();
	cin.get();
	return 0;
}
```