# 函数模板
## 函数模板基本语法
```c++
#include <iostream>
using namespace std;

//让类型参数化，方便程序员进行编码
//泛型编程
template <typename T>
void swap0(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

void main() {
	int x = 10;
	int y = 20;
	//函数模板的调用
	//显示类型调用
	swap0<int>(x, y);
	cout << "x: " << x << ", y: " << y << endl;

	//自动类型推导
	char a = 'a';
	char b = 'b';
	swap0(a, b);
	cout << "a: " << a << ", b: " << b << endl;
	system("pause");
}
```
## 函数模板当函数参数
```c++
#include <iostream>
using namespace std;

template <typename T>
int sort(T* array, int size) {
	if (array == NULL) {
		return -1;
	}
	for (int i = 0; i < size; i++) {
		for (int j = i + 1; j < size; j++) {
			if (array[i] >= array[j]) {
				continue;
			}
			T tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
	}
	return 0;
}

template <typename T>
void print(T* array, int size) {
	for (int i = 0; i < size; i++) {
		cout << array[i] << " ";
	}
	cout << endl;
}

void main() {
	int array[] = { 11, 2, 23, 33, 12, 2, 6, 9 };
	int size = sizeof(array) / sizeof(int);
	sort(array, size);
	print(array, size);

	char c_arr[] = { 'a', 'd', 'b', 'c' };
	int c_size = sizeof(c_arr) / sizeof(char);
	sort(c_arr, c_size);
	print(c_arr, c_size);
	system("pause");
}
```
## 函数模板遇上函数重载
- 普通函数的调用：可以进行隐式的类型转换
- 模板函数的调用（本质：类型参数化）：将严格按照类型进行匹配，不会进行自动类型转换
- 当函数模板和普通函数都符合调用时，优先选择普通函数
```c++
#include <iostream>
using namespace std;

template <typename T>
void swap1(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "模板函数" << endl;
}

void swap1(int& a, int& b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "普通函数" << endl;
}

void main() {
	int x = 10;
	int y = 20;
	swap1(x, y); //普通函数
	cout << "x: " << x << ", y: " << y << endl;
	system("pause");
}
```
- 函数模板可以向普通函数一样被重载
- C++编译器优先考虑普通函数
- 如果函数模板可以产生一个更好的匹配，那么选择模板
- 可以通过空模板实参列表的语法限定编译器只通过模板匹配
```c++
#include <iostream>
using namespace std;

void max0(int a, int b) {
	cout << "普通函数" << endl;
}

template <typename T>
void max0(T a, T b) {
	cout << "模板函数" << endl;
}

void main() {
	int a = 1;
	int b = 2;
	max0(a, b);   // 当函数模板和普通函数都符合调用时，优先选择普通函数
	max0<>(a, b); //若显示使用函数模板，则使用<>类型列表
	max0(3.0, 4.0); //如果函数模板产生更好的匹配，使用函数模板
	max0('a', 100); //调用普通函数，可以隐式类型转换
	system("pause");
}
```
## 函数模板原理
- 编译器并不是把函数模板处理成能够处理任意类的函数
- 编译器从函数模板通过具体类型产生不同的函数
- 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译
# 类模板
## 类模板基本语法
```c++
#include <iostream>
using namespace std;

template <typename T>
class A {
private:
	T t;
public:
	A(T t) {
		this->t = t;
	}
	void print() {
		cout << "t:" << t << endl;
	}
};

//类模板做函数参数
//参数C++编译器要求具体的类，所以要A<int>& a
void useA(A<int>& a) {
	a.print();
}

void main() {
	A<int> a1(100);
	a1.print();
	useA(a1);

	A<char> a2('b');
	a2.print();

	A<string> a3("hello");
	a3.print();
	system("pause");
}
```
## 派生类类模板
- 子模版类派生时，需要具体化模板类，C++编译器需要知道父类的数据类型具体是什么样子的
- 要知道父类所占的内存大小是多少，只有数据类型固定下来，才知道如何分配内存
```c++
class B : public A<int> {
private:
	int b;
public:
	B(int a, int b) : A(a) {
		this->b = b;
	}
};
```
- 从模板类派生模板类
```c++
template <typename T>
class C : public A<T> {
private:
	T c;
public:
	C(T a, T c) : A<T>(a) {
		this->c = c;
	}
	void print() {
		cout << "c: " << c << endl;
	}
};
```
## 复数类
- Complex.h
```c++
#pragma once
#include <iostream>
using namespace std;

template <typename T>
class Complex {
private:
	T a;
	T b;
	friend ostream& operator<<<T>(ostream& out, Complex& c);
public:
	Complex(T a, T b);
	void print();
	Complex operator+(Complex& other);
	Complex operator-(Complex& other);
};
```
- Complex.hpp
```c++
#include <iostream>
#include "Complex.h"
using namespace std;

template <typename T>
Complex<T>::Complex(T a, T b) {
	this->a = a;
	this->b = b;
}

template <typename T>
void Complex<T>::print() {
	cout << "a: " << a << ", b: " << b << endl;
}

template <typename T>
Complex<T> Complex<T>::operator+(Complex<T>& other) {
	Complex tmp(a + other.a, b + other.b);
	return tmp;
}

template <typename T>
Complex<T> Complex<T>::operator-(Complex<T>& other) {
	Complex tmp(a - other.a, b - other.b);
	return tmp;
}

template <typename T>
ostream& operator<<(ostream& out, Complex<T>& c) {
	out << c.a << " + " << c.b << "i";
	return out;
}
```
- test.cpp
```c++
#include <iostream>
#include "Complex.hpp" //必须引进hpp文件 hpp可以理解为h头文件的增强
using namespace std;

void main() {
	Complex<int> c1(1, 2);
	Complex<int> c2(3, 4);
	Complex<int> c3 = c1 + c2;
	cout << c3 << endl;
	c3.print();

	Complex<int> c4 = c2 - c1;
	cout << c4 << endl;
	c4.print();
	system("pause");
}
```
## 类模板中的static关键字
```c++
#include <iostream>
using namespace std;

template <typename T>
class AA {
public:
	static T a;
};

template <typename T>
T AA<T>::a = 0;

void main() {
	AA<int> a1, a2, a3;
	a1.a = 10;
	a2.a++;
	a3.a++;
	cout << a1.a << endl; //12
	AA<double> a4, a5, a6;
	cout << a4.a << endl; //0 不同类型的类，不共用静态变量；相同类型的类共用同一个静态变量
	system("pause");
}
```