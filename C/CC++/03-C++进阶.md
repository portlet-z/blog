# 函数模板和类模板
## 函数模板基本语法
```c++
#include <iostream>
using namespace std;

//让类型参数化，方便程序员进行编码
//泛型编程
template <typename T>
void swap0(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

void main() {
	int x = 10;
	int y = 20;
	//函数模板的调用
	//显示类型调用
	swap0<int>(x, y);
	cout << "x: " << x << ", y: " << y << endl;

	//自动类型推导
	char a = 'a';
	char b = 'b';
	swap0(a, b);
	cout << "a: " << a << ", b: " << b << endl;
	system("pause");
}
```
## 函数模板当函数参数
```c++
#include <iostream>
using namespace std;

template <typename T>
int sort(T* array, int size) {
	if (array == NULL) {
		return -1;
	}
	for (int i = 0; i < size; i++) {
		for (int j = i + 1; j < size; j++) {
			if (array[i] >= array[j]) {
				continue;
			}
			T tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
	}
	return 0;
}

template <typename T>
void print(T* array, int size) {
	for (int i = 0; i < size; i++) {
		cout << array[i] << " ";
	}
	cout << endl;
}

void main() {
	int array[] = { 11, 2, 23, 33, 12, 2, 6, 9 };
	int size = sizeof(array) / sizeof(int);
	sort(array, size);
	print(array, size);

	char c_arr[] = { 'a', 'd', 'b', 'c' };
	int c_size = sizeof(c_arr) / sizeof(char);
	sort(c_arr, c_size);
	print(c_arr, c_size);
	system("pause");
}
```
## 函数模板遇上函数重载
- 普通函数的调用：可以进行隐式的类型转换
- 模板函数的调用（本质：类型参数化）：将严格按照类型进行匹配，不会进行自动类型转换
- 当函数模板和普通函数都符合调用时，优先选择普通函数
```c++
#include <iostream>
using namespace std;

template <typename T>
void swap1(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "模板函数" << endl;
}

void swap1(int& a, int& b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "普通函数" << endl;
}

void main() {
	int x = 10;
	int y = 20;
	swap1(x, y); //普通函数
	cout << "x: " << x << ", y: " << y << endl;
	system("pause");
}
```
- 函数模板可以向普通函数一样被重载
- C++编译器优先考虑普通函数
- 如果函数模板可以产生一个更好的匹配，那么选择模板
- 可以通过空模板实参列表的语法限定编译器只通过模板匹配
```c++
#include <iostream>
using namespace std;

void max0(int a, int b) {
	cout << "普通函数" << endl;
}

template <typename T>
void max0(T a, T b) {
	cout << "模板函数" << endl;
}

void main() {
	int a = 1;
	int b = 2;
	max0(a, b);   // 当函数模板和普通函数都符合调用时，优先选择普通函数
	max0<>(a, b); //若显示使用函数模板，则使用<>类型列表
	max0(3.0, 4.0); //如果函数模板产生更好的匹配，使用函数模板
	max0('a', 100); //调用普通函数，可以隐式类型转换
	system("pause");
}
```
## 函数模板原理
- 编译器并不是把函数模板处理成能够处理任意类的函数
- 编译器从函数模板通过具体类型产生不同的函数
- 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译
## 类模板