# 函数模板
## 函数模板基本语法
```c++
#include <iostream>
using namespace std;

//让类型参数化，方便程序员进行编码
//泛型编程
template <typename T>
void swap0(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
}

void main() {
	int x = 10;
	int y = 20;
	//函数模板的调用
	//显示类型调用
	swap0<int>(x, y);
	cout << "x: " << x << ", y: " << y << endl;

	//自动类型推导
	char a = 'a';
	char b = 'b';
	swap0(a, b);
	cout << "a: " << a << ", b: " << b << endl;
	system("pause");
}
```
## 函数模板当函数参数
```c++
#include <iostream>
using namespace std;

template <typename T>
int sort(T* array, int size) {
	if (array == NULL) {
		return -1;
	}
	for (int i = 0; i < size; i++) {
		for (int j = i + 1; j < size; j++) {
			if (array[i] >= array[j]) {
				continue;
			}
			T tmp = array[i];
			array[i] = array[j];
			array[j] = tmp;
		}
	}
	return 0;
}

template <typename T>
void print(T* array, int size) {
	for (int i = 0; i < size; i++) {
		cout << array[i] << " ";
	}
	cout << endl;
}

void main() {
	int array[] = { 11, 2, 23, 33, 12, 2, 6, 9 };
	int size = sizeof(array) / sizeof(int);
	sort(array, size);
	print(array, size);

	char c_arr[] = { 'a', 'd', 'b', 'c' };
	int c_size = sizeof(c_arr) / sizeof(char);
	sort(c_arr, c_size);
	print(c_arr, c_size);
	system("pause");
}
```
## 函数模板遇上函数重载
- 普通函数的调用：可以进行隐式的类型转换
- 模板函数的调用（本质：类型参数化）：将严格按照类型进行匹配，不会进行自动类型转换
- 当函数模板和普通函数都符合调用时，优先选择普通函数
```c++
#include <iostream>
using namespace std;

template <typename T>
void swap1(T& a, T& b) {
	T tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "模板函数" << endl;
}

void swap1(int& a, int& b) {
	int tmp;
	tmp = a;
	a = b;
	b = tmp;
	cout << "普通函数" << endl;
}

void main() {
	int x = 10;
	int y = 20;
	swap1(x, y); //普通函数
	cout << "x: " << x << ", y: " << y << endl;
	system("pause");
}
```
- 函数模板可以向普通函数一样被重载
- C++编译器优先考虑普通函数
- 如果函数模板可以产生一个更好的匹配，那么选择模板
- 可以通过空模板实参列表的语法限定编译器只通过模板匹配
```c++
#include <iostream>
using namespace std;

void max0(int a, int b) {
	cout << "普通函数" << endl;
}

template <typename T>
void max0(T a, T b) {
	cout << "模板函数" << endl;
}

void main() {
	int a = 1;
	int b = 2;
	max0(a, b);   // 当函数模板和普通函数都符合调用时，优先选择普通函数
	max0<>(a, b); //若显示使用函数模板，则使用<>类型列表
	max0(3.0, 4.0); //如果函数模板产生更好的匹配，使用函数模板
	max0('a', 100); //调用普通函数，可以隐式类型转换
	system("pause");
}
```
## 函数模板原理
- 编译器并不是把函数模板处理成能够处理任意类的函数
- 编译器从函数模板通过具体类型产生不同的函数
- 编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译；在调用的地方对参数替换后的代码进行编译
# 类模板
## 类模板基本语法
```c++
#include <iostream>
using namespace std;

template <typename T>
class A {
private:
	T t;
public:
	A(T t) {
		this->t = t;
	}
	void print() {
		cout << "t:" << t << endl;
	}
};

//类模板做函数参数
//参数C++编译器要求具体的类，所以要A<int>& a
void useA(A<int>& a) {
	a.print();
}

void main() {
	A<int> a1(100);
	a1.print();
	useA(a1);

	A<char> a2('b');
	a2.print();

	A<string> a3("hello");
	a3.print();
	system("pause");
}
```
## 派生类类模板
- 子模版类派生时，需要具体化模板类，C++编译器需要知道父类的数据类型具体是什么样子的
- 要知道父类所占的内存大小是多少，只有数据类型固定下来，才知道如何分配内存
```c++
class B : public A<int> {
private:
	int b;
public:
	B(int a, int b) : A(a) {
		this->b = b;
	}
};
```
- 从模板类派生模板类
```c++
template <typename T>
class C : public A<T> {
private:
	T c;
public:
	C(T a, T c) : A<T>(a) {
		this->c = c;
	}
	void print() {
		cout << "c: " << c << endl;
	}
};
```
## 复数类
- Complex.h
```c++
#pragma once
#include <iostream>
using namespace std;

template <typename T>
class Complex {
private:
	T a;
	T b;
	friend ostream& operator<<<T>(ostream& out, Complex& c);
public:
	Complex(T a, T b);
	void print();
	Complex operator+(Complex& other);
	Complex operator-(Complex& other);
};
```
- Complex.hpp
```c++
#include <iostream>
#include "Complex.h"
using namespace std;

template <typename T>
Complex<T>::Complex(T a, T b) {
	this->a = a;
	this->b = b;
}

template <typename T>
void Complex<T>::print() {
	cout << "a: " << a << ", b: " << b << endl;
}

template <typename T>
Complex<T> Complex<T>::operator+(Complex<T>& other) {
	Complex tmp(a + other.a, b + other.b);
	return tmp;
}

template <typename T>
Complex<T> Complex<T>::operator-(Complex<T>& other) {
	Complex tmp(a - other.a, b - other.b);
	return tmp;
}

template <typename T>
ostream& operator<<(ostream& out, Complex<T>& c) {
	out << c.a << " + " << c.b << "i";
	return out;
}
```
- test.cpp
```c++
#include <iostream>
#include "Complex.hpp" //必须引进hpp文件 hpp可以理解为h头文件的增强
using namespace std;

void main() {
	Complex<int> c1(1, 2);
	Complex<int> c2(3, 4);
	Complex<int> c3 = c1 + c2;
	cout << c3 << endl;
	c3.print();

	Complex<int> c4 = c2 - c1;
	cout << c4 << endl;
	c4.print();
	system("pause");
}
```
## 类模板中的static关键字
```c++
#include <iostream>
using namespace std;

template <typename T>
class AA {
public:
	static T a;
};

template <typename T>
T AA<T>::a = 0;

void main() {
	AA<int> a1, a2, a3;
	a1.a = 10;
	a2.a++;
	a3.a++;
	cout << a1.a << endl; //12
	AA<double> a4, a5, a6;
	cout << a4.a << endl; //0 不同类型的类，不共用静态变量；相同类型的类共用同一个静态变量
	system("pause");
}
```
## 数组容器
- Vector.h
```c++
#include <iostream>
using namespace std;

template <typename T>
class Vector {
private:
	int len;
	T* space;
	friend ostream& operator<<<T>(ostream& out, Vector& v);
public:
	Vector(int size = 0);//构造函数
	Vector(const Vector& other);//拷贝构造函数
	~Vector();//析构函数
	int getLen() {
		return this->len;
	}
public:
	T& operator[](int index); //重载[]运算符
	Vector& operator=(const Vector& other);
};
```
- Vector.hpp
```c++
#include "Vector.h"

template <typename T>
Vector<T>::Vector(int size) {
	len = size;
	space = new T[len];
}

template <typename T>
Vector<T>::Vector(const Vector& other) {
	len = other.len;
	space = new T[other.len];
	for (int i = 0; i < other.len; i++) {
		space[i] = other.space[i];
	}
}

template <typename T>
Vector<T>::~Vector() {
	if (space != NULL) {
		delete[] space;
		space = NULL;
	}
	len = 0;
}

template <typename T>
T& Vector<T>::operator[](int index) {
	return space[index];
}

template <typename T>
Vector<T>& Vector<T>::operator=(const Vector<T>& other) {
	if (space != NULL) {
		delete[] space;
		space = NULL;
		len = 0;
	}
	len = other.len;
	space = new T[other.len];
	for (int i = 0; i < other.len; i++) {
		space[i] = other.space[i];
	}
	return *this;
}

template <typename T>
ostream& operator<<(ostream& out, Vector<T>& v) {
	for (int i = 0; i < v.getLen(); i++) {
		out << v[i] << " ";
	}
	return out;
}
```
- VectorTest.cpp
```c++
#include "Vector.hpp"

class Teacher {
private:
	int age;
	char first_name[32];
	char* second_name;
	friend ostream& operator<<(ostream& out, const Teacher& t);
public:
	Teacher() {
		age = 0;
		strcpy(first_name, "");
		second_name = new char[1];
		strcpy(second_name, "");
	}
	Teacher(int age, const char* first_name, const char* second_name) {
		this->age = age;
		strcpy(this->first_name, first_name);
		this->second_name = new char[strlen(second_name) + 1];
		strcpy(this->second_name, second_name);
	}
	Teacher(const Teacher& other) {
		age = other.age;
		strcpy(first_name, other.first_name);
		if (second_name != NULL) {
			delete[] second_name;
			second_name = NULL;
		}
		second_name = new char[strlen(other.second_name) + 1];
		strcpy(second_name, other.second_name);
	}
	//vector有析构函数delete[]space的时候会将second_name释放
	//~Teacher() {
	//	if (second_name != NULL) {
	//		delete[] second_name;
	//		second_name = NULL;
	//	}
	//}
	void print() {
		cout << first_name << "," << age << endl;
	}
	Teacher& operator=(const Teacher& other) {
		if (second_name != NULL) {
			delete[] second_name;
			second_name = NULL;
		}
		age = other.age;
		strcpy(first_name, other.first_name);
		second_name = new char(strlen(other.second_name) + 1);
		strcpy(second_name, other.second_name);
		return *this;
	}
};

ostream& operator<<(ostream& out, const Teacher& t) {
	out << t.first_name << " " << t.second_name << " " << t.age;
	return out;
}

void main() {
	Vector<int> v1(10);
	for (int i = 0; i < v1.getLen(); i++) {
		v1[i] = i + 1;
	}
	Vector<int> v2 = v1;
	for (int i = 0; i < v2.getLen(); i++) {
		cout << v2[i] << " ";
	}
	cout << endl;
	cout << v2 << endl;

	Teacher t1(31, "a", "aa");
	Vector<Teacher> vt(1);
	vt[0] = t1;
	/*vt[1] = t2;
	vt[2] = t3;*/
	cout << vt << endl;
	system("pause");
}
```
# C++的类型转换
## 类型转换基本语法
- C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是Type b = (Type)a;
- C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用
	- static_cast:静态类型转换。如int转换成char
	- reinterpret_cast:重新解释类型
	- dynamic_cast: 命名上理解是动态类型转换。如子类和父类之间的多态类型转换
	- const_cast: 字面上理解就是去const属性
```c++
#include <iostream>
using namespace std;

class Animal {
public:
	virtual void cry() = 0;
};

class Dog : public Animal {
public:
	void cry() {
		cout << "汪汪" << endl;
	}
	void doHome() {
		cout << "看家" << endl;
	}
};

class Cat : public Animal {
public:
	void cry() {
		cout << "喵喵" << endl;
	}
	void doCatch() {
		cout << "抓老鼠" << endl;
	}
};

class Tree {

};

void animal_play(Animal* base) {
	base->cry(); //1有继承 2虚函数重写 3父类指针指向子类对象 --> 多态
	//能识别子类对象
	// dynamic_cast 运行时类型识别
	Dog* dog = dynamic_cast<Dog*>(base);
	if (dog != NULL) {
		dog->doHome();
	}
	Cat* cat = dynamic_cast<Cat*>(base);
	if (cat != NULL) {
		cat->doCatch();
	}
}

void printBuf(const char* p) {
	//p[0] = 'z';//编译错误
	char* tmp = NULL;
	tmp = const_cast<char*>(p); //把只读属性去掉,得确定所指向的内存空间确实能够修改
	tmp[0] = 'z';
	cout << p << endl;
}

void main() {
	double pi = 3.1415926;
	int num1 = (int)pi; //C类型转换
	cout << num1 << endl;
	int num2 = pi; //隐式类型转换，隐式类型转换的地方均可使用static_cast<>()进行类型转换
	cout << num2 << endl;

	//静态类型转换：编译时编译器会做类型检查
	int num3 = static_cast<int>(pi); 
	cout << num3 << endl;

	//char* ===> int*
	const char* p1 = "hello";
	const int* p2 = NULL;
	// 使用static_cast编译时会做类型检查，下面编译时会报错
	//p2 = static_cast<const int*>(p1);
	//若不同类型之间，进行强制类型转换，用reinterpret_cast<>()进行重新解释
	p2 = reinterpret_cast<const int*>(p1);
	cout << p1 << endl;
	cout << p2 << endl;
	//总结：通过reinterpret_cast<>()和static_cast<>()把C语言的强制类型转换都覆盖了

	Dog d1;
	Cat c1;
	animal_play(&d1);
	animal_play(&c1);

	Animal* base = NULL;
	base = &d1;
	base = static_cast<Animal*>(&d1);
	base = reinterpret_cast<Animal*>(&d1);

	Tree* tree;
	//tree = static_cast<Tree*>(&d1); 编译时报错
	//base = static_cast<Animal*>(&tree); 编译时报错
	tree = reinterpret_cast<Tree*>(&d1);
	base = reinterpret_cast<Animal*>(&tree);

	char buf[] = "hello world";
	printBuf(buf);
	const char* p = "hello world";
	// printBuf(p); 运行出错，p所指向的内存空间不能修改
	system("pause");
}
```
# 异常处理
## 异常基本语法
```c++
#include <iostream>
using namespace std;

int divide(int x, int y) {
	if (y == 0) {
		throw x;
	}
	return x / y;
}

void main() {
	try {
		int i = divide(1, 0);
		cout << i << endl;
	}
	catch (int e) {
		cout << "被零除" << e << endl;
	} 
	catch (...) {
		cout << "未知异常" << endl;
	}
	system("pause");
}
```
## 栈解旋(unwinding)
- 异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋unwinding
```c++
#include <iostream>
using namespace std;

class Test {
private:
	int a;
public:
	Test(int a = 0) {
		this->a = a;
		cout << "Test Constructor:" << a << endl;
	}
	~Test() {
		cout << "Test Destrcutor:" << a << endl;
	}
};

void my_divide() {
	Test t1(1);
	Test t2(2);
	Test t3(3);
	cout << "发生异常" << endl;
	throw 1;
}

void main() {
	try {
		my_divide();
	}
	catch (int e) {
		cout << "异常" << e << endl;
	}
	system("pause");
}
```
## 异常接口声明
- void func() throw (A,B,C,D);//这个函数func能够且只能抛出A B C D及其子类型的异常
- void func(); //没有异常接口声明，可以抛出任意类型的异常
- 一个不抛任何类型异常的函数可以声明为: void func() throw();
## 异常变量的生命周期
```c++
#include <iostream>
using namespace std;

//传统错误处理
int my_strcpy(char* to, char* from) {
	if (from == NULL) {
		return 1;
	}
	if (to == NULL) {
		return 2;
	}
	if (*from == 'a') {
		return 3;
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
	return 0;
}

void main_() {
	int ret = 0;
	char buf1[] = "abcdefg";
	char buf2[1024] = { 0 };
	ret = my_strcpy(buf2, buf1);
	if (ret != 0) {
		switch (ret) {
		case 1:
			cout << "源buf出错" << endl;
			break;
		case 2:
			cout << "目的buf出错" << endl;
			break;
		case 3:
			cout << "copy过程出错" << endl;
			break; 
		default:
			cout << "未知错误" << endl;
			break;
		}
	}
	else {
		cout << buf2 << endl;
	}

	system("pause");
}

// throw int
void my_strcpy1(char* to, char* from) {
	if (from == NULL) {
		throw 1;
	}
	if (to == NULL) {
		throw 2;
	}
	if (*from == 'a') {
		throw 3;
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

// throw char*
void my_strcpy2(char* to, char* from) {
	if (from == NULL) {
		throw "源buf出错";
	}
	if (to == NULL) {
		throw "目的buf出错";
	}
	if (*from == 'a') {
		throw "copy过程出错";
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

class SourceError {

};

class DestinationError {

};

class ProcessError {
public:
	ProcessError() {
		cout << "ProcessError Constructor" << endl;
	}
	~ProcessError() {
		cout << "ProcessError Destructor" << endl;
	}
	ProcessError(ProcessError& other) {
		cout << "ProcessError Copy Constructor" << endl;
	}
};

// throw 类对象
void my_strcpy3(char* to, char* from) {
	if (from == NULL) {
		throw SourceError();
	}
	if (to == NULL) {
		throw DestinationError();
	}
	if (*from == 'a') {
		throw ProcessError(); //产生一个匿名对象
		//ProcessError e;
		//throw &e; //指针被抛出后，就会被析构，产生野指针
	}
	while (*from != '\0') {
		*to = *from;
		to++;
		from++;
	}
	*to = '\0';
}

void main() {
	char buf1[] = "abcdefg";
	char buf2[1024] = { 0 };
	try {
		my_strcpy1(buf2, buf1);
		cout << buf2 << endl;
	}
	catch (int e) {
		cout << "int类型异常:" << e << endl;
	}
	catch (...) {
		cout << "未知异常" << endl;
	}
	try {
		my_strcpy2(buf2, buf1);
		cout << buf2 << endl;
	}
	catch (const char* e) {
		cout << e << endl;
	}
	catch (...) {
		cout << "未知异常" << endl;
	}
	try {
		my_strcpy3(buf2, buf1);
		cout << buf2 << endl;
	}
	catch (SourceError e) {
		cout << "SourceError" << endl;
	}
	catch (DestinationError e) {
		cout << "DestinationError" << endl;
	}
	//结论：1如果接受异常的时候使用一个异常变量，则copy构造异常变量
	catch (ProcessError e) { //是把匿名对象copy给e
		cout << "ProcessError" << endl;
	}
	//结论2：使用引用的话会使用throw时的那个对象
	//catch (ProcessError& e) { //不会发生copy构造
	//	cout << "ProcessError" << endl;
	//}
	//结论3:指针可以和引用/元素写在一起，但是元素和引用不能写在一块
	catch (ProcessError* e) {
		cout << "ProcessError *" << endl;
	}
	catch (...) {
		cout << "未知异常" << endl;
	}
	system("pause");
}
```
## 异常的层次结构
