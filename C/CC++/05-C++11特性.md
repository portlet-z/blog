# 字符串原始字面量
```c++
#include <iostream>
using namespace std;
int main() {
	string str1 = "D:\hello\world\test.txt";
	cout << str1 << endl; //D:helloworld    est.txt
	string str2 = R"(D:\hello\world\test.txt)"; //D:\hello\world\test.txt 原始输出
	cout << str2 << endl;
	string str3 = R"xxxx(D:\hello\world\test.txt)xxxx";//D:\hello\world\test.txt
	cout << str3 << endl;
	cin.get();
	return 0;
}
```
# 指针空值类型nullptr
- nullptr无法隐式转换，但是可以隐式匹配指针类型。相比NULL和0，使用nullptr初始化空指针可以令我们编写的程序更加健壮
```c++
#include <iostream>
using namespace std;
void func(char* p) {
	cout << "void func(char* p)" << endl;
}
void func(int p) {
	cout << "void func(int p)" << endl;
}
int main() {
	int* ptr1 = NULL;
	char* ptr2 = NULL;
	double* ptr3 = NULL;
	void* ptr4 = NULL;
	//int* ptr5 = ptr4;
	int* ptr5 = (int*)ptr4;
	func(10);   // void func(int p)
	func(NULL); // void func(int p)
	func(nullptr); //void func(char* p)
	func(ptr2); //void func(char* p) 
	cin.get();
	return 0;
} 
```
# constexpr
- C++11之前只有const关键字，从功能上来说这个关键字有双重语义：变量只读，修饰常量
```c++
void func(const int num) { //num是变量，只不过是是只读的
	int a1 = 520;
	int a2 = 250;
	const int count = 24; //常量
	int array[count];
	//int array1[a1]; //编译出错 expression did not evaluate to a constant
	//int array2[num]; //编译出错，num是变量，只不过是是只读的
}
```
- constexpr用来修饰常量表达式的。所谓常量表达式，指的就是由多个(>=1)常量组成并且在编译过程中就得到计算结果的表达式
- 在使用中建议const和constexpr功能区分开来，即凡是表达“只读”语义的场景都使用const, 表达“常量”语义的场景都使用constexpr
```c++
struct T {
	int a;
};
int main() {
	constexpr T t{ 100 };
	cin.get();
	return 0;
}
```
# 常量表达式函数
- 为了提高C++程序的执行效率，可以将程序中值不需要发生的变量定义为常量，也可以使用constexpr修饰函数的返回值，这种函数称作常量表达式函数
- 函数必须要有返回值，并且return返回的表达式必须是常量表达式
```c++
//error, 不是常量表达式函数 没有返回值
constexpr void func1() {
    int a = 100;
    cout << a << endl;
}
//error, 不是常量表达式函数，返回值不是常量表达式
constexpr int func2() {
    int a = 100;
    return a;
}
```
- 函数在使用之前，必须由对应的定义语句
```c++
#include <iostream>
using namespace std;
constexpr int func1();
int main() {
    constexpr int num = func1(); //error
    return 0;
}
constexpr int func1() {
    constexpr int a = 100;
    return a;
}
```
- 在测试程序中constexpr int num = func1();中，还没有定义func1()就直接调用了，应该将func1()函数的定义放到main()函数上边
- 整个函数的函数体中，不能出现非常量表达式之外的语句(using指令，typedef语句以及static_assert断言，return语句除外)
```c++
// error
constexpr int func1() {
    constexpr int a = 100;
    constexpr int b = 10;
    for (int i=0; i<b; i++) { //for循环非法操作
        cout << i << endl;
    }
}
// ok
constexpr int func2() {
    using mytype = int;
    constexpr mytype a = 100;
    constexpr mytype b = 10;
    constexpr mytype c = a * b;
    return c - (a + b);
}
```
- 如果constexpr修饰的模板函数实例化结果不满足常量表达式函数的要求，则constexpr会被自动忽略，即该函数就等同于一个普通函数
# decltype
- 在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用decltype关键字，作用是在编译器编译的时候推导出一个表达式的类型 `decltype (表达式)`
```c++
int a = 10;
decltype(a) b = 99; // b->int
decltype(a+3.14) c = 12.34; // c->double
```
- 可以看到decltype推导的表达式可以简单可复杂，在这一点上auto是做不到的，auto只能推导已初始化的变量类型
```c++
// x: int
int x = 99;
// y: const int&
const int& y = x;
// b: const int&
decltype(y) b = y;
```
- 表达式是函数调用，使用decltype推导出的类型和函数返回值一致
```c++
class Test{};
int func_int();
int& func_int_r();
int&& func_int_rr();
const int func_cint();
const int& func_cint_r();
const int&& func_cint_rr();
const Test func_ctest();
int n = 100;
decltype(func_int()) a = 0; // a->int
decltype(func_int_r()) b = n; // b->int&
decltype(func_int_rr()) c = 0; //c->int&&
decltype(func_cint()) d = 0; //d->int
decltype(func_cint_r()) e = n; //e->const int&
decltype(func_cint_rr()) f = 0; //f->const int&&
decltype(func_ctest()) g = Test();//g->const Test
```
- 表达式是一个左值，或者被()括号包围，使用decltype推导出的是表达式类型的引用(如果有const,volatile限定符不能忽略)
```c++
class Test{
public:
	int num;
};
int main() {
	const Test obj;
	//a: int
	decltype(obj.num) a = 0;
	//b: const int&
	decltype((obj.num)) b = a;

	int n = 0, m = 0;
	//c: int
	decltype(n + m) c = 0;
	//d: int&
	decltype(n = n + m) d = n;
	return 0;
}
- decltype应用多出现在泛型编程中。
```c++
#include <iostream>
#include <list>
using namespace std;

template <typename T>
class Container {
public:
	void print(T& t) {
		for (it = t.begin(); it != t.end(); it++) {
			cout << "value: " << *it << endl;
		}
	}
private:
	//T::iterator it; //C++17版本下没问题，可以推导出为iterator类型
	decltype(T().begin()) it;
};
int main() {
	list<int> ls{ 1,2,3,4,5,6,7 };
	Container<list<int>> c;
	c.print(ls);
	cin.get();
	return 0;
}
```
# 返回值类型后置
```c++
#include <iostream>
using namespace std;

template<typename R, typename T, typename U>
R add(T t, U u) {
	return t + u;
}

template<typename T, typename U>
auto add2(T t, U u) -> decltype(t + u) {
	return t + u;
}
int main() {
	int x = 520;
	double y = 13.14;
	auto ret = add<decltype(x + y), int, double>(x, y);
	cout << "ret: " << ret << endl;
	auto ret2 = add2<int, double>(x, y);
	cout << "ret2: " << ret2 << endl;
	auto ret3 = add2(x, y);
	cout << "ret3: " << ret3 << endl;
	cin.get();
	return 0;
}
```
# final
- final关键字来限制某个类不能被继承，或者某个虚函数不能被重写，和Java的final关键字的功能类似。如果用final修饰函数，只能修饰虚函数，并且要把final关键字放到类或者函数的后面
```c++
#include <iostream>
using namespace std;
class Base {
public:
	virtual void test() {
		cout << "Base class..." << endl;
	}
};
class Child : public Base {
public:
	void test() final {
		cout << "Child class..." << endl;
	}
};
class GrandChild : public Child {
public:
	//void test() {
	// 编译失败
	//}
};
int main() {
	cin.get();
	return 0;
}
```
- final修饰类，表示类不允许被继承，也就是说这个类不能有派生类
```c++
class Base {
public:
	virtual void test() {
		cout << "Base class..." << endl;
	}
};
class Child final : public Base {
public:
	void test() {
		cout << "Child class..." << endl;
	}
};
//class GrandChild : public Child {} //error Child被final修饰，不能有派生类了
```
# override
- 和Java类型，确保在派生类中声明的重写函数与基类的虚函数有相同的签名
```c++
class Base {
public:
	virtual void test() {
		cout << "Base class..." << endl;
	}
};
class Child : public Base {
public:
	virtual void test() override {
		cout << "Child class..." << endl;
	}
};
```
# 模板的右尖括号
```c++
#include <iostream>
#include <map>
using namespace std;
template <typename T>
class Container {
public:
	void print(T& t) {
		for (auto it = t.begin(); it != t.end(); it++) {
			cout << it->first << ": " << it->second << endl;
		}
	}
};
int main() {
	map<int, string> m;
	m.insert(make_pair(1, "aaa"));
	m.insert(make_pair(2, "bbb"));
	m.insert(make_pair(3, "ccc"));
	Container<map<int, string>> c;
	c.print(m);
	cin.get();
	return 0;
}
```
# 默认模板参数
```c++
template <typename T = long, typename U = int>
void test(T t = 'A', U u = 'B') {
	cout << "t: " << t << ", u: " << u << endl;
}
```
# using
## 定义别名
```c++
typedef unsigned int uint_t;
using uint_t = int;
//使用typedef定义函数指针
typedef int(*func_ptr)(int, double);
//使用using定义函数指针
using func_ptr1 = int(*)(int, double);
```