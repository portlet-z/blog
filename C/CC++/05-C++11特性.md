# 字符串原始字面量
```c++
#include <iostream>
using namespace std;
int main() {
	string str1 = "D:\hello\world\test.txt";
	cout << str1 << endl; //D:helloworld    est.txt
	string str2 = R"(D:\hello\world\test.txt)"; //D:\hello\world\test.txt 原始输出
	cout << str2 << endl;
	string str3 = R"xxxx(D:\hello\world\test.txt)xxxx";//D:\hello\world\test.txt
	cout << str3 << endl;
	cin.get();
	return 0;
}
```
# 指针空值类型nullptr
- nullptr无法隐式转换，但是可以隐式匹配指针类型。相比NULL和0，使用nullptr初始化空指针可以令我们编写的程序更加健壮
```c++
#include <iostream>
using namespace std;
void func(char* p) {
	cout << "void func(char* p)" << endl;
}
void func(int p) {
	cout << "void func(int p)" << endl;
}
int main() {
	int* ptr1 = NULL;
	char* ptr2 = NULL;
	double* ptr3 = NULL;
	void* ptr4 = NULL;
	//int* ptr5 = ptr4;
	int* ptr5 = (int*)ptr4;
	func(10);   // void func(int p)
	func(NULL); // void func(int p)
	func(nullptr); //void func(char* p)
	func(ptr2); //void func(char* p) 
	cin.get();
	return 0;
} 
```
# constexpr
- C++11之前只有const关键字，从功能上来说这个关键字有双重语义：变量只读，修饰常量
```c++
void func(const int num) { //num是变量，只不过是是只读的
	int a1 = 520;
	int a2 = 250;
	const int count = 24; //常量
	int array[count];
	//int array1[a1]; //编译出错 expression did not evaluate to a constant
	//int array2[num]; //编译出错，num是变量，只不过是是只读的
}
```
- constexpr用来修饰常量表达式的。所谓常量表达式，指的就是由多个(>=1)常量组成并且在编译过程中就得到计算结果的表达式
- 在使用中建议const和constexpr功能区分开来，即凡是表达“只读”语义的场景都使用const, 表达“常量”语义的场景都使用constexpr
```c++
struct T {
	int a;
};
int main() {
	constexpr T t{ 100 };
	cin.get();
	return 0;
}
```
# 常量表达式函数
- 为了提高C++程序的执行效率，可以将程序中值不需要发生的变量定义为常量，也可以使用constexpr修饰函数的返回值，这种函数称作常量表达式函数
- 函数必须要有返回值，并且return返回的表达式必须是常量表达式
```c++
//error, 不是常量表达式函数 没有返回值
constexpr void func1() {
    int a = 100;
    cout << a << endl;
}
//error, 不是常量表达式函数，返回值不是常量表达式
constexpr int func2() {
    int a = 100;
    return a;
}
```
- 函数在使用之前，必须由对应的定义语句
```c++
#include <iostream>
using namespace std;
constexpr int func1();
int main() {
    constexpr int num = func1(); //error
    return 0;
}
constexpr int func1() {
    constexpr int a = 100;
    return a;
}
```
- 在测试程序中constexpr int num = func1();中，还没有定义func1()就直接调用了，应该将func1()函数的定义放到main()函数上边
- 整个函数的函数体中，不能出现非常量表达式之外的语句(using指令，typedef语句以及static_assert断言，return语句除外)
```c++
// error
constexpr int func1() {
    constexpr int a = 100;
    constexpr int b = 10;
    for (int i=0; i<b; i++) { //for循环非法操作
        cout << i << endl;
    }
}
// ok
constexpr int func2() {
    using mytype = int;
    constexpr mytype a = 100;
    constexpr mytype b = 10;
    constexpr mytype c = a * b;
    return c - (a + b);
}
```
- 如果constexpr修饰的模板函数实例化结果不满足常量表达式函数的要求，则constexpr会被自动忽略，即该函数就等同于一个普通函数