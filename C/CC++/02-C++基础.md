# hello
```c++
#include <iostream>

using namespace std; //使用命名空间std标准的命名空间

int main()
{
	// cout标准输出
	// << 左移操作符 在C++里面功能的改造（增强） ===> C++ 语言操作符重载
	// endl \n
	cout << "Hello World." << endl;
	system("pause");
	return 0;
}
```
# C++对C的加强
## namespace
- 所谓namespace,是指标识符的各种可见范围
- 当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespce std;这样才能正确使用cout
- 在C++中，名称(name)可以是符合常量、变量、宏、函数、结构体、枚举、类和对象等等。为了避免在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突。
- 标准C++引入了关键字namespace(命名空间/名字空间/名称空间/名域)，可以更好地控制标识符地作用域
- C中的命名空间
    - 在C语言中只有一个全局作用域
    - C语言中所有的全局标识符共享同一个作用域
    - 标识符之间可能发生冲突
- C++中提出了命名空间的概念
    - 命名空间将全局作用域分成不同的部分
    - 不同命名空间中的标识符可以同名而不会发生冲突
    - 命名空间可以相互嵌套
## 实用性增加
- C语言中的变量都必须在作用域开始的位置定义
- C++中更强调语言的实用性，所有的变量都可以在需要使用时再定义。
## register关键字增强
- register关键字请求编译器将局部变量存储于寄存器中；C语言中无法取得register变量地址；在C++中依然支持register关键字；C++编译器有自己的优化方式，不使用register也可能做优化；C++中可以取得register变量的地址
- C++编译器发现程序中需要取register变量的地址时，register对变量的声明变得无效
- 早期C语言编译器不会对代码进行优化，因此register变量时一个很好的补充.
## 变量类型检测增强
- 在C语言中，重复定义多个同名的全局变量是合法的，C语言中多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上
- 在C++中，不允许定义多个同名的全局变量
## struct类型增强
- C语言的struct定义了一组变量的集合，C编译器并不认为这是一种新的类型
- C++中的struct是一个新类型的定义声明
- struct关键字class关键字，完成的功能是一样的
```c
struct Teacher {
    char name[64];
    int age;
};
void main() {
    struct Teacher t1; //C中struct关键字不能省略
    Teacher t2; //C++中不用写struct关键字
}
```
## C++中所有的变量和函数都必须有类型
- 在C语言中
    - int f(): 表示返回值为int, 接受任意参数的函数
    - int f(void): 表示返回值为int的无参函数
- 在C++中
    - int f()和int f(void)具有相同的意义，都表示返回值为int的无参函数
- C++中更加强调类型，任意的程序元素都必须显示指明类型
```c
f(i) {
    printf("i = %d\n", i);
}
g() {
    return 5;
}
void main() {
    f(10);
    g(1,2,3,4,5);
}
```
## 新增bool类型关键字
- 理论上只占一个字节
- 如果多个bool变量定义在一起，可能会各占一个bit,这取决于编译器的实现
- true代表真值，编译器内部哦那个1来表示。false代表非真值，编译器内部用0来表示
## 三目运算符增强
- 在C语言中，表达式的结果放在什么地方：寄存器
- 在C语言中，表达式的返回值是变量的值
- 在C++中，表达式返回的是变量的本身
- 如何做到的：让表达式返回一个内存空间，内存首地址
- C++编译器帮我们程序员完成了取地址的工作
- 注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用 (a < b ? 1 : b)
```c++
#include <iostream>

using namespace std;

void main() {
	int a = 10;
	int b = 20;
	(a < b ? a : b) = 30; //在C中编译器会报错，C++中没问题
    // *(a < b ? &a : &b) = 30 类似于C中这种编写
	cout << "a = " << a << endl; // 30
	cout << "b = " << b << endl; // 20
	system("pause");
}
```
## C/C++中的const
```c++
struct Teacher {
    char name[64];
    int age;
};
//指针所指向的内存空间不能被修改
int operatorTeacher01(const Teacher* pt) {
    //pt->age = 10;
    return 0;
}
//指针变量本身不能被修改
int operatorTeacher02(Teacher* const pt) {
    //pt = NULL;
    pt->age = 10;
    return 0;
}
int operatorTeacher03(const Teacher* const pt) {
    printf("age:%d\n", pt->age);
    return 0;
}
void main() {
    const int a = 10;
    //a=11;
    int* p = NULL;
    p = (int*)&a;
    *p = 20;
    // C编译器中执行为20，C++中为10
    // C++中的实现方式，常量存在一个符合表(key->value)里 
    // C语言中的const是一个冒牌货，C++语言中const是一个真正的常量
    // const分配内存时机：编译器编译期间
    printf("a:%d\n", a);
}
```
- const和#define区别
    - C++中的const常量类似于宏定义：const int a = 5; #define c 5
- C++中的const常量在与宏定义的不同
    - const产量是由编译器处理的，提供类型检查和作用域检查
    - 宏定义由预处理器处理，单纯的文本替换
```c++
void fun1() {
    #define a 10
    const int b = 20;
    // undef a
}
void fun2() {
    printf("a%d\n", a); //a可以使用，如果fun1 加了宏删除undef a则不用使用
    printf("b%d\n", b); //b不可以使用，超过b的作用域
}
```
## 引用
### 引用概念
- C++中新增加了引用的概念
- 引用可以看作一个一定义变量的别名
```c++
void main() {
    int a = 10;
    int& b = a;
    b = 20;
    printf("a:%d\n", a); //20
    // int& c; 编译错误，普通引用必须要初始化
}
```
### 引用的意义
- 引用作为其他变量的别名而存在，因此在一些场合可以替代指针
- 引用相对于指针来说具有更好的可读性和实用性
```c++
void swap(int& a, int& b) {
    int t = a;
    a = b;
    b = t;
}
```
### 引用的本质
- 引用在C++中的内部实现是一个常指针 type& name <=> type* const name;
- C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。
- 从使用的角度，引用会让人误会其只是一个别名，没有字节的存储空间。这是C++为了实用性而做出的细节隐藏
### 函数返回值是引用
- 当函数返回值为引用时：若返回栈变量，不能成为其他引用的初始值，不能作为左值使用
- 若返回静态变量或全局变量：可以成为其他引用的初始值，即可作为右值使用，也可作为左值使用
- C++链式编程中，经常用到引用
```c++
#include <iostream>

using namespace std;

int getA1() {
	int a;
	a = 10;
	return a;
}

int& getA2() {
	int a;
	a = 10;
	return a;
}

int* getA3() {
	int a;
	a = 10;
	return &a;
}

//返回变量的值
int j1() {
	static int a = 10;
	a++;
	return a;
}
//返回变量本身
int& j2() {
	static int a = 10;
	a++;
	return a;
}

void main() {
	int a1 = getA1();
	int a2 = getA2();
	int& a3 = getA2();
	printf("a1:%d, a2:%d, a3:%d\n", a1, a2, a3);

    int b1 = 10;
    int b2 = 20;
    b1 = j1();
    b2 = j2();
    int& b3 = j2();
    printf("b1:%d, b2:%d, b3:%d\n", b1, b2, b3);

	// j1() = 100;
	j2() = 100;
	printf("b3:%d\n", b3); // 100
    
	system("pause");
}
```
### 指针的引用
```c++
#include <iostream>

using namespace std;

struct Teacher {
	char name[64];
	int age;
};

int getTeacher01(Teacher** p) {
	if (p == NULL) {
		return -1;
	}
	Teacher* tmp;
	tmp = (Teacher*)malloc(sizeof(Teacher));
	if (tmp == NULL) {
		return -2;
	}
	tmp->age = 33;
	*p = tmp;
	return 0;
}

int getTeacher02(Teacher*& p) {
	p = (Teacher*)malloc(sizeof(Teacher));
	if (p == NULL) {
		return -1;
	}
	p->age = 32;
	return 0;
}

void freeTeacher(Teacher* p) {
	if (p != NULL) {
		free(p);
	}
}

void main() {
	Teacher* p = NULL;
	// C语言中的二级指针
	getTeacher01(&p);
	cout << "age:" << p->age << endl;
	freeTeacher(p);
	// C++中的引用(指针的引用)
	// 引用的本质：间接赋值的后两个条件让C++编译器帮我们程序员做了
	getTeacher02(p);
	cout << "age:" << p->age << endl;
	freeTeacher(p);
	system("pause");
}
```
### 常引用
```c++
#include <iostream>
using namespace std;

void main() {
	// 普通引用
	int a = 10;
	int& b = a;
	cout << "b:" << b << endl;
	// 常引用
	int x = 20;
	// 常引用初始化 分为两种情况
	// 1. 用变量初始化常引用
	const int& y = x; // 常引用是让变量引用只读属性，不能通过y去修改x了
	// y = 21; 编译报错
	// 2. 用常量（字面量）初始化常引用
	const int m = 10; // C++编译器把m放在符合表中
	// int& d = 10; 编译报错，普通引用不能用字面量去初始化
	const int& n = 10; //C++编译器会给m分配内存空间

	system("pause");
}
```
- const& 相当于 const int* const e
- 普通引用相当于 int* const e
- 当使用常量（字面量）对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
- 使用字面量对const初始化后，将生成一个只读变量
## inline内联函数
- 内联函数在最终生成的代码中是没有定义的
- 编译器直接将函数体插入函数调用的地方
- 内联函数没有普通函数调用时的额外开销（压栈、跳转、返回）
- 内联函数由编译器处理，直接将编译后的函数体插入调用的地方
- 宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程
- 编译器对内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远远大于压栈、跳转、返回所用的开销时，那么内联将无意义
- inline只是一种请求，编译器不一定允许这种请求
```c++
#include <iostream>
using namespace std;

inline void printA() {
	int a = 10;
	cout << "a:" << a << endl;
}
void main() {
	printA();
	system("pause");
}
```
## 函数参数扩展
### 默认参数
- C++中可以在函数声明时为参数提供一个默认值，当函数调用时没有指定这个参数的值，编译器会自动用默认值代替
- 函数默认参数的规则：只有参数列表后面部分的参数才可以提供默认参数值，一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值
```c++
#include <iostream>
using namespace std;

void print(int x = 3) {
	cout << "x:" << x << endl;
}

//void print1(int m, int n, int x = 3, int y) { //编译错误
void print1(int m, int n, int x = 3, int y = 4) {
	cout << "x:" << x << endl;
}

void main() {
	print(4);
	print();
	system("pause");
}
```
### 函数占位参数
- 占位参数只有参数类型声明，而没有参数声明，一般情况下，在函数体内部无法使用占位参数
- 函数调用时，必须写够参数
```c++
void func(int a, int b, int) {
	cout << "a:" << a << ",b:" << b << endl;
}

void main() {
	//func1(1, 2); //编译错误
	func(1, 2, 3);
	system("pause");
}
```
### 默认参数和占位参数
- 可以将默认参数和占位参数结合起来使用。为以后程序的扩展留下线索，兼容C语言程序中可能出现不规范写法
```c++
void func(int a, int b, int = 0) {
	cout << "a:" << a << ",b:" << b << endl;
}

void main() {
	func(1, 2);
	func(1, 2, 3);
	system("pause");
}
```
### 函数重载
- 概念：用同一个函数名定义不同的函数，当函数名和不同的参数搭配时函数的含义不同
- 函数重载的判断标准：函数重载至少满足下面的一个条件；参数个数不同、参数类型不同、参数顺序不同
- 函数返回值不是函数重载的判断标准
```c++
#include <iostream>
using namespace std;

void print0(int a) {
	cout << "a:" << a << endl;
}

void print0(char* p) {
	cout << "p:" << p << endl;
}

void print0(int a, int b) {
	cout << "a:" << a << ",b:" << b << endl;
}

void main() {
	print0(1);
	char buf[128] = "hello";
	print0(buf);
	print0(1, 2);
	system("pause");
}
```
- 函数重载遇见默认参数
```c++
int func0(int a, int b, int c = 0) {
	return a + b + c;
}

int func0(int a, int b) {
	return a + b;
}
void main() {
	print0(1);
	// func0(1, 2); 存在二义性，调用失败，编译不通过
	system("pause");
}
```
### 函数重载和函数指针结合
- 当使用重载函数名对函数指针进行赋值时，根据重载规则挑选与函数指针参数列表一致的候选者，根据重载规则挑选与函数指针参数列表一致的候选者，严格匹配候选者的函数类型与函数指针的函数类型
```c++
#include <iostream>
using namespace std;

void func1(int a) {
	cout << "a:" << a << endl;
}

void func1(int a, int b) {
	cout << "a:" << a << ", b:" << b << endl;
}

void func1(char* a, char* b) {
	cout << "a:" << a << ", b:" << b << endl;
}

void func1(char* p) {
	cout << "p:" << p << endl;
}

//函数指针：
// 1.声明一个函数类型 
typedef void (type_func)(int a, int b);
// type_func* func = NULL; // 定义一个函数指针，这个指针指向函数的入口地址
// 2.声明一个函数指针类型 
typedef void (*p_type_func)(int a, int b);
// p_type_func fp = NULL; //通过函数指针类型定义了一个函数指针
// 3.定义一个函数指针变量
void (*var_p_type_func)(int a, int b);

void main() {
	p_type_func fp = NULL; //定义一个函数指针变量
	fp = func1;
	fp(1, 2);
	system("pause");
}
```
# 面向对象初步
## 类型的封装和访问控制
```c++
#include <iostream>
using namespace std;

class Circle {
private:
	double m_r;
	double m_s;
public:
	double getR() {
		return m_r;
	}
	void setR(double r) {
		m_r = r;
	}
	double getS() {
		m_s = 3.1415926 * m_r * m_r;
		return m_s;
	}
};

void print1(Circle* pc) {
	cout << "r:" << pc->getR() << ", s:" << pc->getS() << endl;
}

void print2(Circle& c) {
	cout << "r:" << c.getR() << ", s:" << c.getS() << endl;
}

void print3(Circle c) {
	cout << "r:" << c.getR() << ", s:" << c.getS() << endl;
}

void main() {
	Circle c1, c2;
	c1.setR(10);
	c2.setR(20);
	print1(&c1);
	print2(c2);
	print3(c2);
	cout << "hello" << endl;
	system("pause");
}
```
## struct和class区别
- 用struct定义类时，所有成员默认属性为public
- 用class定义类时，所有成员默认属性为private
## 类的声明和类的实现分开
```c++
// Teacher.h
#pragma once //只包含一次
//等价于
/*
#ifndef __TEACHER_H__
#define __TEACHER_H__

#endif
*/

class Teacher {
private:
	int m_age;
	char m_name[32];
public:
	void setAge(int age);
	int getAge();
};

// Teacher.cpp
#include "Teacher.h"

void Teacher::setAge(int age) {
	m_age = age;
}

int Teacher::getAge() {
	return m_age;
}

// main.cpp
#include <iostream>
#include "Teacher.h"

using namespace std;

void main() {
	Teacher t1;
	t1.setAge(30);
	cout << "t1.age: " << t1.getAge() << endl;
	system("pause");
}
```
## 对象的构造和析构
### 构造和析构函数
```c++
#include <iostream>
using namespace std;

class Test {
private:
	int a;
	char* p;
public:
	Test() { //构造函数
		a = 10;
		p = (char*)malloc(100);
		strcpy(p, "hello p");
		cout << "Construtor" << endl;
	}
	void print() {
		cout << "a: " << a << endl;
		cout << "p: " << p << endl;
	}
	~Test() { //析构函数
		if (p != NULL) {
			free(p);
		}
		cout << "Destructor" << endl;
	}
};

void obj_play() {
	Test t1;
	t1.print();
	cout << "分隔符" << endl;
}

void main() {
	obj_play();
	cout << "hello" << endl;
	system("pause");
}
```
### 构造函数的分类
```c++
#include <iostream>
using namespace std;

class Test {
private:
	int m_a;
	int m_b;
public:
	Test() {
		m_a = 0;
		m_b = 0;
		cout << "无参构造函数" << endl;
	}
	Test(int a) {
		m_a = a;
		m_b = 0;
		cout << "有参构造函数" << endl;
	}
	Test(int a, int b) {
		m_a = a;
		m_b = b;
		cout << "有参构造函数" << endl;
	}
	Test(const Test& obj) {
		m_a = obj.m_a;
		m_b = obj.m_b;
		cout << "赋值(拷贝)构造函数" << endl;
	}
	void print() {
		cout << "a:" << m_a << ", b:" << m_b << endl;
	}
};

void f(Test t) {
	t.print();
}

Test g() {
	Test t(10, 10);
	return t;
}

static void obj_play() {
	Test t0 = Test(); //调用无参构造函数
	t0.print();
	Test t1; //调用无参构造函数
	t1.print();
	// 调用有参构造函数三种方式
	Test t2(1, 2); //括号法
	t2.print();
	Test t3 = 3; //等号法
	t3.print();
	Test t4 = Test(4, 5); //直接（手动）调用构造函数
	t4.print();

	// 拷贝构造函数四种调用时机
	t0 = t4; //用t4给t0赋值（和初始化时两个不同的概念）赋值操作不会调用拷贝构造函数，会调用操作符重载operator=()
	// 1.调用时机一：用一个对象去初始化另外一个对象
	Test t5 = t4; // 用t4来初始化t5
	t5.print();
	// 2.调用时机二：用一个对象去初始化另外一个对象
	Test t6(t4);
	t6.print();
	// 3.调用时机三:实参去初始化形参，会调用copy构造函数
	f(t4);
	// 4.调用时机四: 匿名对象（最新的C++版本没有复现）
	cout << "分隔符" << endl;
	Test t7 = g(); 
}

void main() {
	obj_play();
	cout << "hello" << endl;
	system("pause");
}
```
### 构造函数调用规则研究
- 当类中没有定义任何一个构造函数时，C++编译器会提供默认无参构造函数和默认拷贝构造函数
- 当类中定义了拷贝构造函数时，C++编译器不会提供无参构造函数
- 当类中定义了任意的非拷贝构造函数（即：当类中提供了有参构造函数或无参构造函数），C++编译器不会提供无参构造函数
- 默认拷贝构造函数成员变量简单赋值
- 只要写了构造函数，必须用
### 深拷贝和浅拷贝
```c++
#include <iostream>
using namespace std;

class Name {
private:
	char* m_p;
	int m_len;
public:
	Name(const char* p) {
		m_len = strlen(p);
		m_p = (char*)malloc(m_len + 1);
		strcpy(m_p, p);
	}
	Name(const Name& obj) {
		m_len = obj.m_len;
		m_p = (char*)malloc(m_len + 1);
		strcpy(m_p, obj.m_p);
	}
	~Name() {
		if (m_p != NULL) {
			free(m_p);
			m_p = NULL;
			m_len = 0;
		}
	}
};

static void obj_play() {
	Name obj1("hello, world");
	Name obj2 = obj1;
}

void main() {
	obj_play();
	system("pause");
}
```
### 构造函数的初始化列表
```c++
#include <iostream>
using namespace std;

class A {
private:
	int a;
public:
	A(int _a) {
		a = _a;
		cout << "构造 a:" << a << endl;
	}
	~A() {

		cout << "析构 a:" << a << endl;
	}
};

//构造函数初始化列表： 解决：在B类中组合了一个A类对象（A类设计了构造函数）
//根据构造函数的调用规则 ：设计了A的构造函数，必须要用，没有机会初始化A
/*
Construtor::Constructor(): m1(v1), m2(v2) {
}
*/
class B {
private:
	int b1;
	int b2;
	A a1;
	A a2;
public:
	B(int _b1, int _b2) : a1(1), a2(2) {
		b1 = _b1;
		b2 = _b2;
		cout << "构造 b:" << b1 << endl;
	}
	B(int _b1, int _b2, int m, int n) : a2(m), a1(n) {
		b1 = _b1;
		b2 = _b2;
		cout << "析构 b:" << b1 << endl;
	}
};

static void obj_play() {
	A a1(10);
	B b1(1, 2);
	// 参数传递
	B b2(1, 2, 3, 4);
	// 执行顺序：先执行被组合对象的构造函数，如果组合对象有多个，按照定义顺序，而不是按照初始化列表的顺序
	// 析构函数：和构造函数的调用顺序相反
}

void main() {
	obj_play();
	system("pause");
}
```
- 使用初始化列表出现的原因
1. 如果我们有一个类成员，它本身时一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，而没有默认构造函数，这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，如果没有初始化列表，那么它将无法完成第一步，就会报错
2. 类成员中若有const修饰，必须在对象初始化的时候，给属性赋值，当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。
### 构造和析构综合练习
```c++
#include <iostream>
using namespace std;

class AB {
private:
	int a;
	int b;
public:
	AB(int a, int b) {
		this->a = a;
		this->b = b;
		cout << "AB Constructor, a:" << a << " b:" << b << endl;
	}
	~AB() {
		cout << "AB Destructor, a:" << a << " b:" << b << endl;
	}

	int getA() {
		return a;
	}
};

class C {
private:
	AB ab1;
	AB ab2;
	const int m;
public:
	C() : ab1(1, 2), ab2(3, 4), m(1) {
		cout << "C Constructor" << endl;
	}
	~C() {
		cout << "C Destructor" << endl;
	}
	C(const C& obj) : ab1(5, 6), ab2(7, 8), m(1) {
		cout << "C copy Constroctor" << endl;
	}
	AB getAB1() {
		return ab1;
	}
};

void doC(C c) {
	cout << "doC ab1.a:" << c.getAB1().getA() << endl;
}

void run() {
	C c;
	doC(c);
}

void run1() {
	AB(10, 10); //临时对象声明周期，这行代码执行后会调用AB的构造和析构函数
}

void main() {
	//run();
	run1();
	system("pause");
}
```
### 构造中调用构造
```c++
#include <iostream>
using namespace std;

class D {
private:
	int a;
	int b;
public:
	D(int a) {
		this->a = a;
		// D(a, 1); 构造中调用构造是危险行为，此行代码会生成一个匿名对象，就析构了。
	}
	D(int a, int b) {
		this->a = a;
		this->b = b;
	}
	~D() {
		cout << "D Destructor" << endl;
	}
	void print() {
		cout << "a: " << a << ", b: " << b << endl;
	}
};
void runD() {
	D d(1);
	d.print();
}

void main() {
	runD();
	system("pause");
}
```
## new和delete
```c++
#include <iostream>
using namespace std;

class Obj {
private:
	int a;
public:
	Obj(int a) {
		this->a = a;
		cout << "Obj Constructor" << endl;
	}
	~Obj() {
		cout << "Obj Destructor" << endl;
	}
};

void main() {
	//分配基础类型
	int* p1 = (int*)malloc(sizeof(int));
	*p1 = 10;
	int* p2 = new int;
	*p2 = 20;
	int* p3 = new int(30);
	cout << "*p1:" << *p1 << endl;
	cout << "*p2:" << *p2 << endl;
	cout << "*p3:" << *p3 << endl;
	free(p1); //delete p1; ok
	delete p2; // free(p2); ok
	delete p3; // free(p3); ok
	//分配数组变量
	int* arr1 = (int*)malloc(sizeof(int) * 10);
	arr1[0] = 1;
	free(arr1); // delete[] arr1; ok
	int* arr2 = new int[10];
	arr2[0] = 1; 
	delete[] arr2; //数组delete不要把[]忘记 free(arr2); ok
	//分配对象
	Obj* obj1 = (Obj*)malloc(sizeof(Obj));
	free(obj1); // delete obj1;会执行析构方法
	Obj* obj2 = new Obj(10); //会调用构造方法
	delete obj2; //会调用析构函数 free(obj2);不会执行析构函数
	system("pause");
}
```
## 静态成员变量和静态成员函数
```c++
#include <iostream>
using namespace std;

class S{
private:
	int a;
	int b;
	static int c;
public:
	static int getC() {
		return c;
	}
	void addC() {
		c++;
	}
};

int S::c = 0; //不给静态变量声明初始值，编译会报错

void main() {
	S s1,s2,s3;
	cout << "c:" << S::getC() << endl;
	s2.addC();
	s3.addC();
	cout << "c:" << S::getC() << endl;
	system("pause");
}
```
## 面向对象模型初探
```c++
#include <iostream>
using namespace std;

class C1 {
private:
	int i;
	int j;
	int k;
};

class C2 {
private:
	int i;
	int j;
	int k;
	static int m;
public:
	int getK() {
		return k;
	}
	void setK(int _k) {
		k = _k;
	}
};

struct S1 {
	int i;
	int j;
	int k;
};

struct S2 {
	int i;
	int j;
	int k;
	static int m;
};

void main() {
	cout << "C1: " << sizeof(C1) << endl; //12
	cout << "C2: " << sizeof(C2) << endl; //12
	cout << "S1: " << sizeof(S1) << endl; //12
	cout << "S2: " << sizeof(S2) << endl; //12
	system("pause");
}
```
- C++类对象中的成员变量和成员函数是分开存储的
- 普通成员变量：存储于对象中，与struct变量有相同的内存布局和字节对齐方式
- 静态成员变量：存储于全局数据区中
- 成员函数：存储于代码段中
```c++
class Test {
private:
	int m;
public:
	Test(int _m) {
		m = _m;
	}
	int getM() {
		return m;
	}
	static void print() {
		cout << "hello" << endl;
	}
};
Test a(10);
a.getM();
Test::print();
```
- 用C语言实现上述类功能
```c
struct Test {
	int m;
}
void Test_initialize(Test* pThis, int m) {
	pThis->m = m;
}
int Test_getM(Test* pThis) {
	return pThis->m;
}
void Test_print() {
	printf("hello\n");
}
Test a;
Test_initialize(&a, 10);
Test_getM(&a);
Test_print();
```
- C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效
- C++中类的普通成员函数都隐式包含一个指向当前对象的this指针
- 静态成员函数、成员变量属于类
- 静态成员函数于普通成员函数的区别：静态成员函数不包含指向具体对象的指针；普通成员函数包含一个指向具体对象的指针
## const修饰this
```c++
#include <iostream>
using namespace std;

class T {
private:
	int a;
	int b;
public:
	// const写在以下三个位置都可以，C++编译后的代码类似于 void op_var(const T* this, int a, int b)
	// const修饰的是this指针所指向的内存空间，修饰的是this指针
	void op_var(int a, int b) const {
	//const void op_var(int a, int b) {
	//void const op_var(int a, int b) {
		//this->a = 100; //编译报错，不能被修改
		//this->b = 200; //编译报错，不能被修改
		cout << "a: " << a << endl;
		cout << "b: " << b << endl;
	}
};

void main() {
	T t;
	t.op_var(1, 2);
	system("pause");
}
```
## 全局函数和成员函数
- 把全局函数转成成员函数，通过this指针隐藏左操作数 Test add(Test& t1, Test& t2) ===> Test add(Test& t2)
- 把成员函数转成全局函数，多了一个参数 void print() ===> void print(Test* p)
- 函数返回引用，return *this
```c++
#include <iostream>
using namespace std;

class TT {
private:
	int a;
	int b;
public:
	void printT() {
		cout << "a:" << a << ",b:" << b << endl;
	}
	TT TTAdd(TT& other) {
		TT tmp(this->a + other.a, this->b + other.b);
		return tmp;
	}
	//返回一个引用相当于返回自身
	TT& TTAdd2(TT& other) {
		this->a += other.a;
		this->b += other.b;
		return *this;
	}
public:
	TT(int a=0, int b=0) {
		this->a = a;
		this->b = b;
		cout << this << " Construtor" << endl;
	}
	~TT() {
		cout << this << " Destrutor" << endl;
	}
	TT(const TT& obj) {
		this->a = obj.a;
		this->b = obj.b;
		cout << this << " Copy Construtor" << endl;
	}
};
//全局函数
//全局函数转成成员函数少了一个参数
TT TTAdd(TT& t1, TT& t2) {
	TT tmp;
	return tmp;
}

//把成员函数转成全局函数，多了一个参数
void printT(TT* p) {

}

static void obj_play() {
	TT t1(1,2);
	TT t2(3,4);
	TT t3 = t1.TTAdd(t2); //匿名对象直接转成t3
	t3.printT();
	TT t4;
	t4 = t1.TTAdd(t2); //匿名对象 复制 给t4
	t2.TTAdd2(t1);
	t2.printT();
}

int main() {
	obj_play();
	system("pause");
}
```
## 数组类的简单封装
- MyArray.h
```c++
#pragma once
#include <iostream>

class Array {
private:
	int len;
	int* space;
public:
	Array(int len);
	Array(const Array& obj);
	~Array();
public:
	void setData(int index, int value);
	int getData(int index);
	int length();
};
```
- MyArray.cpp
```c++
#include "MyArray.h"

Array::Array(int len) {
	if (len < 0) {
		len = 0;
	}
	this->len = len;
	this->space = new int[len];
}
Array::Array(const Array& obj) {
	this->len = obj.len;
	this->space = new int[obj.len];
	for (int i = 0; i < len; i++) {
		this->space[i] = obj.space[i];
	}
}
Array::~Array() {
	if (space != NULL) {
		delete[] space;
		len = 0;
	}
}

void Array::setData(int index, int value) {
	space[index] = value;
}
int Array::getData(int index) {
	return space[index];
}
int Array::length() {
	return this->len;
}
```
- MyArrayTest.cpp
```c++
#include <iostream>
#include "MyArray.h"
using namespace std;

int main() {
	Array a1(10);
	for (int i = 0; i < 10; i++) {
		a1.setData(i, i);
	}
	for (int i = 0; i < 10; i++) {
		cout << a1.getData(i) << endl;
	}
	Array a2 = a1;
	cout << "a2" << endl;
	for (int i = 0; i < 10; i++) {
		cout << a2.getData(i) << endl;
	}
	system("pause");
	return 0;
}
```
# 友元
## 友元函数
- 通过友元函数可以修改类的私有属性
```c++
#include <iostream>
using namespace std;

class F {
private:
	int a;
	int b;
	//友元函数的声明位置和public,private没有关系
	friend void modifyF(F* p, int a, int b);
public:
	F(int a, int b) {
		this->a = a;
		this->b = b;
	}
	void print() {
		cout << "a:" << a << ", b:" << b << endl;
	}
};

void modifyF(F* p, int a, int b) {
	p->a = a;
	p->b = b;
}

void main() {
	F f(1, 2);
	f.print();
	modifyF(&f, 3, 4);
	f.print();
	system("pause");
}
```
## 友元类
- 若B类是A类的友元类，则B类的所有成员函数都是A类的友元函数
- 友元类通常设计为一种对数据操作或类之间传递消息的辅助类
- 为什么设计友元类友元函数：Java语言中Test.java -> Test.class(字节码) -> 反射机制分析Test.class找到类对象，直接修改类的私有属性
```c++
#include <iostream>
using namespace std;

class FriendA {
private:
	int a;
	//声明B类是A的好朋友，在B中可以访问A类的私有属性，私有函数
	friend class FriendB;
public:
	FriendA(int a=0) {
		this->a = a;
	}
	void print() {
		cout << "a:" << a << endl;
	}
};

class FriendB {
private:
	FriendA* A;
public:
	FriendB(FriendA* A) {
		this->A = A;
	}
	void set(int a) {
		A->a = a;
	}
};

void main() {
	FriendA A(10);
	A.print();
	FriendB B(&A);
	B.set(20);
	A.print();
	system("pause");
}
```
# 运算符重载
## 运算符重载入门技术推演
- 运算符重载两种方式
```c++
#include <iostream>
using namespace std;

class Complex {
private:
	int a;
	int b;
	friend Complex operator+(Complex& c1, Complex& c2);
	//友元函数实现前置++
	friend Complex& operator++(Complex& c);
	//友元函数实现后置++
	friend Complex operator++(Complex& c, int);
	//友元函数实现<<
	friend ostream& operator<<(ostream& out, Complex c);
public:
	Complex(int a=0, int b=0) {
		this->a = a;
		this->b = b;
	}
	void print() {
		cout << "a:" << a << ",b:" << b << endl;
	}
	//成员函数实现运算符重载
	Complex operator-(Complex& other) {
		return Complex(this->a - other.a, this->b - other.b);
	}
	//成员函数实现前置--
	Complex& operator--() {
		this->a--;
		this->b--;
		return *this;
	}
	//成员函数实现后置--
	Complex operator--(int) {
		Complex tmp = *this;
		this->a--;
		this->b--;
		return tmp;
	}
};

//全局函数实现运算符重载
Complex operator+(Complex& c1, Complex& c2) {
	return Complex(c1.a + c2.a, c1.b + c2.b);
}

Complex& operator++(Complex& c) {
	c.a++;
	c.b++;
	return c;
}

Complex operator++(Complex& c, int) {
	Complex tmp = c;
	c.a++;
	c.b++;
	return tmp;
}

ostream& operator<<(ostream& out, Complex c) {
	out << "a:" << c.a << ",b:" << c.b << endl;
	return out;
}

void main() {
	int a = 10, b = 10;
	int c;
	c = a + b; //基础数据类型 编译器已经知道如何进行运算
	cout << "c:" << c << endl;
	Complex c1(1, 2);
	Complex c2(3, 4);
	Complex c3; //类也是一种数据类型，用户自定义数据类型C++编译器是不知道如何进行运算
	// C++编译器应该给我们程序员提供一种机制，让自定义数据类型有机会进行运算符操作 ==> 运算符重载机制
	c3 = c1 + c2;
	c3.print();
	Complex c4;
	c4 = c2 - c1;
	c4.print();

	//前置++操作符，用全局函数重载 ++c1
	++c1;
	c1.print();
	//前置--操作符，用成员函数重载 --c1
	--c1;
	c1.print();
	//后置++操作符，用全局函数重新 c1++
	c1++;
	c1.print();
	//后置--操作符，用成员函数重载 c1--
	c1--;
	c1.print();
	//重载<<操作符 cout.operator<<(Complex c).operator("hello");
	//函数返回值当左值，需要返回一个引用
	cout << c1 << "hello" << endl;
	system("pause");
}
```
## 友元函数重载操作符使用注意点
- 友元函数重载常用于运算符的左右操作数据类型不同的情况 Complex c; c + 1, 1 + c(1.operator+(c))
- 在第一个参数需要隐式转换的情况下，使用友元函数重载运算符是正确的选择
- 友元函数没有this指针，所需操作数都必须在参数显式声明，很容易实现类型的隐式转换
- C++中不用用友元函数重载的运算符有：= () [] ->
## 等号运算符重载
```c++
#include <iostream>
using namespace std;

class Name {
private:
	int len;
	char* p;
	friend ostream& operator<<(ostream& out, Name n);
public:
	Name(const char* p) {
		this->len = strlen(p);
		this->p = (char*)malloc(this->len + 1);
		strcpy(this->p, p);
	}
	//拷贝构造函数Name n2 = n1;
	Name(const Name& other) {
		this->len = other.len;
		this->p = (char*)malloc(this->len + 1);
		strcpy(this->p, other.p);
	}
	~Name() {
		if (this->p != NULL) {
			free(p);
		}
		this->len = 0;
	}
	// n2 = n1;
	Name& operator=(Name& other) {
		//先释放内存
		if (this->p != NULL) {
			delete this->p;
			this->len = 0;
		}
		this->len = other.len;
		this->p = new char[this->len + 1]; //malloc也可
		strcpy(this->p, other.p);
		return *this;
	}
};

ostream& operator<<(ostream& out, Name n) {
	out << n.p;
	return out;
}

void obj_play() {
	Name n1("hello");
	Name n2 = n1;
	Name n3("hi");

	n1 = n2 = n3;;
	cout << n1 << endl;
	cout << n2 << endl;
	cout << n3 << endl;
}

int main() {
	obj_play();
	system("pause");
}	
```
# 继承
# 多态
# C++异常和IO流