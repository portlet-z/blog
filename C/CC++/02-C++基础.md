# hello
```c++
#include <iostream>

using namespace std; //使用命名空间std标准的命名空间

int main()
{
	// cout标准输出
	// << 左移操作符 在C++里面功能的改造（增强） ===> C++ 语言操作符重载
	// endl \n
	cout << "Hello World." << endl;
	system("pause");
	return 0;
}
```
# C++对C的加强
## namespace
- 所谓namespace,是指标识符的各种可见范围
- 当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespce std;这样才能正确使用cout
- 在C++中，名称(name)可以是符合常量、变量、宏、函数、结构体、枚举、类和对象等等。为了避免在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突。
- 标准C++引入了关键字namespace(命名空间/名字空间/名称空间/名域)，可以更好地控制标识符地作用域
- C中的命名空间
    - 在C语言中只有一个全局作用域
    - C语言中所有的全局标识符共享同一个作用域
    - 标识符之间可能发生冲突
- C++中提出了命名空间的概念
    - 命名空间将全局作用域分成不同的部分
    - 不同命名空间中的标识符可以同名而不会发生冲突
    - 命名空间可以相互嵌套
## 实用性增加
- C语言中的变量都必须在作用域开始的位置定义
- C++中更强调语言的实用性，所有的变量都可以在需要使用时再定义。
## register关键字增强
- register关键字请求编译器将局部变量存储于寄存器中；C语言中无法取得register变量地址；在C++中依然支持register关键字；C++编译器有自己的优化方式，不使用register也可能做优化；C++中可以取得register变量的地址
- C++编译器发现程序中需要取register变量的地址时，register对变量的声明变得无效
- 早期C语言编译器不会对代码进行优化，因此register变量时一个很好的补充.
## 变量类型检测增强
- 在C语言中，重复定义多个同名的全局变量是合法的，C语言中多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上
- 在C++中，不允许定义多个同名的全局变量
## struct类型增强
- C语言的struct定义了一组变量的集合，C编译器并不认为这是一种新的类型
- C++中的struct是一个新类型的定义声明
- struct关键字class关键字，完成的功能是一样的
```c
struct Teacher {
    char name[64];
    int age;
};
void main() {
    struct Teacher t1; //C中struct关键字不能省略
    Teacher t2; //C++中不用写struct关键字
}
```
## C++中所有的变量和函数都必须有类型
- 在C语言中
    - int f(): 表示返回值为int, 接受任意参数的函数
    - int f(void): 表示返回值为int的无参函数
- 在C++中
    - int f()和int f(void)具有相同的意义，都表示返回值为int的无参函数
- C++中更加强调类型，任意的程序元素都必须显示指明类型
```c
f(i) {
    printf("i = %d\n", i);
}
g() {
    return 5;
}
void main() {
    f(10);
    g(1,2,3,4,5);
}
```
## 新增bool类型关键字
- 理论上只占一个字节
- 如果多个bool变量定义在一起，可能会各占一个bit,这取决于编译器的实现
- true代表真值，编译器内部哦那个1来表示。false代表非真值，编译器内部用0来表示
## 三目运算符增强
- 在C语言中，表达式的结果放在什么地方：寄存器
- 在C语言中，表达式的返回值是变量的值
- 在C++中，表达式返回的是变量的本身
- 如何做到的：让表达式返回一个内存空间，内存首地址
- C++编译器帮我们程序员完成了取地址的工作
- 注意：三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用 (a < b ? 1 : b)
```c++
#include <iostream>

using namespace std;

void main() {
	int a = 10;
	int b = 20;
	(a < b ? a : b) = 30; //在C中编译器会报错，C++中没问题
    // *(a < b ? &a : &b) = 30 类似于C中这种编写
	cout << "a = " << a << endl; // 30
	cout << "b = " << b << endl; // 20
	system("pause");
}
```
## C/C++中的const
```c++
struct Teacher {
    char name[64];
    int age;
};
//指针所指向的内存空间不能被修改
int operatorTeacher01(const Teacher* pt) {
    //pt->age = 10;
    return 0;
}
//指针变量本身不能被修改
int operatorTeacher02(Teacher* const pt) {
    //pt = NULL;
    pt->age = 10;
    return 0;
}
int operatorTeacher03(const Teacher* const pt) {
    printf("age:%d\n", pt->age);
    return 0;
}
void main() {
    const int a = 10;
    //a=11;
    int* p = NULL;
    p = (int*)&a;
    *p = 20;
    // C编译器中执行为20，C++中为10
    // C++中的实现方式，常量存在一个符合表(key->value)里 
    // C语言中的const是一个冒牌货，C++语言中const是一个真正的常量
    // const分配内存时机：编译器编译期间
    printf("a:%d\n", a);
}
```
- const和#define区别
    - C++中的const常量类似于宏定义：const int a = 5; #define c 5
- C++中的const常量在与宏定义的不同
    - const产量是由编译器处理的，提供类型检查和作用域检查
    - 宏定义由预处理器处理，单纯的文本替换
```c++
void fun1() {
    #define a 10
    const int b = 20;
    // undef a
}
void fun2() {
    printf("a%d\n", a); //a可以使用，如果fun1 加了宏删除undef a则不用使用
    printf("b%d\n", b); //b不可以使用，超过b的作用域
}
```
## 引用
### 引用概念
- C++中新增加了引用的概念
- 引用可以看作一个一定义变量的别名
```c++
void main() {
    int a = 10;
    int& b = a;
    b = 20;
    printf("a:%d\n", a); //20
    // int& c; 编译错误，普通引用必须要初始化
}
```
### 引用的意义
- 引用作为其他变量的别名而存在，因此在一些场合可以替代指针
- 引用相对于指针来说具有更好的可读性和实用性
```c++
void swap(int& a, int& b) {
    int t = a;
    a = b;
    b = t;
}
```
### 引用的本质
- 引用在C++中的内部实现是一个常指针 type& name <=> type* const name;
- C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。
- 从使用的角度，引用会让人误会其只是一个别名，没有字节的存储空间。这是C++为了实用性而做出的细节隐藏
### 函数返回值是引用
- 当函数返回值为引用时：若返回栈变量，不能成为其他引用的初始值，不能作为左值使用
- 若返回静态变量或全局变量：可以成为其他引用的初始值，即可作为右值使用，也可作为左值使用
- C++链式编程中，经常用到引用
```c++
#include <iostream>

using namespace std;

int getA1() {
	int a;
	a = 10;
	return a;
}

int& getA2() {
	int a;
	a = 10;
	return a;
}

int* getA3() {
	int a;
	a = 10;
	return &a;
}

//返回变量的值
int j1() {
	static int a = 10;
	a++;
	return a;
}
//返回变量本身
int& j2() {
	static int a = 10;
	a++;
	return a;
}

void main() {
	int a1 = getA1();
	int a2 = getA2();
	int& a3 = getA2();
	printf("a1:%d, a2:%d, a3:%d\n", a1, a2, a3);

    int b1 = 10;
    int b2 = 20;
    b1 = j1();
    b2 = j2();
    int& b3 = j2();
    printf("b1:%d, b2:%d, b3:%d\n", b1, b2, b3);

	// j1() = 100;
	j2() = 100;
	printf("b3:%d\n", b3); // 100
    
	system("pause");
}
```
### 指针的引用
```c++
#include <iostream>

using namespace std;

struct Teacher {
	char name[64];
	int age;
};

int getTeacher01(Teacher** p) {
	if (p == NULL) {
		return -1;
	}
	Teacher* tmp;
	tmp = (Teacher*)malloc(sizeof(Teacher));
	if (tmp == NULL) {
		return -2;
	}
	tmp->age = 33;
	*p = tmp;
	return 0;
}

int getTeacher02(Teacher*& p) {
	p = (Teacher*)malloc(sizeof(Teacher));
	if (p == NULL) {
		return -1;
	}
	p->age = 32;
	return 0;
}

void freeTeacher(Teacher* p) {
	if (p != NULL) {
		free(p);
	}
}

void main() {
	Teacher* p = NULL;
	// C语言中的二级指针
	getTeacher01(&p);
	cout << "age:" << p->age << endl;
	freeTeacher(p);
	// C++中的引用(指针的引用)
	// 引用的本质：间接赋值的后两个条件让C++编译器帮我们程序员做了
	getTeacher02(p);
	cout << "age:" << p->age << endl;
	freeTeacher(p);
	system("pause");
}
```
### 常引用
```c++
#include <iostream>
using namespace std;

void main() {
	// 普通引用
	int a = 10;
	int& b = a;
	cout << "b:" << b << endl;
	// 常引用
	int x = 20;
	// 常引用初始化 分为两种情况
	// 1. 用变量初始化常引用
	const int& y = x; // 常引用是让变量引用只读属性，不能通过y去修改x了
	// y = 21; 编译报错
	// 2. 用常量（字面量）初始化常引用
	const int m = 10; // C++编译器把m放在符合表中
	// int& d = 10; 编译报错，普通引用不能用字面量去初始化
	const int& n = 10; //C++编译器会给m分配内存空间

	system("pause");
}
```
- const& 相当于 const int* const e
- 普通引用相当于 int* const e
- 当使用常量（字面量）对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名
- 使用字面量对const初始化后，将生成一个只读变量
## inline内联函数
- 内联函数在最终生成的代码中是没有定义的
- 编译器直接将函数体插入函数调用的地方
- 内联函数没有普通函数调用时的额外开销（压栈、跳转、返回）
- 内联函数由编译器处理，直接将编译后的函数体插入调用的地方
- 宏代码片段由预处理器处理，进行简单的文本替换，没有任何编译过程
- 编译器对内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，当函数体的执行开销远远大于压栈、跳转、返回所用的开销时，那么内联将无意义
- inline只是一种请求，编译器不一定允许这种请求
```c++
#include <iostream>
using namespace std;

inline void printA() {
	int a = 10;
	cout << "a:" << a << endl;
}
void main() {
	printA();
	system("pause");
}
```