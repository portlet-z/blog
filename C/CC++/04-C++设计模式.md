# 设计模式基本原则
- 最终目的：高内聚，低耦合
- 开放封闭原则：类的改动时通过增加代码进行的，而不是修改源代码
```c++
#include <iostream>
using namespace std;

class BankWorker {
public:
	void save() {
		cout << "存款" << endl;
	}
	void moveMoney() {
		cout << "转账" << endl;
	}
	void payment() {
		cout << "交费" << endl;
	}
};

class AbstractBankWorker {
public:
	virtual void dothing() = 0;
};

class SaveBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "存款" << endl;
	}
};
class MoveBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "转账" << endl;
	}
};
class PaymentBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "交费" << endl;
	}
};

void bank_test1() {
	BankWorker* bw = new BankWorker;
	bw->save();
	bw->moveMoney();
	bw->payment();
}

void bank_test2() {
	AbstractBankWorker* bw = NULL;
	bw = new SaveBanker;
	bw->dothing(); //有多态发生
	delete bw;

	bw = new MoveBanker;
	bw->dothing();
	delete bw;
}

void bank_do(AbstractBankWorker* bw) {
	bw->dothing();
}

void bank_test3() {
	AbstractBankWorker* bw = NULL;
	bw = new SaveBanker;
	bank_do(bw);
	delete bw;

	bw = new MoveBanker;
	bank_do(bw);
	delete bw;
}

int main() {
	bank_test1();
	bank_test2();
	bank_test3();
	cin.get();
	return 0;
}
```
- 单一职责原则：类的职责要单一，对外只提供一种功能，而引起类变化的原因应该只有一个
- 依赖倒置原则：依赖于抽象（接口），不要依赖具体的实现类，也就是针对接口编程
```c++
#include <iostream>
using namespace std;

class HardDisk {
public:
	virtual void work() = 0;
};
class Memory {
public:
	virtual void work() = 0;
};
class CPU {
public:
	virtual void work() = 0;
};
//让Computer框架和具体的厂商进行解耦合
class Computer {
public:
	Computer(HardDisk* hard_disk, Memory* memory, CPU* cpu) {
		this->hard_disk = hard_disk;
		this->memory = memory;
		this->cpu = cpu;
	}
	void work() {
		hard_disk->work();
		memory->work();
		cpu->work();
	}
private:
	HardDisk* hard_disk;
	Memory* memory;
	CPU* cpu;
};
class IntelCPU : public CPU {
public:
	void work() {
		cout << "Intel CPU work" << endl;
	}
};
class WestDataHardDisk : public HardDisk {
public:
	void work() {
		cout << "West Data Hard Disk work" << endl;
	}
};
class JinShiDunMemory : public Memory {
public:
	void work() {
		cout << "JinShiDun Memory work" << endl;
	}
};

int main() {
	HardDisk* hard_disk = NULL;
	Memory* memory = NULL;
	CPU* cpu = NULL;
	
	hard_disk = new WestDataHardDisk;
	memory = new JinShiDunMemory;
	cpu = new IntelCPU;
	Computer* computer = new Computer(hard_disk, memory, cpu);
	computer->work();
	delete computer;
	delete cpu;
	delete memory;
	delete hard_disk;
	cin.get();
	return 0;
}
```
- 接口隔离原则：不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。
- 里氏替换原则：任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能
- 优先使用组合而不是继承原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果实现对象组合，就降低了这种依赖关系
- 迪米特法则：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）
# 创建型模式
## 单例模式
### 定义
- 保证一个类，只有一个实例的存在，同时提供能对该实例加以访问的全局访问方法
### 为什么使用单例模式
- 在多个线程之间，比如初始化一次socket资源，比如servlet环境，共享同一个资源或者操作同一个对象
- 在整个程序空间使用全局变量，共享资源
- 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等
### 实现单例模式常用步骤
- 构造函数私有化
- 提供一个全局的静态方法（全局访问点）
- 在类中定义一个静态指针，指向本类的变量的静态变量指针
### 懒汉式
```c++
#include <iostream>
using namespace std;

//懒汉式单例
class Singleton {
private:
	static Singleton* singleton;
	Singleton() {
		cout << "Singleton Constructor" << endl;
	}
public:
	static Singleton* getInstance() {
		if (singleton == NULL) {
			singleton = new Singleton;
		}
		return singleton;
	}
	static void freeInstance() {
		if (singleton != NULL) {
			delete singleton;
			singleton = NULL;
		}
	}
};
Singleton* Singleton::singleton = NULL;

int main() {
	Singleton* p1 = Singleton::getInstance();
	Singleton* p2 = Singleton::getInstance();
	if (p1 == p2) {
		cout << "p1,p2是同一个对象" << endl;
	}
	else {
		cout << "p1,p2不是同一个对象" << endl;
	}
	Singleton::freeInstance();
	cin.get();
	return 0;
}
```
### 饿汉式
```c++
#include <iostream>
using namespace std;

//饿汉式单例
class Singleton {
private:
	static Singleton* singleton;
	Singleton() {
		cout << "Singleton Constructor" << endl;
	}
public:
	static Singleton* getInstance() {
		return singleton;
	}
	static void freeInstance() {
		if (singleton != NULL) {
			delete singleton;
			singleton = NULL;
		}
	}
};
Singleton* Singleton::singleton = new Singleton;

int main() {
	Singleton* p1 = Singleton::getInstance();
	Singleton* p2 = Singleton::getInstance();
	if (p1 == p2) {
		cout << "p1,p2是同一个对象" << endl;
	}
	else {
		cout << "p1,p2不是同一个对象" << endl;
	}
	Singleton::freeInstance();
	cin.get();
	return 0;
}
```
### 懒汉式多线程安全
```c++
#include <iostream>
#include <thread>
#include <mutex>

using namespace std;

mutex global_lock;
//懒汉式单例
class Singleton0 {
private:
	static Singleton0* singleton;
	Singleton0() {
		count++;
		cout << "Singleton0 Constructor" << endl;
	}
public:
	static int count;
	static Singleton0* getInstance() {
		global_lock.lock();
		if (singleton == NULL) {
			singleton = new Singleton0;
		}
		global_lock.unlock();
		return singleton;
	}
	static void freeInstance() {
		if (singleton != NULL) {
			delete singleton;
			singleton = NULL;
		}
	}
};
Singleton0* Singleton0::singleton = NULL;
int Singleton0::count = 0;

int main() {
	thread t1(Singleton0::getInstance);
	thread t2(Singleton0::getInstance);
	thread t3(Singleton0::getInstance);
	t1.join();
	t2.join();
	t3.join();
	cout << Singleton0::count << endl;
	Singleton0::freeInstance();
	cin.get();
	return 0;
}
```
## 简单工厂模式
- 简单工厂模式属于类的创建型模式，又叫做静态工厂方法模式，通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
```c++
#include <iostream>
using namespace std;

class Fruit {
public:
	virtual void getFruit() = 0;
};
class Banana : public Fruit {
public:
	virtual void getFruit() {
		cout << "Banana" << endl;
	}
};
class Apple : public Fruit {
public:
	virtual void getFruit() {
		cout << "Apple" << endl;
	}
};
class FruitFactory {
public:
	Fruit* create(const char* p) {
		if (strcmp(p, "banana") == 0) {
			return new Banana;
		}
		else if (strcmp(p, "apple") == 0) {
			return new Apple;
		}
		else {
			cout << "error type" << endl;
		}
		return NULL;
	}
};
int main() {
	FruitFactory* f = new FruitFactory;
	Fruit* fruit = NULL;
	// 工厂生产香蕉
	fruit = f->create("banana");
	fruit->getFruit();
	delete fruit;
	// 工厂生产苹果
	fruit = f->create("apple");
	fruit->getFruit();
	delete fruit;
	delete f;
	cin.get();
	return 0;
}
```
## 工厂模式
```c++
#include <iostream>
using namespace std;

class Fruit {
public:
	virtual void sayname() = 0;
};
class Banana : public Fruit {
public:
	virtual void sayname() {
		cout << "Banana" << endl;
	}
};
class Apple : public Fruit {
public:
	virtual void sayname() {
		cout << "Apple" << endl;
	}
};
class AbstractFruitFactory {
public:
	virtual Fruit* createProduct() = 0;
};
class BananaFactory : public AbstractFruitFactory {
public:
	virtual Fruit* createProduct() {
		return new Banana;
	}
};
class AppleFactory : public AbstractFruitFactory {
public:
	virtual Fruit* createProduct() {
		return new Apple;
	}
};
int main() {
	AbstractFruitFactory* f = NULL;
	Fruit* fruit = NULL;
	f = new BananaFactory;
	fruit = f->createProduct();
	fruit->sayname();
	delete fruit;

	f = new AppleFactory;
	fruit = f->createProduct();
	fruit->sayname();
	delete fruit;
	delete f;
	cin.get();
	return 0;
}
```
## 抽象工厂模式
```c++
#include <iostream>
using namespace std;

class Fruit {
public:
	virtual void sayname() = 0;
};
class NorthBanana : public Fruit {
public:
	virtual void sayname() {
		cout << "North Banana" << endl;
	}
};
class NorthApple : public Fruit {
public:
	virtual void sayname() {
		cout << "North Apple" << endl;
	}
};
class SourthBanana : public Fruit {
public:
	virtual void sayname() {
		cout << "Sourth Banana" << endl;
	}
};
class SourthApple : public Fruit {
public:
	virtual void sayname() {
		cout << "Sourth Apple" << endl;
	}
};
class AbstractFactory {
public:
	virtual Fruit* createBanana() = 0;
	virtual Fruit* createApple() = 0;
};
class NorthFactory : public AbstractFactory {
public:
	virtual Fruit* createBanana() {
		return new NorthBanana;
	}
	virtual Fruit* createApple() {
		return new NorthApple;
	}
};
class SourthFactory : public AbstractFactory {
public:
	virtual Fruit* createBanana() {
		return new SourthBanana;
	}
	virtual Fruit* createApple() {
		return new SourthApple;
	}
};
int main() {
	AbstractFactory* f = NULL;
	Fruit* fruit = NULL;
	f = new NorthFactory;
	fruit = f->createApple();
	fruit->sayname();
	delete fruit;

	fruit = f->createBanana();
	fruit->sayname();
	delete fruit;
	delete f;

	f = new SourthFactory;
	fruit = f->createApple();
	fruit->sayname();
	delete fruit;

	fruit = f->createBanana();
	fruit->sayname();
	delete fruit;
	delete f;
	cin.get();
	return 0;
}
```
## 建造者模式
- 一个对象的构建比较复杂，将一个对象的构建和对象的表示进行分离
- Builder: 为创建产品各个部分，统一抽象接口
- ConcreteBuilder: 具体的创建产品的各个部分，部分A, 部分B, 部分C；创建该产品的内部表示并定义它的装配过程，包含定义组成部件的类，包括这些部件装配成最终产品的接口。
- Director: 构造一个使用Builder接口的对象
- Product: 表示被构造的复杂对象
```c++
#include <iostream>
using namespace std;

class House {
private:
	string door;
	string wall;
	string window;
public:
	void setDoor(string door) {
		this->door = door;
	}
	string getDoor() {
		return this->door;
	}
	void setWall(string wall) {
		this->wall = wall;
	}
	string getWall() {
		return this->wall;
	}
	void setWindow(string window) {
		this->window = window;
	}
	string getWindow() {
		return this->window;
	}
};
class Builder {
public:
	virtual void buildDoor() = 0;
	virtual void buildWall() = 0;
	virtual void buildWindow() = 0;
	virtual House* getHouse() = 0;
};
class FlatBuilder : public Builder {
public:
	FlatBuilder() {
		this->house = new House();
	}
	virtual void buildDoor() {
		this->house->setDoor("flat door");
	}
	virtual void buildWall() {
		this->house->setWall("flat wall");
	}
	virtual void buildWindow() {
		this->house->setWindow("flat window");
	}
	virtual House* getHouse() {
		return house;
	}
private:
	House* house;
};
class VillaBuilder : public Builder {
public:
	VillaBuilder() {
		this->house = new House();
	}
	virtual void buildDoor() {
		this->house->setDoor("villa door");
	}
	virtual void buildWall() {
		this->house->setWall("villa wall");
	}
	virtual void buildWindow() {
		this->house->setWindow("villa window");
	}
	virtual House* getHouse() {
		return house;
	}
private:
	House* house;
};
//设计师（指挥者）负责建造逻辑
//建筑队，干具体的活
class Director {
public:
	Director(Builder* builder) {
		this->builder = builder;
	}
	void construct() {
		builder->buildDoor();
		builder->buildWall();
		builder->buildWindow();
	}
private:
	Builder* builder;
};
int main() {
	House* house = NULL;
	Builder* builder = NULL;
	Director* director = NULL;
	//请一个建造别墅的工程队
	builder = new VillaBuilder;
	//设计师指挥工程队干活
	director = new Director(builder);
	director->construct();
	house = builder->getHouse();
	cout << house->getDoor() << endl;
	cout << house->getWall() << endl;
	cout << house->getWindow() << endl;

	//请一个建造公寓的工程队
	builder = new FlatBuilder;
	//设计师指挥工程队干活
	director = new Director(builder);
	director->construct();
	house = builder->getHouse();
	cout << house->getDoor() << endl;
	cout << house->getWall() << endl;
	cout << house->getWindow() << endl;
	delete house;
	delete builder;
	delete director;
	cin.get();
	return 0;
}
```
## 原型模式prototype
- Prototype模式提供了一个通过已存在对象进行新对象创建的接口(Clone)
- 一个复杂对象，具有自我复制功能，统一一套接口
```c++
#include <iostream>
using namespace std;

class Person {
public:
	virtual Person* clone() = 0;
	virtual void print() = 0;
	virtual void setDescription(const char*) = 0;
};
class CPlusPlusProgrammer : public Person {
public:
	CPlusPlusProgrammer() {
		this->name = "";
		this->age = 0;
		this->description = NULL;
	}
	CPlusPlusProgrammer(string name, int age) {
		this->name = name;
		this->age = age;
		this->description = NULL;
	}
	void setDescription(const char* p) {
		if (description != NULL) {
			delete description;
		}
		description = new char[strlen(p) + 1];
		strcpy(description, p);
	}
	virtual void print() {
		cout << "name: " << name << ", age: " << age << ", descriptiton: " << description << endl;
	}
	virtual Person* clone() {
		CPlusPlusProgrammer* tmp = new CPlusPlusProgrammer;
		tmp->name = name;
		tmp->age = age;
		tmp->description = new char[strlen(description) + 1];
		strcpy(tmp->description, description);
		return tmp;
	}
	~CPlusPlusProgrammer(){
		if (description != NULL) {
			delete[] description;
			description = NULL;
		}
	}
private:
	string name;
	int age;
	char* description;
};
int main() {
	Person* c1 = new CPlusPlusProgrammer("张三", 30);
	c1->setDescription("C++工程师");
	c1->print();
	Person* c2 = c1->clone();
	c2->print();
	cin.get();
	return 0;
}
```
# 结构型模式
- 让类与类进行组合，获取更大的结构
## 代理模式
```c++
#include <iostream>
using namespace std;

class Subject {
public:
	virtual void sailbook() = 0;
};
class RealSubjectBook : public Subject {
public:
	virtual void sailbook() {
		cout << "sell book" << endl;
	}
};
class DangdangProxy : public Subject {
public:
	virtual void sailbook() {
		RealSubjectBook* rsb = new RealSubjectBook;
		discount();
		rsb->sailbook();
	}
	void discount() {
		cout << "双十一优惠" << endl;
	}
private:
	Subject* subject;
};
int main() {
	Subject* subject = new DangdangProxy;
	subject->sailbook();
	delete subject;
	cin.get();
	return 0;
}
```
## 装饰模式
- 装饰者模式动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。
```c++
#include <iostream>
using namespace std;

class Car {
public:
	virtual void show() = 0;
};
class RunCar : public Car {
public:
	virtual void show() {
		cout << "run car" << endl;
	}
};
class SwimCarDecorator : public Car {
public:
	SwimCarDecorator(Car* car) {
		this->car = car;
	}
	virtual void show() {
		this->car->show();
		swim();
	}
	void swim() {
		cout << "swim car" << endl;
	}
private:
	Car* car;
};
class FlyCarDecorator : public Car {
public:
	FlyCarDecorator(Car* car) {
		this->car = car;
	}
	virtual void show() {
		this->car->show();
		fly();
	}
	void fly() {
		cout << "fly car" << endl;
	}
private:
	Car* car;
};
int main() {
	Car* car = NULL;
	car = new RunCar;
	car->show();
	cout << "-------------------------------" << endl;
	SwimCarDecorator* swimCar = new SwimCarDecorator(car);
	swimCar->show();
	cout << "-------------------------------" << endl;
	FlyCarDecorator* flyCar = new FlyCarDecorator(swimCar);
	flyCar->show();
	cout << "-------------------------------" << endl;
	cin.get();
	return 0;
}
```
## 适配器模式
- 将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
```c++
#include <iostream>
using namespace std;

class Current18v {
public:
	virtual void useCurrent18v() = 0;
};
class Current220v {
public:
	void useCurrent220v() {
		cout << "I'm 220v" << endl;
	}
};
class Adapter : public Current18v {
public:
	Adapter(Current220v* current) {
		this->current = current;
	}
	virtual void useCurrent18v() {
		cout << "Adapter adapt 220v" << endl;
		current->useCurrent220v();
	}
private:
	Current220v* current;
};
int main() {
	Current220v* current220v = NULL;
	Adapter* adapter = NULL;
	current220v = new Current220v;
	adapter = new Adapter(current220v);
	adapter->useCurrent18v();
	delete current220v;
	delete adapter;
	cin.get();
	return 0;
}
```
## 桥接模式
- Bridge模式又叫做桥接模式，是构造型的设计模式之一。Bridge模式基于类的最小设计原则，通过使用封装，聚合以及继承等行为来让不同的类承担不同的责任。它的主要特点是把抽象(abstraction)与行为实现(implementation)分离开来，从而可以保持各部分的独立性以及应对它们的功能扩展。
- Client: Birdge模式的使用者
- Abstraction: 抽象类接口（接口或抽象类）维护对行为实现(implementor)的引用
- Refined Abstraction: Abstraction子类
- Implementor: 行为实现类接口(Abstraction接口定义了基于Implementor接口的更高层次的奥做)
- ConcreteImplementor: Implementor子类
- 桥接模式是将抽象部分与实现部分分离(解耦合)，使它们都可以独立的变化
- 车安装发动机；不同型号的车安装不同型号的发动机
- 图形填充颜色：不同形状的图形，填充上不同的颜色
```c++
#include <iostream>
using namespace std;

class Engine {
public:
	virtual void installEngine() = 0;
};
class CC4400 : public Engine {
public:
	virtual void installEngine() {
		cout << "我是4400cc发动机，安装完毕" << endl;
	}
};
class CC4500 : public Engine {
public:
	virtual void installEngine() {
		cout << "我是4500cc发动机，安装完毕" << endl;
	}
};
class Car {
public:
	Car(Engine* engine) {
		this->engine = engine;
	}
	virtual void installEngine() = 0;
protected:
	Engine* engine;
};
class BMW5 : public Car {
public:
	BMW5(Engine* engine) : Car(engine) {

	}
	virtual void installEngine() {
		cout << "BMW5" << " ";
		engine->installEngine();
	}
};
class BMW6 : public Car {
public:
	BMW6(Engine* engine) : Car(engine) {

	}
	virtual void installEngine() {
		cout << "BMW6" << " ";
		engine->installEngine();
	}
};
int main() {
	Engine* engine = NULL;
	Car* car = NULL;
	engine = new CC4400();
	car = new BMW5(engine);
	car->installEngine();
	engine = new CC4500();
	car = new BMW6(engine);
	car->installEngine();
	delete car;
	delete engine;
	cin.get();
	return 0;
}
```
## 组合模式
- 通过递归手段来构造树形的对象结构，并可以通过一个对象来访问整个对象树
- 适用于单个对象和组合对象的使用具有一致性。将对象组合成树形结构以表示“部分-整体”
```c++
#include <iostream>
#include <list>
using namespace std;

class IFile {
public:
	virtual void display() = 0;
	virtual int add(IFile* file) = 0;
	virtual int remove(IFile* file) = 0;
	virtual list<IFile*>* getChild() = 0;
};
class File : public IFile {
public:
	File(string name) {
		this->name = name;
	}
	virtual void display() {
		cout << name << endl;
	}
	virtual int add(IFile* file) {
		return -1;
	}
	virtual int remove(IFile* file) {
		return -1;
	}
	virtual list<IFile*>* getChild() {
		return NULL;
	}
private:
	string name;
};
class Directory : public IFile {
public:
	Directory(string name) {
		this->name = name;
		this->files = new list<IFile*>;
		this->files->clear();
	}
	virtual void display() {
		cout << name << endl;
		list<IFile*>* files = getChild();
		for (list<IFile*>::iterator it = files->begin(); it != files->end(); it++) {
			(*it)->display();
		}
	}
	virtual int add(IFile* file) {
		files->push_back(file);
		return 0;
	}
	virtual int remove(IFile* file) {
		files->remove(file);
		return 0;
	}
	virtual list<IFile*>* getChild() {
		return files;
	}
private:
	string name;
	list<IFile*>* files;
};
int main() {
	Directory* root = new Directory("C");
	Directory* dir1 = new Directory("111dir");
	File* file1 = new File("aaa.txt");
	root->add(file1);

	Directory* dir2 = new Directory("222dir");
	dir1->add(dir2);
	File* file2 = new File("bbb.txt");
	dir1->add(file2);
	root->add(dir1);

	root->display();
	cin.get();
	return 0;
}
```
## 外观模式
- Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade
- 适用于：为子系统中统一一套接口，让子系统更加容易使用。
```c++
#include <iostream>
using namespace std;

class SubSystemA {
public:
	void doThing() {
		cout << "SubSystem A run" << endl;
	}
};
class SubSystemB {
public:
	void doThing() {
		cout << "SubSystem B run" << endl;
	}
};
class SubSystemC {
public:
	void doThing() {
		cout << "SubSystem C run" << endl;
	}
};
class Facade {
public:
	Facade() {
		a = new SubSystemA;
		b = new SubSystemB;
		c = new SubSystemC;
	}
	void doThing() {
		a->doThing();
		b->doThing();
		c->doThing();
	}
	~Facade() {
		delete a;
		delete b;
		delete c;
	}
private:
	SubSystemA* a;
	SubSystemB* b;
	SubSystemC* c;
};
int main() {
	Facade facade;
	facade.doThing();
	cin.get();
	return 0;
}
```
## 享元模式
- Flyweight, 通过与其他类似对象共享数据来减小内存占用
- 使用场景：是以共享的方式，高效的支持大量的细粒度的对象
```c++
#include <iostream>
#include <map>
using namespace std;
class People {
public:
	People(string name, int age) {
		this->name = name;
		this->age = age;
	}
	virtual void print() = 0;
protected:
	string name;
	int age;
};
class Teacher : public People {
public:
	Teacher(string name, int age, string id) : People(name, age) {
		this->id = id;
	}
	void print() {
		cout << "name: " << name << ", age: " << age << ", id: " << id << endl;
	}
private:
	string id;
};
class FlyweightTeacherFactory {
public:
	FlyweightTeacherFactory() {
		map1.clear();
	}
	~FlyweightTeacherFactory() {
		while (!map1.empty()) {
			People* tmp = NULL;
			auto it = map1.begin();
			tmp = it->second;
			map1.erase(it); //把第一个节点从容器中删除
			delete tmp;
		}
	}
	People* getTeacher(string id) {
		Teacher* t = NULL;
		auto it =  map1.find(id);
		if (it == map1.end()) {
			string name;
			int age;
			cout << "请输入老师名字:";
			cin >> name;
			cout << "请输入老师年龄:";
			cin >> age;
			t = new Teacher(name, age, id);
			map1.insert(make_pair(id, t));
			return t;
		}
		return (*it).second;
	}
private:
	map<string, People*> map1;
};
int main() {
	People* p1 = NULL;
	People* p2 = NULL;
	FlyweightTeacherFactory* ftf = new FlyweightTeacherFactory;
	p1 = ftf->getTeacher("001");
	p1->print();
	p2 = ftf->getTeacher("001");
	p2->print();
	delete ftf;
	system("pause");
	return 0;
}
```
