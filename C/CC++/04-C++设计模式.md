# 设计模式基本原则
- 最终目的：高内聚，低耦合
- 开放封闭原则：类的改动时通过增加代码进行的，而不是修改源代码
```c++
#include <iostream>
using namespace std;

class BankWorker {
public:
	void save() {
		cout << "存款" << endl;
	}
	void moveMoney() {
		cout << "转账" << endl;
	}
	void payment() {
		cout << "交费" << endl;
	}
};

class AbstractBankWorker {
public:
	virtual void dothing() = 0;
};

class SaveBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "存款" << endl;
	}
};
class MoveBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "转账" << endl;
	}
};
class PaymentBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "交费" << endl;
	}
};

void bank_test1() {
	BankWorker* bw = new BankWorker;
	bw->save();
	bw->moveMoney();
	bw->payment();
}

void bank_test2() {
	AbstractBankWorker* bw = NULL;
	bw = new SaveBanker;
	bw->dothing(); //有多态发生
	delete bw;

	bw = new MoveBanker;
	bw->dothing();
	delete bw;
}

void bank_do(AbstractBankWorker* bw) {
	bw->dothing();
}

void bank_test3() {
	AbstractBankWorker* bw = NULL;
	bw = new SaveBanker;
	bank_do(bw);
	delete bw;

	bw = new MoveBanker;
	bank_do(bw);
	delete bw;
}

int main() {
	bank_test1();
	bank_test2();
	bank_test3();
	cin.get();
	return 0;
}
```
- 单一职责原则：类的职责要单一，对外只提供一种功能，而引起类变化的原因应该只有一个
- 依赖倒置原则：依赖于抽象（接口），不要依赖具体的实现类，也就是针对接口编程
```c++
#include <iostream>
using namespace std;

class HardDisk {
public:
	virtual void work() = 0;
};
class Memory {
public:
	virtual void work() = 0;
};
class CPU {
public:
	virtual void work() = 0;
};
//让Computer框架和具体的厂商进行解耦合
class Computer {
public:
	Computer(HardDisk* hard_disk, Memory* memory, CPU* cpu) {
		this->hard_disk = hard_disk;
		this->memory = memory;
		this->cpu = cpu;
	}
	void work() {
		hard_disk->work();
		memory->work();
		cpu->work();
	}
private:
	HardDisk* hard_disk;
	Memory* memory;
	CPU* cpu;
};
class IntelCPU : public CPU {
public:
	void work() {
		cout << "Intel CPU work" << endl;
	}
};
class WestDataHardDisk : public HardDisk {
public:
	void work() {
		cout << "West Data Hard Disk work" << endl;
	}
};
class JinShiDunMemory : public Memory {
public:
	void work() {
		cout << "JinShiDun Memory work" << endl;
	}
};

int main() {
	HardDisk* hard_disk = NULL;
	Memory* memory = NULL;
	CPU* cpu = NULL;
	
	hard_disk = new WestDataHardDisk;
	memory = new JinShiDunMemory;
	cpu = new IntelCPU;
	Computer* computer = new Computer(hard_disk, memory, cpu);
	computer->work();
	delete computer;
	delete cpu;
	delete memory;
	delete hard_disk;
	cin.get();
	return 0;
}
```
- 接口隔离原则：不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。
- 里氏替换原则：任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能
- 优先使用组合而不是继承原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果实现对象组合，就降低了这种依赖关系
- 迪米特法则：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）