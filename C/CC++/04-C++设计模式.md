# 设计模式基本原则
- 最终目的：高内聚，低耦合
- 开放封闭原则：类的改动时通过增加代码进行的，而不是修改源代码
```c++
#include <iostream>
using namespace std;

class BankWorker {
public:
	void save() {
		cout << "存款" << endl;
	}
	void moveMoney() {
		cout << "转账" << endl;
	}
	void payment() {
		cout << "交费" << endl;
	}
};

class AbstractBankWorker {
public:
	virtual void dothing() = 0;
};

class SaveBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "存款" << endl;
	}
};
class MoveBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "转账" << endl;
	}
};
class PaymentBanker : public AbstractBankWorker {
public:
	virtual void dothing() {
		cout << "交费" << endl;
	}
};

void bank_test1() {
	BankWorker* bw = new BankWorker;
	bw->save();
	bw->moveMoney();
	bw->payment();
}

void bank_test2() {
	AbstractBankWorker* bw = NULL;
	bw = new SaveBanker;
	bw->dothing(); //有多态发生
	delete bw;

	bw = new MoveBanker;
	bw->dothing();
	delete bw;
}

void bank_do(AbstractBankWorker* bw) {
	bw->dothing();
}

void bank_test3() {
	AbstractBankWorker* bw = NULL;
	bw = new SaveBanker;
	bank_do(bw);
	delete bw;

	bw = new MoveBanker;
	bank_do(bw);
	delete bw;
}

int main() {
	bank_test1();
	bank_test2();
	bank_test3();
	cin.get();
	return 0;
}
```
- 单一职责原则：类的职责要单一，对外只提供一种功能，而引起类变化的原因应该只有一个
- 依赖倒置原则：依赖于抽象（接口），不要依赖具体的实现类，也就是针对接口编程
```c++
#include <iostream>
using namespace std;

class HardDisk {
public:
	virtual void work() = 0;
};
class Memory {
public:
	virtual void work() = 0;
};
class CPU {
public:
	virtual void work() = 0;
};
//让Computer框架和具体的厂商进行解耦合
class Computer {
public:
	Computer(HardDisk* hard_disk, Memory* memory, CPU* cpu) {
		this->hard_disk = hard_disk;
		this->memory = memory;
		this->cpu = cpu;
	}
	void work() {
		hard_disk->work();
		memory->work();
		cpu->work();
	}
private:
	HardDisk* hard_disk;
	Memory* memory;
	CPU* cpu;
};
class IntelCPU : public CPU {
public:
	void work() {
		cout << "Intel CPU work" << endl;
	}
};
class WestDataHardDisk : public HardDisk {
public:
	void work() {
		cout << "West Data Hard Disk work" << endl;
	}
};
class JinShiDunMemory : public Memory {
public:
	void work() {
		cout << "JinShiDun Memory work" << endl;
	}
};

int main() {
	HardDisk* hard_disk = NULL;
	Memory* memory = NULL;
	CPU* cpu = NULL;
	
	hard_disk = new WestDataHardDisk;
	memory = new JinShiDunMemory;
	cpu = new IntelCPU;
	Computer* computer = new Computer(hard_disk, memory, cpu);
	computer->work();
	delete computer;
	delete cpu;
	delete memory;
	delete hard_disk;
	cin.get();
	return 0;
}
```
- 接口隔离原则：不应该强迫客户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。
- 里氏替换原则：任何抽象类出现的地方都可以用他的实现类进行替换。实际就是虚拟机制，语言级别实现面向对象功能
- 优先使用组合而不是继承原则：如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果实现对象组合，就降低了这种依赖关系
- 迪米特法则：一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）
# 创建型模式
## 单例模式
### 定义
- 保证一个类，只有一个实例的存在，同时提供能对该实例加以访问的全局访问方法
### 为什么使用单例模式
- 在多个线程之间，比如初始化一次socket资源，比如servlet环境，共享同一个资源或者操作同一个对象
- 在整个程序空间使用全局变量，共享资源
- 大规模系统中，为了性能的考虑，需要节省对象的创建时间等等
### 实现单例模式常用步骤
- 构造函数私有化
- 提供一个全局的静态方法（全局访问点）
- 在类中定义一个静态指针，指向本类的变量的静态变量指针
### 懒汉式
```c++
#include <iostream>
using namespace std;

//懒汉式单例
class Singleton {
private:
	static Singleton* singleton;
	Singleton() {
		cout << "Singleton Constructor" << endl;
	}
public:
	static Singleton* getInstance() {
		if (singleton == NULL) {
			singleton = new Singleton;
		}
		return singleton;
	}
	static void freeInstance() {
		if (singleton != NULL) {
			delete singleton;
			singleton = NULL;
		}
	}
};
Singleton* Singleton::singleton = NULL;

int main() {
	Singleton* p1 = Singleton::getInstance();
	Singleton* p2 = Singleton::getInstance();
	if (p1 == p2) {
		cout << "p1,p2是同一个对象" << endl;
	}
	else {
		cout << "p1,p2不是同一个对象" << endl;
	}
	Singleton::freeInstance();
	cin.get();
	return 0;
}
```
### 饿汉式
```c++
#include <iostream>
using namespace std;

//饿汉式单例
class Singleton {
private:
	static Singleton* singleton;
	Singleton() {
		cout << "Singleton Constructor" << endl;
	}
public:
	static Singleton* getInstance() {
		return singleton;
	}
	static void freeInstance() {
		if (singleton != NULL) {
			delete singleton;
			singleton = NULL;
		}
	}
};
Singleton* Singleton::singleton = new Singleton;

int main() {
	Singleton* p1 = Singleton::getInstance();
	Singleton* p2 = Singleton::getInstance();
	if (p1 == p2) {
		cout << "p1,p2是同一个对象" << endl;
	}
	else {
		cout << "p1,p2不是同一个对象" << endl;
	}
	Singleton::freeInstance();
	cin.get();
	return 0;
}
```
### 懒汉式多线程安全
```c++
#include <iostream>
#include <thread>
#include <mutex>

using namespace std;

mutex global_lock;
//懒汉式单例
class Singleton0 {
private:
	static Singleton0* singleton;
	Singleton0() {
		count++;
		cout << "Singleton0 Constructor" << endl;
	}
public:
	static int count;
	static Singleton0* getInstance() {
		global_lock.lock();
		if (singleton == NULL) {
			singleton = new Singleton0;
		}
		global_lock.unlock();
		return singleton;
	}
	static void freeInstance() {
		if (singleton != NULL) {
			delete singleton;
			singleton = NULL;
		}
	}
};
Singleton0* Singleton0::singleton = NULL;
int Singleton0::count = 0;

int main() {
	thread t1(Singleton0::getInstance);
	thread t2(Singleton0::getInstance);
	thread t3(Singleton0::getInstance);
	t1.join();
	t2.join();
	t3.join();
	cout << Singleton0::count << endl;
	Singleton0::freeInstance();
	cin.get();
	return 0;
}
```
## 简单工厂模式
- 简单工厂模式属于类的创建型模式，又叫做静态工厂方法模式，通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类
```c++
#include <iostream>
using namespace std;

class Fruit {
public:
	virtual void getFruit() = 0;
};
class Banana : public Fruit {
public:
	virtual void getFruit() {
		cout << "Banana" << endl;
	}
};
class Apple : public Fruit {
public:
	virtual void getFruit() {
		cout << "Apple" << endl;
	}
};
class FruitFactory {
public:
	Fruit* create(const char* p) {
		if (strcmp(p, "banana") == 0) {
			return new Banana;
		}
		else if (strcmp(p, "apple") == 0) {
			return new Apple;
		}
		else {
			cout << "error type" << endl;
		}
		return NULL;
	}
};
int main() {
	FruitFactory* f = new FruitFactory;
	Fruit* fruit = NULL;
	// 工厂生产香蕉
	fruit = f->create("banana");
	fruit->getFruit();
	delete fruit;
	// 工厂生产苹果
	fruit = f->create("apple");
	fruit->getFruit();
	delete fruit;
	delete f;
	cin.get();
	return 0;
}
```
## 工厂模式
```c++
#include <iostream>
using namespace std;

class Fruit {
public:
	virtual void sayname() = 0;
};
class Banana : public Fruit {
public:
	virtual void sayname() {
		cout << "Banana" << endl;
	}
};
class Apple : public Fruit {
public:
	virtual void sayname() {
		cout << "Apple" << endl;
	}
};
class AbstractFruitFactory {
public:
	virtual Fruit* createProduct() = 0;
};
class BananaFactory : public AbstractFruitFactory {
public:
	virtual Fruit* createProduct() {
		return new Banana;
	}
};
class AppleFactory : public AbstractFruitFactory {
public:
	virtual Fruit* createProduct() {
		return new Apple;
	}
};
int main() {
	AbstractFruitFactory* f = NULL;
	Fruit* fruit = NULL;
	f = new BananaFactory;
	fruit = f->createProduct();
	fruit->sayname();
	delete fruit;

	f = new AppleFactory;
	fruit = f->createProduct();
	fruit->sayname();
	delete fruit;
	delete f;
	cin.get();
	return 0;
}
```
## 抽象工厂模式
```c++
#include <iostream>
using namespace std;

class Fruit {
public:
	virtual void sayname() = 0;
};
class NorthBanana : public Fruit {
public:
	virtual void sayname() {
		cout << "North Banana" << endl;
	}
};
class NorthApple : public Fruit {
public:
	virtual void sayname() {
		cout << "North Apple" << endl;
	}
};
class SourthBanana : public Fruit {
public:
	virtual void sayname() {
		cout << "Sourth Banana" << endl;
	}
};
class SourthApple : public Fruit {
public:
	virtual void sayname() {
		cout << "Sourth Apple" << endl;
	}
};
class AbstractFactory {
public:
	virtual Fruit* createBanana() = 0;
	virtual Fruit* createApple() = 0;
};
class NorthFactory : public AbstractFactory {
public:
	virtual Fruit* createBanana() {
		return new NorthBanana;
	}
	virtual Fruit* createApple() {
		return new NorthApple;
	}
};
class SourthFactory : public AbstractFactory {
public:
	virtual Fruit* createBanana() {
		return new SourthBanana;
	}
	virtual Fruit* createApple() {
		return new SourthApple;
	}
};
int main() {
	AbstractFactory* f = NULL;
	Fruit* fruit = NULL;
	f = new NorthFactory;
	fruit = f->createApple();
	fruit->sayname();
	delete fruit;

	fruit = f->createBanana();
	fruit->sayname();
	delete fruit;
	delete f;

	f = new SourthFactory;
	fruit = f->createApple();
	fruit->sayname();
	delete fruit;

	fruit = f->createBanana();
	fruit->sayname();
	delete fruit;
	delete f;
	cin.get();
	return 0;
}
```