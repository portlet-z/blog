## 处理字符问题

### 字符

- 汇编程序中，用'......'的方式指明数据是以字符的形式给出的，编译器将把它们转化成相应的ASCII码

```assembly
assume cs:code, ds:data
data segment
	db 'unIX'
	db 'foRK'
data ends
code segment
start: mov al, 'a'
			 mov bl, 'b'
			 mov ax, 4C00H
			 int 21H
code ends
end start
```

### 大小写转换

| 大写 | 二进制   | 小写 | 二进制   |
| ---- | -------- | ---- | -------- |
| A    | 01000001 | a    | 01100001 |
| B    | 01000010 | b    | 01100010 |
| C    | 01000011 | c    | 01100011 |
| D    | 01000100 | d    | 01100100 |

- 大写+20H --> 小写； 小写-20H --> 大写
- 要求：对第一个字符串转大写，对第二个字符串转小写
- 逻辑与指令： and dest, src
- 逻辑或指令：or dest, src

```assembly
assume cs:code, ds:data
data segment
	db 'unIX'
	db 'foRK'
data ends
code segment
start: mov ax, data
	     mov ds, ax
	     ; 小写转大写
	     mov bx, 0
	     mov cx, 4
	  s: mov al, [bx]
	  	 and al, 11011111B
	  	 mov [bx], al
	  	 inc bx
	  	 loop s
	  	 
	  	 ; 大写转小写
	     mov bx, 4
	 	   mov cx, 4
	 s0: mov al, [bx]
	 	   or al, 00100000B
	 	   mov [bx], al
	 	   inc bx
	 	   loop s0

			 mov ax, 4C00H
			 int 21H
code ends
end start
```

## [bx+idata]方式寻址

### [bx+idata]的含义

- [bx_idata]表示一个内存单元，它的偏移地址为(bx) + idata (bx中的数值加上idata)
- mov ax, [bx + 200]    mov ax, [200 + bx]的含义
  - 将一个内存单元的内容送入ax
  - 这个内存单元的长度为2字节（字单元），存放一个字
  - 内存单元的段地址再ds中，偏移地址为200加上bx中的数值
  - 数学化的描述为：(ax) = ((ds) * 16 + 200 + (bx))
- 指令mov ax, [bx + 200]的其他写法
  - mov ax, [200 + bx]
  - mov ax, 200[bx]
  - mov ax, [bx].200

### 应用：用[bx+idata]的方式进行数组的处理

- 大小写转换

```assembly
assume cs:code, ds:data
data segment
	db 'unIX'
	db 'foRK'
data ends
code segment
start: mov ax, data
			 mov ds, ax
			 mov bx, 0
			 mov cx, 4
		s: mov al, [bx]
			 and al, 11011111B
			 mov [bx], al
			 mov al, [bx+4]
			 or al, 00100000B
			 mov [bx+4], al
			 inc bx
			 loop s
			 
			 mov ax, 4C00H
			 int 21H
code ends
end
```

- [bx+idata]的方式为高级语言实现数组提供了便利机制

```c
char a[4] = 'unIX';
char b[4] = 'foRK';
int main() {
  int i = 0;
  do {
    a[i] = a[i] & 0xDF;
    b[i] = b[i] | 0x20;
    i++;
  } while (i < 4);
}
```

## SI和DI寄存器

### SI和DI常执行与地址有关的操作

- SI和DI是8086CPU中和BX功能相近的寄存器
  - 区别：SI和DI不能够分成两个8位寄存器来使用
  - BX: 通用寄存器，在计算存储器地址时，常作为基址寄存器用
  - SI: source index, 源变址寄存器
  - DI: destination index, 目标变址寄存器
- 下面三组指令实现了相同的功能

```assembly
mov bx, 0
mov ax, [bx]

mov si, 0
mov ax, [si]

mov di, 0
mov ax, [di]
```

```assembly
mov bx, 0
mov ax, [bx+123]

mov si, 0
mov ax, [si+123]

mov di, 0
mov ax, [di+123]
```

### 应用SI和DI

- 问题：用寄存器SI和DI实现字符串'welcome to masm!'复制到它后面的数据区中
- 解决方案：
  - 源数据起始地址：datasg: 0
  - 目标数据起始地址：datasg: 16
  - 用ds:si指向要复制的原始字符串
  - 用ds:di指向目的空间
  - 然后用一个循环来完成复制

```assembly
assume cs:codesg, ds:datasg
datasg segment
	db 'welcome to masm!'
	db '................'
datasg ends
codesg segment
start: mov ax, datasg
			 mov ds, ax
			 mov si, 0
			 mov di, 16
			 mov cx, 8
		s: mov ax, [si]
		   mov [di], ax
		   add si, 2
		   add di, 2
		   loop s
			 
			 mov ax, 4C00H
			 int 21H
codesg ends
end start
```

## [bx+si]和[bx+di]方式寻址

### [bx+si]和[bx+di]方式指定地址

- [bx+si]表示一个内存单元：偏移地址为(bx) + (si) (即bx中的数值加上si中的数值)
- 指令mov ax, [bx+si]的含义
  - 将一个内存单元的内容送入ax
  - 这个内存单元的长度为2字节（字单元），存放一个字
  - 偏移地址为bx中的数值加上si中的数值
  - 段地址再ds中
- 指令mov ax, [bx+si]的数学化的描述为 (ax) = ((ds) * 16 + (bx) + (si))
- mov ax, [bx+si]的其他写法：`mov ax, [bx][si]`

### 应用案例

- 内存中数据 2000:1000 BE 00 06 00 00 00
- 分析程序执行后，ax, bx, cx中的内容

```assembly
mov ax, 2000H    ;1
mov ds, ax       ;2
mov bx, 1000H    ;3
mov si, 0        ;4
mov ax, [bx+si]  ;5
inc si           ;6
mov cx, [bx+si]  ;7
inc si           ;8
mov di, si       ;9
mov ax, [bx+di]  ;10
```

- 执行1,2,3,4行代码后

| ax    | bx    | cx   | ds    | si   | di   |
| ----- | ----- | ---- | ----- | ---- | ---- |
| 2000H | 1000H |      | 2000H | 0    |      |

- 执行5，6行代码后

| ax    | bx    | cx   | ds    | si   | di   |
| ----- | ----- | ---- | ----- | ---- | ---- |
| 00BEH | 1000H |      | 2000H | 1    |      |

- 执行7，8行代码后

| ax    | bx    | cx    | ds    | si   | di   |
| ----- | ----- | ----- | ----- | ---- | ---- |
| 00BEH | 1000H | 0600H | 2000H | 2    |      |

- 执行9，10行代码后

| ax    | bx    | cx    | ds    | si   | di   |
| ----- | ----- | ----- | ----- | ---- | ---- |
| 0006H | 1000H | 0600H | 2000H | 2    | 2    |

## [bx+si+idata]和[bx+di+idata]方式寻址

### [bx+si+idata]和[bx+di+idata]方式指定地址

- [bx+si+idata]表示一个内存单元：偏移地址为(bx) + (si) + idata,即bx中的数值加上si中数值再加上idata
- 指令mov ax, [bx+si+idata]的含义
  - 将一个内存单元的内容送入ax
  - 这个内存单元的长度为2字节（字单元），存放一个字
  - 偏移地址为bx中的数值加上si中的数值再加上idata, 段地址在ds中
- 数学化的描述为(ax) = ((ds) * 16 + (bx) + (si) + idata)
- 指令mov ax, [bx+si+idata]的其他写法
  - `mov ax,  [bx+200+si]`
  - `mov ax, [200+bx+si]`
  - `mov ax, 200[bx][si]`
  - `mov ax, [bx].200[si]`
  - `mov ax, [bx][si].200`

### 应用案例

- 内存中数据 2000:1000 BE 00 06 00 6A 22
- 分析程序执行后，ax, bx, cx中的内容

```assembly
mov ax, 2000H      ;1
mov ds, ax         ;2
mov bx, 1000H      ;3
mov si, 0          ;4
mov ax, [bx+si+2]  ;5
inc si             ;6
mov cx, [bx+si+2]  ;7
inc si             ;8
mov di, si         ;9
mov ax, [bx+di+2]  ;10
```

- 执行1,2,3,4行代码后

| ax    | bx    | cx   | ds    | si   | di   |
| ----- | ----- | ---- | ----- | ---- | ---- |
| 2000H | 1000H |      | 2000H | 0    |      |

- 执行5，6行代码后

| ax    | bx    | cx   | ds    | si   | di   |
| ----- | ----- | ---- | ----- | ---- | ---- |
| 0006H | 1000H |      | 2000H | 1    |      |

- 执行7，8行代码后

| ax    | bx    | cx    | ds    | si   | di   |
| ----- | ----- | ----- | ----- | ---- | ---- |
| 0006H | 1000H | 6A00H | 2000H | 2    |      |

- 执行9，10行代码后

| ax    | bx    | cx    | ds    | si   | di   |
| ----- | ----- | ----- | ----- | ---- | ---- |
| 226AH | 1000H | 0600H | 2000H | 2    | 2    |

## 不同的寻址方式的灵活应用

### 对内存的寻址方式

| 形式          | 名称             | 特点                         | 意义                                               | 示例                            |
| ------------- | ---------------- | ---------------------------- | -------------------------------------------------- | ------------------------------- |
| [idata]       | 直接寻址         | 用一个常量、立即数来表示地址 | 用于直接定位一个内存单元                           | mov ax, [200]                   |
| [bx]          | 寄存器间接寻址   | 用一个变量来表示内存地址     | 用于间接定位一个内存单元                           | mov bx, 0<br />mov ax, [bx]     |
| [bx+idata]    | 寄存器相对寻址   | 用一个变量和常量表示地址     | 可在一个起始地址的基础上用变量间接定位一个内存单元 | mov bx, 4<br />mov ax, [bx+200] |
| [bx+si]       | 基址变址寻址     | 用两个变量表示地址           |                                                    | mov ax, [bx+si]                 |
| [bx+si+idata] | 相对基址变址寻址 | 用两个变量和一个常量表示地址 |                                                    | mov ax, [bx+si+200]             |

### 案例一

- 编程将datasg段中每个单词的头一个字母改为大写字母

```assembly
assume: cs:codesg, ds:datasg
datasg segment
	db '1. file         '
	db '2. edit         '
	db '3. search       '
	db '4. view         '
	db '5. options      '
	db '6. help         '
datasg ends
codesg segment
start: mov ax, datasg
			 mov ds, ax
			 mov bx, 0
			 mov cx, 6
		s: mov al, [bx+3]
		   and al, 11011111B
		   mov [bx+3], al
		   add bx, 16
		   loop s

			 mov ax, 4C00H
			 int 21H
codesg ends
end start
```

### 案例二

- 编程将datasg段中每个单词改为大写字母

- 4个字符串，看成一个4行16列的二维数组
- 要修改二维数组的每一行的前3列
- 构造4*3的二重循环

```assembly
assume cs:codesg, ds:datasg
datasg segment
	db 'ibm             '
	db 'dec             '
	db 'dos             '
	db 'vax             '
datasg ends
codesg segment
start: mov ax, datasg
	     mov ds, ax
	     mov bx, 0
	     mov cx, 4  ;循环次数
	 s0: mov si, 0
	 	   mov cx, 3  ;循环次数由cx定，可是cx只有一个。代码有bug
	 	s: mov al, [bx+si]
	 	   and al, 11011111B
	 	   mov [bx+si], al
	 	   inc si
	 	   loop s
	 	   add bx, 16
	 	   loop s0
			 
			 mov ax, 4C00H
			 int 21H
codesg ends
end start
```

- 方法一：用dx保存外存循环次数

```assembly
codesg segment
start: mov ax, datasg
	     mov ds, ax
	     mov bx, 0
	     mov cx, 4
	 s0: mov dx, cx ; 将外层循环的cx值保存在dx中
	     mov si, 0
	     mov cx, 3
	  s: mov al, [bx+si]
	     and al, 11011111B
	     mov [bx+si], al
	     inc si
	     loop s
	     add bx, 16
	     mov cx, dx ; 用dx中存放的外层循环的计数值恢复cx
	     loop s0    ; (cx) = (cx) - 1针对外层循环
codesg ends
end start
```

- 方法二：用固定的内存空间保存数据

```assembly
codesg segment
start: mov ax, datasg
	     mov ds, ax
	     mov bx, 0
	     mov cx, 4
	 s0: mov ds:[40H], cx ; 将外层循环的cx值保存在ds:[40H]中
	     mov si, 0
	     mov cx, 3
	  s: mov al, [bx+si]
	     and al, 11011111B
	     mov [bx+si], al
	     inc si
	     loop s
	     add bx, 16
	     mov cx, ds:[40H] ; 用ds:[40H]中存放的外层循环的计数值恢复cx
	     loop s0    ; (cx) = (cx) - 1针对外层循环
codesg ends
end start
```

- 方法三：用栈保存数据

```assembly
assume cs:codesg, ds:datasg, ss:stacksg
datasg segment
	db 'ibm             '
	db 'dec             '
	db 'dos             '
	db 'vax             '
datasg ends
stacksg segment
	dw 0,0,0,0,0,0,0,0
stacksg ends
codesg segment
start: mov ax, stacksg
			 mov ss, ax
			 mov sp 16
       mov ax, datasg
	     mov ds, ax
	     mov bx, 0
	     mov cx, 4  ;循环次数
	 s0: push cx    ;将外层循环的cx值压栈
	     mov si, 0
	 	   mov cx, 3  ;cx设置为内存循环的次数
	 	s: mov al, [bx+si]
	 	   and al, 11011111B
	 	   mov [bx+si], al
	 	   inc si
	 	   loop s
	 	   add bx, 16
	 	   pop cx ;从栈顶弹出原cx的值，恢复cx
	 	   loop s0
			 
			 mov ax, 4C00H
			 int 21H
codesg ends
end start
```

## 不同寻址方式总结

| 寻址方式                                                     | 含义                                                         | 名称             | 常用格式举例                                                 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- | ------------------------------------------------------------ |
| [idata]                                                      | EA=idata; SA=(ds)                                            | 直接寻址         | [idata]                                                      |
| [bx]<br />[si]<br />[di]<br />[bp]                           | EA=(bx); SA=(ds)<br />EA=(si); SA=(ds)<br />EA=(di); SA=(ds)<br />EA=(bp); SA=(ss) | 寄存器间接寻址   | [bx]                                                         |
| [bx+idata]<br />[si+idata]<br />[di+idata]<br />[bp+idata]   | EA=(bx)+idata; SA=(ds)<br />EA=(si)+idata; SA=(ds)<br />EA=(di)+idata; SA=(ds)<br />EA=(bp)+idata; SA=(ss) | 寄存器相对寻址   | 常用于结构体: bx.idata<br />用于数组: idata[si], idata[di]<br />用于二维数组: `[bx][idata]` |
| [bx+si]<br />[bx+di]<br />[bp+si]<br />[bp+di]               | EA=(bx)+(si); SA=(ds)<br />EA=(bx)+(di); SA=(ds)<br />EA=(bp)+(si); SA=(ss)<br />EA=(bp)+(di); SA=(ss) | 基址变址寻址     | 用于二维数组: `[bx][si]`                                     |
| [bx+si+idata]<br />[bx+di+idata]<br />[bp+si+idata]<br />[bp+di+idata] | EA=(bx)+(si)+idata; SA=(ds)<br />EA=(bx)+(di)+idata; SA=(ds)<br />EA=(bp)+(si)+idata; SA=(ss)<br />EA=(bp)+(di)+idata; SA=(ss) | 相对基址变址寻址 | 用于表格（结构体）中的数组项，[bx].idata[si]<br />用于二维数组：`idata[bx][si]` |

## 用于内存寻址的寄存器

- 只有bx, bp, si, di可以用在[...]对内存单元寻址

```assembly
mov ax, [bx]
mov ax, [bx+si]
mov ax, [bx+di]
mov ax, [bp]
mov ax, [bp+si]
mov ax, [bp+di]
```

- bx以外的通用寄存器，段寄存器不可以用在[...]中

```assembly
; 以下指令都是错误的
mov ax, [cx]
mov ax, [ax]
mov ax, [dx]
mov ax, [ds]
```

- bx, bp的区别：
  - bx默认指ds段
  - bp默认指ss段

```assembly
mov ax, [bp]           ; (ax) = ((ss) * 16 + (bp))
mov ax, ds:[bp]        ; (ax) = ((ds) * 16 + (bp))
mov ax, es:[bp]        ; (ax) = ((es) * 16 + (bp))
mov ax, [bx]           ; (ax) = ((ds) * 16 + (bx))
mov ax, ss:[bx]        ; (ax) = ((ss) * 16 + (bx))
mov ax, [bp+idata]     ; (ax) = ((ss) * 16 + (bp) + idata)
mov ax, [bp+si]        ; (ax) = ((ss) * 16 + (bp) + (si))
mov ax, [bp+si+idata]  ; (ax) = ((ss) * 16 + (bp) + (si) + idata)
; 下面的指令都是是错误
mov ax, [bx+bp] ;error
mov ax, [si+di] ;error
```

## 在哪里？有多长？

### 两个基本问题

- 处理的数据在什么地方
- 要处理的数据有多长

### 汇编语言中数据位置的表达

- 立即数
- 寄存器
- 内存：段地址(SA)和偏移地址(EA)

### 指令要处理的数据有多长



## 寻址方式的总和应用

## 用div指令实现除法

## 用dup设置内存空间

