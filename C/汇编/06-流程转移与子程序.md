## "转移"综述

- 背景：一般情况下指令是顺序逐条执行的，而在实际中，常需要改变程序的执行流程
- 转移指令
  - 可以控制CPU执行内存中某处代码的指令
  - 可以修改IP，或同时修改CS和IP的指令
- 转移指令的分类
  - 按转移行为
    - 段内转移：只修改IP,如jmp ax
    - 段间转移：同时修改CS和IP, 如jmp 1000:0
  - 根据指令对IP修改的范围不同
    - 段内短转移：IP修改范围为-128 - 127
    - 段内近转移：IP修改范围为-32768 - 32767
  - 按转移指令
    - 无条件转移指令 jmp
    - 条件转移指令 jcxz
    - 循环指令 loop
    - 过程
    - 中断

## 操作符offset

- 用操作符offset取得标号的偏移地址
- 格式： offset 标号

```assembly
assume cs:codesg
codesg segment
start: mov ax, offset start    ; 想当于mov ax, 0
	  s: mov ax, offset s        ; 想当于mov ax, 3
codesg ends
end start
```

- 问题：有如下程序段，填写两条指令，使该程序在运行中将s处的一条指令复制到s0处

```assembly
assume cs:codesg
codesg segment
s: mov ax, bx
	 mov si, offset s
	 mov di, offset s0
	 mov ax, cs:[si]
	 mov cs:[di], ax
s0:nop ; nop的机器码占一个字节，起占位作用
	 nop 
codesg ends
end
```

- 分析
  - s和s0处的指令所在的内存单元的地址是多少？cs:offset s 和 cs:offset s0
  - 将s处的指令复制到s0处，就是将cs:offset s处的数据复制到cs:offset s0处
  - 地址如何表示？段地址已知在cs中，偏移地址已经送入si和di中
  - 要复制的数据有多长？mov ax, bx指令的长度为两个字节，即1个字

## jmp指令

### 无条件转移

- jmp指令的功能：无条件转移，可以只修改IP也可以同时修改CS和IP
- jmp指令要给出两种信息：
  - 转移的目的地址
  - 转移的距离
    - 段间转移（远转移）：jmp 2000:1000
    - 段内短转移：jmp short 标号; IP的修改范围为-128 - 127, 8位的位移
    - 段内近转移：jmp near ptr 标号； IP的修改范围为-32768 - 32767, 16位的位移

### 根据位移进行转移

- 常见指令中的立即数均在机器指令中有体现
- 问题：jmp short指令中，转移到了哪里？jmp short的机器指令中，包含的是跳转到指令的相对位置，而不是转移的目标地址

```assembly
assume cs:codesg
codesg segment
start: mov ax, 0
		   jmp short s
		   add ax, 1
		   nop
		   nop
		s: inc ax
codesg ends
end start
```

![](./images/根据位移进行转移.jpg)

- (IP)=0003, CS:IP指向EB05(jmp的机器码)
- 读取指令码EB05进入指令缓冲区
- (IP)=(IP)+所读取指令的长度=(IP)+2=0005, CS:IP指向add ax, 0001
- CPU执行指令缓冲区中的指令EB05
- 指令EB05执行后，(IP)=(IP)+05=000AH, CS:IP指向inc ax

### 两种段内转移

- 短转移：jmp short 标号

  - 功能：(IP) = (IP) + 8位位移
  - 8位位移 = 标号处的地址 - jmp指令后第一个字节的地址
  - short指明此处的位移为8位位移
  - 8位位移的范围为-128 - 127，用补码表示
  - 8位位移由编译程序在编译时算出

  ```assembly
  assume cs:codesg
  codesg segment
  start: jmp short s
  			 db 128 dup (0)
  		s: mov ax, 0ffffh
  codesg ends
  end start
  ```

  - 编译出错：jump out of range by 1byte, 转移位移超界

- 近转移：jmp near ptr标号

  - 功能：(IP) = (IP) + 16位位移
  - 16位位移=标号处的地址 - jmp指令后的第一个字节的地址
  - near ptr指明此处的位移为16位位移，进行的是段内近转移
  - 16位位移的范围为-32768 - 32767，用补码表示
  - 16位位移由编译程序在编译时算出

  ```assembly
  assume cs:codesg
  codesg segment
  start: mov ax, 0
  			 mov bx, 0
  			 jmp near ptr s
  			 db 256 dup (0)
  		s: add ax, 1
  		   inc ax
  codesg ends
  end start
  ```

### 远转移：jmp far ptr 标号

- 段间转移：far ptr 指明了跳转的目的地址，即包含了标号的段地址CS和偏移地址IP

```assembly
assume cs:codesg
codesg segment
start: mov ax, 0
	     mov bx, 0
	     jmp far ptr s
	  	 db 256 dup (0)
	  s: add ax, 1
	     inc ax
codesg ends
end start
```

### 转移地址在寄存器中的jmp指令

- 指令格式： jmp 16位寄存器
- 功能： IP = (16位寄存器)
- jmp ax    jmp bx

```assembly
assume cs:codesg
codesg segment
start: mov ax, 0
 			 mov bx, ax
 			 jmp bx
 			 mov ax, 0123H
codesg ends
end start
```

### 转移地址在内存中的jmp指令

- jmp word ptr 内存单元地址

  - 段内转移
  - 功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址

  ```assembly
  mov ax, 0123H
  mov ds:[0], ax
  jmp word ptr ds:[0]
  ; 执行后 (IP)=0123H
  
  mov ax, 0123H
  mov [bx], ax
  jmp word ptr [bx]
  ; 执行后 (IP)=0123H
  ```

- jmp dword ptr 内存单元地址

  - 段间转移
  - 功能：从内存单元地址处开始存放着两个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址
  - 00 (IP), 02 (CS)

  ```assembly
  mov ax, 0123H
  mov ds:[0], ax
  mov word ptr ds:[2], 0
  jmp dword ptr ds:[0]
  ; 执行后(CS)=0, (IP)=0123H; CS:IP指向0000:0123
  
  mov ax, 0123H
  mov [bx], ax
  mov word ptr [bx+2], 0
  jmp dword ptr [bx]
  ; 执行后(CS)=0, (IP)=0123H, CS:IP指向0000:0123
  ```

### jmp指令小结

- jmp 标号
  - 段间转移（远转移）： jmp far ptr 标号
  - 段内短转移： jmp short 标号， 8位的位移
  - 段内近转移： jmp near ptr 标号， 16位的位移
- jmp 寄存器
  - jmp bx; 16位的位移
- jmp 内存单元（表示跳转的地址）
  - 段内转移： jmp word ptr 内存单元地址; jmp word ptr [bx]
  - 段间转移： jmp dword ptr 内存单元地址; jmp dword ptr [bx]

> 在源程序中，不允许使用 jmp 2000:1000 的转移指令实现段间转移
>
> - 这是在debug中使用的汇编指令，汇编编译器并不认识
> - 如果在源程序中使用，编译时也会报错

## 其他转移指令

### jcxz指令

- 指令格式： jcxz 标号
- 功能：如果(cx)=0, 则转移到标号处执行，当(cx)!=0时，什么也不做（程序向下执行）
  - 当(cx)=0时，(IP)=(IP)+8位位移
  - 8位位移 = 标号处的地址 - jcxz指令后的第一个字节的地址
  - 8位位移的范围为-128 ~ 127，用补码表示
  - 8位位移由编译器程序在编译时算出
- jcxz是有条件转移指令
  - 所有的有条件转移指令都是短转移
  - 对IP的修改范围都为-128 ~ 127
  - 在对应的机器码中包含转移的位移，而不是目的地址

```assembly
assume cs:codesg
codesg segment
start:
    mov ax, 2000H
    mov ds, ax
    mov bx, 0
 s: mov cx, [bx]
 	  jcxz ok
 	  inc bx
 	  inc bx
 	  jmp short s
ok: mov dx, bx
    mov ax, 4C00H
    int 21H
codesg ends
end start
```

### loop指令

- 指令格式： loop 标号
- 指令操作
  - (cx) = (cx) - 1
  - 当(cx)!=0时，则转移到标号处执行；当(cx)=0时，程序向下执行
- 如果(cx)!=0, （IP)=(IP)+8位位移
  - 8位位移=标号处的地址 - loop指令后的第一个字节的地址
  - 8位位移的范围为-128 ~ 127，用补码表示
  - 8位位移由编译程序在编译时算出

### 根据位移进行相对转移的意义

- 对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行
  - jmp short 标号
  - jmp near ptr 标号
  - jcxz 标号
  - loop 标号
- 在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移
  - 如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，易引发错误
  - 当机器码中包含的是转移的位移，无论s处的指令的实际地址是多少, loop指令转移的相对位移是不变的
- 这样的设计，方便了程序段在内存中的浮动装配

## call指令和ret指令

### 模块化程序设计

```c
#include <stdio.h>
int cube(int x);
int main() {
  printf("%d\n", cube(2));
  return 0;
}
int cube(int x) {
  int f = 0;
  f = x * x;
  f = f * x;
  return f;
}
```

- 调用子程序: call指令
- 返回：ret指令

```assembly
mov ax, 0
call s
mov ax, 4c00h
int 21h

s: add, ax 1
	 ret
```

- 实质：流程转移指令，它们都修改IP, 或同时修改CS和IP

### call 指令

- 字面意思：调用子程序

- 实质：流程转移。call指令实现转移的方法和jmp指令的原理类似

- 格式：call 标号

- CPU执行call指令，进行两步操作：

  - 将当前的IP或CS和IP压入栈中
  - 转移到标号处执行指令

- call 标号

  - 16位位移 = 标号处的地址 - call指令后的第一个字节的地址
  - 16位位移的范围为-32768 ~ 32767，用补码表示
  - 16位位移由编译程序在编译时算出

  ```
  (sp) = (sp) - 2; (ip) = ((ss) * 16 + (sp))
  (ip) = (ip) + 16位位移
  相当于： push IP
  			 jmp near ptr 标号
  ```

### 指令call far ptr 标号实现的是段间转移

- CPU执行call far ptr标号时的操作
  - (sp) = (sp) - 2
  - ((ss) * 16 + (sp)) = (cs)
  - (sp) = (sp) - 2
  - ((ss) * 16 + (sp)) = (ip)
  - (CS) = 标号所在的段地址
  - (IP) = 标号所在的偏移地址
- call far ptr标号相当于
  - push CS
  - push IP
  - jmp far ptr 标号
- call 标号类似于jmp near ptr标号，对应的机器指令中为相对于当前IP的转移位移，而不是转移的目的地址，实现段内转移
- 指令call far ptr标号，实现的是段间转移

### 转移地址在寄存器中的call指令

- 指令格式：call 16位寄存器
- 功能：
  - (sp) = (sp) - 2
  - ((ss) * 16 + (sp)) = (ip)
  - (ip) = (16位寄存器)
- 相当于进行
  - push IP
  - jmp 16位寄存器
- call ax

### 转移地址在内存中的call指令

- call word ptr内存单元地址，相当于

  - push IP
  - jmp word ptr 内存单元地址

  ```assembly
  mov sp, 10H
  mov ax, 0123H
  mov ds:[0], ax
  call word ptr ds:[0]
  ;执行后 (IP)=0123H, (sp)=0EH
  ```

- call dword ptr 内存单元地址，相当于

  - push CS
  - push IP
  - jmp dword ptr 内存单元地址

  ```assembly
  mov sp, 10H
  mov ax, 0123H
  mov ds:[0], ax          ; 低地址放偏移地址
  mov word ptr ds:[2], 0  ; 高地址放段地址
  call dword ptr ds:[0]
  ; 执行后，(CS)=0, (IP)=0123H, (sp)=0CH
  ```

### 返回指令： ret 和retf

- ret指令

  - 功能：用栈中的数据，修改IP的内容，从而实现近转移
  - 相当于 pop IP

  ```assembly
  assume cs:codesg, ss:stack
  stack segment
  	ds 16 dup (0)
  stack ends
  codesg segment
  		mov ax, 4C00H
  		int 21H
  start:
  	  mov ax, stack
  	  mov ss, ax
  	  mov sp, 16
  	  mov ax, 0
  	  push ax
  	  mov bx, 0
  	  ret
  codesg ends
  end start
  ```

- retf指令

  - 功能：用栈中的数据，修改CS和IP的内容，从而实现远转移
  - 相当于：pop IP    pop CS

  ```assembly
  assume cs:codesg, ss:stack
  stack segment
  	db 16 dup (0)
  stack ends
  codesg segment
  		mov ax, 4C00H
  		int 21H
  start:
  		mov ax, stack
  		mov ss, ax
  		mov sp, 16
  		mov ax, 0
  		push cs
  		push ax
  		mov bx, 0
  		retf
  codesg ends
  end start
  ```

## call和ret的配合使用

### 具有子程序的源程序的框架

```assembly
assume cs:code
code segment
main: ...
		call sub1     ; 调用子程序sub1
		...
		mov ax, 4C00H
		int 21H

sub1: ...         ; 子程序sub1开始
		call sub2     ; 调用子程序sub2
		...
		ret           ; 子程序返回
		
sub2: ...         ; 子程序sub2开始
    ...
    ret           ; 子程序返回
code ends
end main
```

### call和reg配合使用

- 计算2的N次方，计算前, N的值由cx提供

```assembly
assume cs:code
code segment
start:
		mov ax, 1
		mov cx, 3
		call s
		mov bx, ax
		mov ax, 4c00h
		int 21h
  s:add ax, ax
  	loop s
  	ret
code ends
end start
```

- 上述代码有问题，没有设置调用call和ret指令的栈

```assembly
assume cs:code, ss:stack
stack segment
		db 16 dup (0)
stack ends
code segment
start:
		mov ax, stack
		mov ss, ax
		mov sp, 16
		mov ax, 1000
		call s
		mov ax, 4c00h
		int 21h
 s: add ax, ax
 		ret
code ends
end start
```

## mul指令

### 回顾：除法div指令

- div是除法指令，格式为： div 寄存器或div 内存单元
- 使用div作除法的时候
  - 被除数：（默认）放在ax或dx和ax中
  - 除数：8位或16位，在寄存器或内存单元中

### 用mul指令做乘法

- 格式 mul 寄存器 或 mul 内存单元

- 8位乘法

  - 被乘数（默认）： al
  - 乘数：8位寄存器或内存单元自己
  - 结果：ax

  ```assembly
  mul bl ; (ax) = (al) * (bl)
  mul byte ptr ds:[0] ; (ax) = (al) * ((ds)*16+)
  ```

- 16位乘法

  - 被乘数（默认）：ax
  - 乘数：16位寄存器或内存字单元
  - 结果：dx(高位)和ax(低位)

  ```assembly
  mul word ptr [bx+si+8]
  ; (ax)=(ax)*((ds)*16+(bx)+(si)+8)结果的低16位
  ; (dx)=(ax)*((ds)*16+(bx)+(si)+8)结果的高16位
  ```

### 应用实例

- 计算100 * 10

  - 分析：100和10小于255,可以做8位乘法

  ```assembly
  mov al, 100
  mov bl, 10
  mul bl
  ; 结果(ax)=1000(03E8H)
  ```

- 计算100 * 10000

  - 分析100小于255， 10000大于255，所以必须做16位乘法

  ```assembly
  mov ax, 100
  mov bx, 10000
  mul bx
  ; 结果(dx)=000FH, (ax)=4240H, 即F4240H=1000000
  ```

## 汇编语言的模块化程序设计

### 模块化程序设计



## 寄存器冲突的问题

## 标志寄存器

## 带进(借)位的加减法

## cmp和条件转移指令

## 条件转移指令应用

## DF标志和串传送指令

