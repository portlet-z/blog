- benchmarking so you've just written some code and you want to see how fast it actually runs because you're working on a session that's rather performance critical or you're testing out this new kind of technique that you've just learned about but you want to compare the performance back through the way that you used to do it in the past and see which way is faster
- how do you do that in C++ so unfortunately there's no right answer really to benchmarking because there's so many different ways to do it and everyone has their own kind of way of actually measuring performance because it's such a touchy subject you know if you do it in the wrong way then maybe the fact that you're measuring the performance itself is gonna add overhead to it 
- some people like to rely on third-party profiling tools some people like to actually instrument their code and have things like timers to them some people like to just run their program and just enclose the whole program in kind of a climber and just write a specific program for testing what it is that they want to test there's just so many different ways that you can actually do this 
- so what's the right way, well I of course don't have a right way but I have the way that I do it and that's what I want to share with you guys. 
- today we're gonna talk about how we can actually measure the performance of C++ code I just want to point out as well that the topic of benchmarking is much more than the tools that you use to actually benchmark your code if you're trying to measure performance of a piece of suppose cost code that itself requires you to actually do that quote-unquote properly 
- there's many different ways to do that as well I don't really want to get into them in this video but I think what I will do is make a video and I'll link it up there when it's made of just like a bunch of tips 
- basically that I have for just ensuring that the performance that you'd like when you actually run your program and you're measuring the performance you're actually doing it in a way that the results are going to be somewhat meaningful because there's just so many things to consider when you're actually kind of preparing a code for benchmarking 
- so the first thing I do is write some code that we actually want to test so I'm going to do something very simple I wanna have this value and then  I'm gonna have a for loop which just increments the value like you know a lot of times let's just say like a million times so this is gonna be value plus equals we'll just increment it by two and then finally what I'll do is actually print that value into the console
- I'll stick a breakpoint here and this is a visual studio kind of a windows only function but all its going to do is break the compiler here so that I don't have to like insert some code here and then put a breakpoint myself so if we run that what we should get is just a little program that will print the value basically two times that so here it is right there's about you fantastic 

```c++
#include <iostream>

int main() {
    int value = 0;
    for (int i=0; i<1000000; i++) {
        value += 2;
    }
    std::cout << valule << std::endl;
    __debugbreak();
}
```

- so now that we've got that we want to actually analyze how fast our code is so the way that I like to do this is basically to create a simple kind of scoped based time and now I do have a video about timing in C++ which you can also check out and this is going to be basically something of the sort 
- so we're going to make a class up here called timer and usually of course that keeps in some sort of library we're gonna rely on foreign oil for this the constructor is going to actually start the timer so what we'll do is we'll keep track of the time point that we get from the high resolution clock so this piece of code gets the current time as a specific time point you can see it's an std chrono time point so what we're gonna do is store that in a private member variables so std chrono time point and it's going to be an std high resolution clock 
- we'll call this how's start time point and that's what we're assigning into our start time point. now we're going to write a stop function but this will be automatically called in the destructor like this because I want this to be scope base which basically means that it's tied to the lifetime of the object so in other words when this object gets created we started the timer when the object gets destroyed we stop the timer so this is basically our a III or resource acquisition is initialization so here we have a little bit more work in the stop method
- we'll just do the order here for a lot of these things because they have very long types so we'll have our end time point and the end time point will just be again the current time so when we start a timer we take note of the current time 

```c++
class Timer {
public:
	Timer() {
		start_time_point = std::chrono::high_resolution_clock::now();
	}
	~Timer() {
		stop();
	}
	void stop() {
		auto end_time_point = std::chrono::high_resolution_clock::now();
	}
private:
	std::chrono::time_point<std::chrono::high_resolution_clock> start_time_point;
};
```

- of course and when we sell the time and we take note of the current time so now we'll work out what the start time actually is as an actual value so what this will be what we'll need to do here it's just time point past this to out the units that we want to use which in this case because I want to be fairly precise will use microseconds but you can also use millisecond that's totally fine depends on what you're measuring a lot of the times when you're measuring something it might be below one millisecond and if it's below one milliseconds and you're measuring in milliseconds you look like it's just useless data so microseconds is just a way for us to actually get some  meaningful data if it's really that fun 
- so we'll get a start time point here we'll use your start time point - that's what we're casting me in two microseconds this will basically get us the time since like the beginning of time and we'll get the count of that 
- okay so that's what we end up with it's a fairly long little function here because we need to cast into the right time and then convert into this time and then actually get the count which will kind of give us the microsecond count of the start time 
- okay fantastic and this will this I believe returns a long long yes so that's what they want what kind of B it's a long long and then we'll do the same thing for the end but instead of doing start time point we of course do the same to that end time point and that is where we stop
- okay so now we just need to calculate the duration so auto duration equals and minus start it's that simple and of course we should call this and or not stop 
- okay so now if we wanted to for example calculate the milliseconds because it's in microseconds all we need to do is just multiply duration by 0.001 and that will just give us the microseconds but in milliseconds with  you know decimal points that we can actually see how many milliseconds that was so now it's kind of up to you what you do with this data now because this is kind of scope based it will just get destroyed so what you need to do if you  want to kind of do anything here and what I usually end up doing is actually outputting 
- this data from this stop function into some kind of tracker which actually keeps track of what has been measured and what the actual results have been but that's a very large system that actually outputs like all the data as file and does a bunch of things so that you can actually view it in separate tools and see how long everything in you program took me if you like making a game you'll see how long each frame took and what the functions in the frames were that we're expensive and that's like a whole system and that's definitely gonna be saved for another video
- but for now what we're gonna to do is just output duration so we'll say Oh we'll do fee for this really is just awkward duration so that have been microseconds so we can just write like us I don't have that micro simple handle candy and then we'll do the milliseconds as well and do milliseconds in fact because this is like this I might just do encase instead 
- so we'll do ms and then milliseconds like that so let's do it all in one line so 20 microseconds it is that's how many milliseconds it is 
- okay cool so that's it right so what we should be able to do is now basically if we want to time something like this we can just wrap this whole part that we want to time into a time up like this right now what I'll do with the value is I'll move the value up here so that we can still access it in out print function but that's it we just stick that block of code where we want the time to start and it will last with the duration of this entire scope 
- so now let's hit F5 and see what value we get out of out timer so there's out break point that we hit and you can see that this took there point six nine milliseconds 
- cool now I just want to mention here that it's really important to make sure that what you're supposedly measuring is actually the code that gets compiled because they both cost compiler obviously can optimize code and strip certain code out and change your code entirely
-  for example we've written this wonderful function here and we're running in debug mode so what I'll do is I'll just kind of put a breakpoint here and I'll right-click somewhere and hit go to disassembly now this is the sweet stuff right this is the actual assembly code that your compiler has compiled your C++ code into and then from that machine code it's been kind of decompiled back into assembly code so that we can actually see the instructions that our CPU is executing
- so if we take a look at what's happening here we have this for loop that's not that interesting but then let's say this is our value so what we're doing here is what we're really timing right bar from like the overhead from say the for loop is what we're trying to work but how long it takes to add one number to another number 
- right so that out operation is right over here right so what we do for this code is we move this value variable that's it right here into the EAX register we add 2 to that EAX register that's what does the increment and then we move the value from that EAX register back into the actual value variable and then we jump to like a different part in out code
- so this actual edition you can see is happening it's right over here we can see it in the assembly code which means our CPU is actually doing it now watch what happens if I switch my configuration to release and hit F5 and now check this out so it looks like there's a whole lot less code and specifically if we take a look at this I mean well there's no add instruction anywhere here is there no not at all 
- it looks like what's actually happening is we're calling this function here which is that operator which is our print function and before we do that we push variable on to the stack and that value you look at it one e eight four eight is zero if we just open a programmer calculator here and see that value is two million in decimal 
- so what's actually happened is the compiler has looked at this code and realized that this does not need to be computed at run time and is optimized it into just figuring this out at compile time and all we're doing now is printing the value two million we're not doing any kind of increment at all 
- so my point is that this kind of the results of this from our timer they're gonna be completely useless because we're not measuring out anymore we're basically measuring how long it takes to print something in fact not even that because that timer scope does not include the printing function 
- so whatever you're actually trying to benchmark something make sure that you're actually doing the work that needs to be done you're not just kind of measuring absolutely nothing taking place because the compiler can actually quite aggressively change your code like you can see here 
- I'm gonna give you guys one last example what I'm gonna do is measure the performance of a shared pointer versus a unique point of now this is kind of a hot topic to hear about all the time do we have any kind of overhead from using smart pointers should we use them what we'll actually do here is we'll test it out so I'll include array because I'm gonna do that and what I'm gonna do is just create a whole bunch of pointers
- so I prayed a little class just test out it'll be a vector to class we'll just have flow to exploit Y and then what I'll do is I'll create an array of shared pointer this will be a vector two and we'll create 1000 of them so just a thousand this isn't even going to be that kind of big ok 
- so we have all of our shared pointers here and then what I'll do is inside a for loop which through every element in that array we'll actually have to initialize those pointers that will create them so we'll say shared pointers I equals std makes shared this is another little thing that we can test by the way we have this make shared function which we've heard is supposedly good but we should measure the performance of this versus if we just used if we didn't use make sure if we just kind of just use new to go to actually create the vector two and then sort it inside a inside of share point 
- so we'll put a timer here we don't really want to time the making of the array so we'll just put the timer here just closer to our actual code that we care about and then what I'll do is I'll copy this code I'll paste it here but instead of make shared what I'm gonna do is actually change this to be std shared pointer vector two and I'll just do new vector two just like that 
- okay so now this is kind of the second scenario and finally what I'll do is I'll just use a unique pointer instead so this will be make unique and I can get rid of this and obviously change this to be a unique pointer all right that was pretty good one thing one last thing that I'll do just so that we're a little bit more clear is I'll just label this basically so we'll have make shared we will have I'll call this new shared and I'll call this make unique 
- okay so we have three different tests here of course this actual printing is not getting timed because it's outside the time scope let's hit at F5 and see what we get 
- okay and as you can see some were expected we have our shared pointers taking more time than our unique pointers but wait a minute look at this make shared actually seems to be taking more time than new shard and I can of course we run this program and see if we get different results 
- okay so now make sure if looks like it might be faster let's run this again now new shared is faster right so these two seem to be  about on top of each other but there's one vital thing that we're doing here we're actually profiling this in debug mode and that's not particularly great for measuring performance because it does a whole lot of extra safety stuff which take time so we'll switch our configuration to release and then on our code now you can see we have this whole different ballgame apart from being a lot faster in release mode a lot faster 
- we can also see that make shared is significantly faster than new shard new and if we try and run this again you'll see that we get fairly consistent results of make sure being faster than new shared 
- so always make sure that you profile code that is actually meaningful in a release because you're not gonna be shipping code in debug anyway release will strip away any kind of extra fluff that might be done and you can see that here we get kind of consistent results of what we would actually expect now for this example of shared pointers well I mean we're not even line accessing the data we're not even like sharing the data with other shared pointers or anything on that is pretty much it not a very good test but my point is that how the timing works and that's how we can benchmark our C++ code
