# 2.1 指令系统简介
- 随着技术的进步，计算机的形态产生了巨大的变化，从巨型机到小型机到个人电脑(Personal Computer简称PC)再到智能手机，其基础元件从电子管到晶体管再到超大规模集成电路。虽然计算机的形态和应用场合千变万化，但从用户感知的应用软件到最底层的物理载体，计算机系统均呈现出层次化的结构，图2.1直观的展示了这些层次。
- 从上到下，计算机系统可分为四个层次，分别为应用软件，基础软件，硬件电路和物理载体。软件以指令形式运行在CPU硬件上，而指令系统介于软件和硬件之间，是软硬件交互的界面，有着非常关键的作用。软硬件本身的更新迭代速度很快，而指令系统则可以保持较长时间的稳定。有了稳定不变的指令系统界面，软件与硬件得到有效的隔离，并行发展。遵循同一指令系统的硬件可以运行该指令系统设计的各种软件，比如X86计算机既可运行最新软件，也可运行30年前的软件；反之，为一个指令系统设计的软件可以运行在兼容这一指令系统的不同的硬件实现上，例如同样的操作系统和应用软件在AMD与Intel的CPU上都可以运行。
- 指令系统包括对指令功能、运行时环境（如存储管理机制和运行级别控制）等内容的定义，涉及软硬件交互的各个方面内容，这些内容将在后续章节一一展开介绍。
# 2.2 指令系统设计原则
- 指令系统是软硬件的接口，程序员根据指令系统设计软件，硬件设计人员根据指令系统实现硬件。指令系统稍微变化，一系列软硬件都会受到影响，所以指令系统的设计应遵循如下基本原则：
- 兼容性。这是指令系统的关键特性。最好能在较长时间内保持指令系统不变并保持向前兼容，例如X86指令系统，虽然背了很多历史包袱，要支持过时的指令，但其兼容性使得Intel在市场上获得了巨大的成功。很多其他指令系统进行过结构上的革命，导致新处理器与旧有软件无法兼容，反而造成了用户群体的流式。因此，保持指令系统的兼容性非常重要。
- 通用性。为了适应各种应用需求，如网络应用、计算科学、视频解码、商业应用等。通用CPU指令系统的功能必须完备。而针对特定应用的专用处理器则不需要强调通用性。指令系统的设计还应满足操作系统管理的需求并方便编译器和程序的使用。
- 高效性。指令系统还有便于CPU硬件的设计和优化。对同一指令系统，不同的微结构实现可以得到不同的性能，既可以使用先进、复杂的技术得到较高的性能，也可以用成熟、简单的技术得到一般的性能。
- 安全性。当今计算机系统的安全性非常重要，指令系统的设计应当为各种安全性提供支持，如提供保护模式等。
- 影响指令系统的因素有很多，某些因素的变化会显著影响指令系统的设计，因此有必要了解各方面的影响因素。
- 工艺技术。在计算机发展的早期阶段，计算机硬件非常昂贵，简化硬件实现成为指令系统的主要任务。到了20世纪八九十年代，随着工艺技术的发展，片内可集成晶体管的数据显著增加，CPU可集成更多地功能，功能集成度提高带来的更多可能性支持指令系统的快速发展，例如从32位结构上升至64位结构以及增加多媒体指令等。随着CPU主频的快速提升，CPU速度和存储器速度的差距逐渐变大，为了弥补这个差距，指令系统中增加预取指令将数据预取到高速缓存(Cache)甚至寄存器中。当工艺能力和功耗密度导致CPU主频达到一定极限时，多核结构成为主流，这又导致指令系统的变化，增加访存一致性和核间同步的支持。一方面，工艺技术的发展为指令系统的发展提供了物质基础；另一方面，工艺技术的发展也对指令系统的发展施加影响。
- 计算机体系结构。指令系统本身就是计算机体系结构的一部分，系统结构的变化对指令系统的影响最为直接。诸如单指令多数据(Single Instruction Multiple Data, SIMD)、多核结构等新的体系结构特性必然会对指令系统产生影响。事实上，体系结构的发展与指令系统兼容性的基本原则要求是矛盾的，为了兼容性总会背上历史的包袱。X86指令系统和硬件实现就是因为这些历史包袱而变得比较复杂，而诸如PowerPC等精简指令系统都经历过彻底抛弃过时指令系统的过程。
- 操作系统。现代操作系统都支持多进程和虚拟地址空间。虚拟地址空间使得应用程序无须考虑物理内存的分配，在计算机系统发展中具有里程碑意义。为了实现虚拟地址空间，需要设计专门的地址翻译模块以及与其配套的寄存器和指令。操作系统所使用的异常和中断也需要专门的支持。操作系统通常具有核心态，用户态等权限等级，核心态比用户态具有更高的等级和权限，需要设计专门的核心态指令。核心态指令对指令系统有较大的影响，X86指令系统一直在对核心态指令进行规范，MIPS指令系统直到了MIPS32和MIPS64才对核心态进行了明确的定义，而Alpha指令系统则通过PALcode定义了抽象的操作系统与硬件的界面。
- 编译技术。编译技术对指令系统的影响也比较大。RISC在某种意义上就是编译技术推动的结果。为使编译器有效地调度指令，至少需要16个通用寄存器。指令功能对编译器更加重要，例如一个指令系统没有乘法指令，编译器就只能将其拆分成多个加法进行运算。
- 应用程序。计算机中的各种应用程序都实现一定的算法，指令是从各种算法中抽象出来的“公共算子”，算法就是由算子序列组成的。指令为应用而设计，因而指令系统随着应用的需求而发展。例如从早期的8位、16位到现在的32位、64位，从早期的只支持定点到支持浮点，从只支持通用指令到支持SIMD指令。此外，应用程序对指令系统的要求还包括前述的兼容性。
- 总之，指令系统需遵循的设计原则和影响因素很多，指令系统的设计需要考虑多方因素并小心谨慎。
# 2.3 指令系统的发展历程
- 指令系统的发展经历了从简单到复杂，再从复杂到简单的演变过程。现代指令系统在指令内容、存储管理和运行级别控制等方面都产生了一系列变化，这些变化体现了人类对计算机体系结构这个学科认知的提升。
## 2.3.1 指令内容的演变
- 依据指令长度的不同，指令系统可分为复杂指令系统(Complex Instruction Set Computer, CISC)和精简执行系统(Reduced Instruction Set Computer, RISC)和超长指令字(Very Long Instruction Word, VLIW)指令集三种。CISC中的指令长度可变；RISC中的指令长度比较固定；VLIW本质上来讲是多条同时执行的指令的组合，其“同时执行”的特征由编译器指定，无须硬件进行判断。
- 早期的CPU都采用CISC结构，如IBM的System360、Intel的8080和8086系列、Motorola的68000系列等。这与当时的时代特点有关，早期处理设备昂贵且处理速度慢，设计者不得不加入越来越多的复杂指令来提高执行效率，部分复杂指令甚至可与高级语言中的操作直接对应。这种设计简化了软件和编译器的设计，但也显著提高了硬件的复杂性。
- 当硬件复杂度逐渐提高时，CISC结构出现了一系列问题。大量复杂指令在实际应用中很少用到，典型程序所使用的80%的指令只占指令集总指令数的20%，消耗大量精力的复杂设计只有很少的回报。同时，复杂的微代码翻译也会增加流水线设计难度，并降低频繁使用的简单指令的执行效率。
- 针对CISC结构的缺点，RISC遵循简化的核心思路。RISC简化了指令功能，单个指令执行周期短；简化了指令编码。使得译码简单；简化了访存模型，访存只能通过load/store指令实现。RISC指令的设计精简是简化了指令间的关系，有利于实现高效的流水线，多发射等技术，从而提高主频和效率。
- 最早的RISC处理器可追溯到CDC公司和其1964年推出的世界上第一台超级计算机CDC6600,现代RISC结构的一些关键特性-如至通过load/store指令访存的load/store结构-都在CDC6600上显现雏形，但简化结构提高效率的思想并未受到小型机和微处理器设计者的重视。1975年，John Cocke在IBM公司位于约克镇的Thomas J.Watson研究中心组织研究指令系统的合理性并研制现代RISC计算机的鼻祖IBM 801，现在IBM PowerPC的主要思想就源于IBM801。参与IBM801项目的David Patterson和John Hennessy分别回到加州大学伯克利分校和斯坦福大学，开始从事RISC-1/RISC-2项目和MIPS项目，它们分别成为SPARC处理器核MIPS处理器的前身。IBM801的项目经理Joel Birnbaum在HP创立了PA-RISC, DEC公司在MIPS的基础上设计了Alpha处理器。广泛使用的ARM处理器也是RISC处理器的代表之一。David Patterson教授在加州大学伯克利分校推出的开源指令系统RISC-V,是加州大学伯克利分校推出的继RISC-I(1981年推出)，RISC-II(1982年推出)，SOAR(1984年推出，也称为RISC-III),SPUR(1988年推出，也成为RISC-IV)之后的第五代指令系统。
- RISC指令系统的最本质特征是通过load/store结构简化了指令间关系，即所有运算指令都是对寄存器运算，所有访存都通过专用的访存指令(load/store)进行。这样，CPU只要通过寄存器号就能判断运算指令之间以及运算指令和访存指令直接有没有数据相关性，而较复杂的访存指令相关判断（需要对访存的物理地址进行比较）则只在执行load/store指令的访存部件上进行，从而大大简化了指令间相关性判断的复杂度，有利于CPU采用指令流水线、多发射、乱序执行等提高性能。因此，RISC不仅是一种指令系统类型，同时也是一种提高CPU性能的技术。X86处理器中将CISC指令译码为类RISC的内部操作，然后对这些内部操作使用诸如超流水线、乱序执行、多发射等高效实现手段。而以PowerPC为例的RISC处理器则包含了许多功能强大的指令。
- VLIM的思想最初由Josh Fisher于20世纪80年代在耶鲁大学提出，Fisher随后离开耶鲁创立了Multiflow公司，并研制了TRACE系列VLIM处理器。后来Fisher和同样经理创业失败的Bob Rau加入了HP公司，并主导了HP在20世纪90年代的计算机结构研究
- 同时,Intel在i860中实现了VLIM, 这也奠定了随后两家公司在Itanium处理器上的合作关系，Itanium(IA-64)采用的EPIC结构的思想来源于VLIM.
- 图2.2直观地给出了RISC,CISC,VLIM三种结构的指令编码。MIPS三种类型的指令内部位域分配不同，但总长度均为32位；X86则不同指令的长度都可能不同；IA-64则将三条41位定长指令合并位一条128位的“束”。
## 2.3.2 存储管理的演变
- 存储器是冯诺依曼结构计算机的核心部件、存储管理的演变是指令系统演变的重要组成部分。
- 存储管理的演变经历了连续实地址、段式、页式虚拟存储等阶段。
- 连续实地址的管理方式是最早期也是最朴素的方式，各程序所需的内存空间必须连续存放并保证不与其他程序产生冲突。这种方式不但会带来大量的内存碎片，而且难以管理多个程序的空间分配。
- 段式存储管理将内存分为多个段和节，地址组织为相对于段地址的偏移。段式存储主要应用于早期处理器中，Burroughs公司的B5000是最早使用段式存储的计算机之一。Intel从8086处理器开始使用段式存储管理，在80286之后兼容段页式，但在最新的X86-64位架构中放弃了对段式管理的支持。
- 页式虚拟存储管理将各进程的虚拟内存空间划分成若干长度相同的页，将虚拟地址和物理地址的对应关系组织为表，并通过硬件来实现快速的地址转换。现代通用处理器的存储管理单元都基于页式虚拟管理，并通过TLB进行地址转换加速。
- 页式虚拟存储可使各进程运行在各自独立的虚拟地址空间中，并提供内存映射、公平的物理内存分配和共享虚拟内存等功能，是计算机系统发展过程中具有里程碑意义的一项技术。
- 下面分别介绍上述几种存储管理方式的基本方法。
- 段式存储管理的地址转换过程如图2.3所示。虚拟地址分为段号和段内偏移两部分，地址转换时根据段号检索段表，得到对应段的起始物理地址（由段长度和基址可得），再加上段内偏移，得到最终的物理地址。需要注意的是，段表中存有每个段的长度，若段内偏移超过该段长度，将被视为不合法地址。
- 段式存储中每段可配置不同的起始地址，但段内地址扔需要连续，当程序段占用空间较大时，仍然存在内存碎片等问题。
- 页式存储管理的地址转换过程如图2.4所示。虚拟地址分为虚拟页号和页内偏移两部分，地址转换时根据虚拟页号检索表，得到对应的物理页号，与页内偏移组合得到最终的物理地址。
- 段页式管理结合了段式和页式的特点，其地址转换过程如图2.5所示，虚拟地址分为段号、虚拟页号和页内偏移三部分，地址转换时首先根据段号查询段表得到对应段的页表起始地址，再根据虚拟页号查询页表得到物理页号，与页内偏移组合得到最终的物理地址。段页式同样需要检查段地址的合法性。
## 2.3.3 运行级别的演变
- 作为软件指令的执行者，处理器中有各种级别的资源，比如通用寄存器、控制寄存器等。为了对软件所能访问的资源加以限制，计算机引入了运行级别的概念。运行级别经历了无管理、增加保护模式、增加调试模式、增加虚拟化支持等阶段。
- 早期的处理器核当今的嵌入式单片机中不包含运行级别的控制，所有程序都可控制所有资源。无管理的方式在安全方面毫无保障，软件必须小心设计，确保不会相互干扰。这通常只在规模有限、封闭可控的系统如微控制器(Micro Control Unit, MCU)中使用。
- 现代操作系统(Linux)包含保护模式，将程序分为两个权限等级：用户态和核心态。核心态具有最高权限，可以执行所有指令，访问任意空间。在用户态下，程序只能访问受限的内存空间，不允许访问外围设备。用户态程序需要使用外部设备时，通过系统调用提出申请，由操作系统在核心态下完成访问。保护模式需要硬件支持，如X86指令系统中定义了Ring0-Ring3四个权限等级，MIPS指令系统中定义了user,supervisor和kernel三个权限等级。LongArch指令系统中定义了PLV0-PLV3四个权限等级，由当前模式信息控制状态寄存器（CSR, CRMD）的PLV域的值确定。在LongArch处理器上运行的Linux操作系统，其核心态程序运行在PLV0级，用户态程序通常运行在PLV3级。
- 为了方便软硬件调试，许多指令系统中还定义了调试模式和相应的调试接口，如ARM的JTAG、MIPS的EJTAG。LongArch指令系统定义了专门的调试模式，调试模式和配套的状态控制寄存器。在调试模式下，处理器所执行的程序将获得最高的权限等级。不过此时处理器所执行的指令是从外部调试接口中获得的，并且利用专用的控制状态寄存器使得调试程序的上下文可以无缝切换。
- 虚拟化技术在服务器领域特别有用，一台物理主机可以支持多台虚拟机，运行各自的系统。虚拟机不绑定底层硬件，可看作一个软件进程，因而部署起来非常灵活。虚拟机中同样要支持不同的运行级别，为了提高效率，硬件辅助虚拟化成为虚拟化发展的必然趋势。IBM System/370早在1970年就增加了硬件虚拟化支持；2005年以来，Intel和AMD也分别提出了硬件辅助虚拟化的扩展VT和SVM。ARM的AArch64架构页定义了硬件虚拟化支持方面的内容。这些指令系统在硬件虚拟化支持中引入了新的运行级别，用于运行虚拟机操作系统的核心态和用户态程序。
- 以LoongArch指令系统为例，其运行级别主要包括调试模式(Debug Mode)、主机模式(Host Mode)和客户机模式(Guest Mode)。主机模式和客户机模式又各自包含PLV0-PLV3四个权限等级，即具有Host-PLV0-Host-PLV3和Guest-PLV0-Guest-PLV3这8个运行级别。所有运行级别互相独立，即处理器在某一时刻只能存在某一种运行级别中。处理器上电复位后处于Host-PLV)级，随后根据需要在不同运行级别之间转换。
- 不同运行级别可访问并控制的处理器资源不同。图2.6给出了这种对应关系的示意。其中调试模式下具有最高的优先级，可以访问并控制处理器中所有的资源；Host-PLV0模式下可以访问并控制处理器中除了用于调试功能外的所有其他资源；Guest-PLV0模式下只能访问部分处理器资源，如客户机控制状态寄存器；Host-PLV1/2/3和Guest-PLV1/2/3则只能访问更少的处理器资源。
# 2.4 指令系统组成
- 指令系统由若干条指令及其操作对象组成。每条指令都是对一个操作的描述，主要包括操作码和操作数。操作码规定指令功能，例如加减法；操作数指示操作对象，包括数据类型，访存地址，寻址方式等内容。
## 2.4.1 地址空间
- 处理器可访存的地址空间包括寄存器空间和系统内存空间。寄存器空间包括通用寄存器、专用寄存器和控制寄存器。寄存器通过编码于指令中的寄存器寻址，系统内存空间通过访存指令中的访存地址寻址。
- 通用寄存器是处理器中最常用的存储单元，一个处理器周期可以同时读取多条指令需要的多个寄存器值。现代指令系统都定义了一定数量的通用寄存器供编译器进行充分的指令调度。针对浮点运算，通常定义了浮点通用寄存器。表2.1给出了部分常见指令集中整数通用寄存器的数量。
| 指令系统           | 整数通用寄存器数量                      |
| ------------------| ------------------------------------|
| Itanium           | 128                                 |
| VAX               | 16                                  |
| ARMv8             | 31                                  |
| PowerPC           | 32                                  |
| Alpha             | 32(包括“zero”)                       |
| SPARC             | 32(包括“zero”)                       |
| MIPS              | 在mips16模式下为8，在32/64位模式下为32  |
| ARMv7             | 在16位Thumb模式下为7，在32位模式下为14   |
| X86               | 16/32位时为8，64位时为16               |
| LongArch          | 32(包括"zero)                        |
- LongArch指令系统中定义了32个整数通用寄存器和32个浮点通用寄存器，其编码分别表示为$r0-$r31和$f0-$f31,其中$r0总是返回0。
- 除了通用寄存器外，有的指令系统还会定义一些专用寄存器，仅用于某些专用指令或专用功能。如MIPS指令系统中定义的HI,LO寄存器就仅用于存放乘法指令的运行结果。
- 控制寄存器用于控制指令执行的环境，比如是核心态还是用户态。其数量、功能和访问方式依据指令系统的定义各不相同。LoongArch指令系统中定义了一系列控制状态寄存器(Control Status Register, CSR),将在第3章介绍。
- 广义的系统内存空间包括IO空间和内存空间，不同指令集对系统内存空间的定义各不相同。X86指令集包含独立的IO空间和内存空间，对这两部分的访问需要使用不同的指令：内存空间使用一般的访存指令，IO空间使用专门的in/out指令。而MIPS,ARM,LoongArch等RISC指令集则通常不区分IO空间和内存空间，把它们都映射到同一个系统内存空间进行访问，使用相同的load/store指令。处理器对IO空间的访问不能经过Cache,因此在使用相同的load/store指令既访问IO空间又访问内存空间的情况下，就需要定义缓存一致性属性(Cache Coherency Attribute, CCA)UnCached和Cached分别用于IO空间和内存空间的访问，ARM AArch64指令定义内存属性(Memory Attribute)Device和Normal分别对应IO空间和内存空间的访问，LoongArch指令集定义存储访问类型(Memory Access Type, MAT)强序非缓存(Strongly-ordered UnCached, SUC)和一致可缓存(Coherent Cached, CC)分别用于IO空间和内存空间的访问。存储访问类型通常根据访存地址范围来确定。如果采用页式地址映射方式，那么同一页内的地址定义为相同的存储访问类型，通常作为该页的一个属性信息记录在页表中，如MIPS指令集中的页表项含有CCA域，LoongArch指令集中的页表项含有MAT域。如果采用段式地址映射方式，那么同一段内地址定义为相同的存储访问类型。如MIPS32中规定虚地址空间的kseg1段(地址范围0xa0000000-0xbfffffff)的存储访问类型固定为Uncached,操作系统可以使用这段地址来访问IO空间。LoongArch指令集可以把直接地址映射窗口的存储访问类型配置为SUC,那么落在该地址窗口就可以访问IO空间。（有关LoongArch指令集中直接地址映射窗口的详细介绍请看第3章）
- 根据指令使用数据的方式，指令系统可分为堆栈型、累加器型和寄存器型。寄存器型又可以进一步分为寄存器-寄存器型(Register-Register)和寄存器-存储器型(Register-Memory)。下面分别介绍各类型的特点。
- 堆栈型。堆栈型指令又称零地址指令，其操作数都在栈顶，在运算指令中不需要知道操作数，默认对栈顶数据进行运算并将结果压回栈顶。
- 累加器型。累加器型又称单地址指令，包含一个隐含操作数-累加器，另一个操作数在指令中指定，结果写会累加器中。
- 寄存器-存储器型。在这种类型的指令系统中，每个操作数都由指令显示指定，操作数为寄存器和内存单元。
- 寄存器-寄存器型。在这种类型的指令系统中，每个操作数都有指令显示指定，但除了访存指令外的其他指令的操作数都只能是寄存器。
- 表2.2给出了四种类型的指令系统中执行C=A+B的指令序列，其中A,B,C为不同的内存地址，R1, R2等为通用寄存器。
| 堆栈型      ｜ 累加器型      | 寄存器-存储型   | 寄存器-寄存器型   |
| ---------- | ------------ | ------------- | --------------- |
| PUSH A     | LOAD A       | LOAD R1,A     | LOAD R1,A       |
| PUSH B     | ADD B        | ADD R1,B      | LOAD R2,B       |
| ADD        | STORE C      | STORE C,R1    | ADD R3,R1,R2    |
| POP C      |              |               | STORE C,R3      |
- 寄存器-寄存器型指令系统中运算指令的操作数只能来自寄存器，不能来自存储器，所有的访存都必须显式通过load和store指令来完成，所以寄存器-寄存器型又被成为load-store型。
- 早期的计算机经常使用堆栈型和累加器型指令系统，主要的目的是降低硬件实现的复杂度。除了X86还保留堆栈型和累加器型指令系统外，当今的指令系统主要是寄存器型，并且是寄存器-寄存器型。使用寄存器的优势在于，寄存器的访问速度快，便于编译器的调度优化，并可以充分利用局部性原理，大量的操作可以在寄存器中完成。此外，寄存器-寄存器型的另一个优势是寄存器之间的相关性容易判断，容易实现流水线，多发射和乱序执行等方法。
## 2.4.2 操作数
### 2.4.2.1 数据类型
- 计算机中常见的数据类型包括整数、实数、字符，数据长度包括1字节、2字节、4字节和8字节。X86指令集中还包括专门的十进制类型BCD。表2.3给出C语言整数类型与不同指令集中定义的名称和数据长度（以字节为单位）的关系。
- 实数类型在计算机中表示为浮点类型，包括单精度浮点数和双精度浮点数，单精度浮点数据长度为4字节，双精度浮点数据为8字节。
- 在指令中表达数据类型有两种方法。一种是由指令操作码来区分不同类型，例如加法指令包括定点加法指令、单精度浮点加法指令、双精度浮点加法指令。另一种是将不同类型的标记附在数据上，例如加法使用统一的操作码，用专门的标记来标明加法操作的数据类型。
### 2.4.2.2 访存地址
- 在执行访存指令时，必须考虑的问题是访存地址是否对齐和指令系统是否支持不对齐访问。所谓对齐访问是指对该数据的访问起始地址是其数据长度的整数倍，例如访问一个4字节数，其访存地址的低两位对应为0。对齐访问的硬件实现较为简单，若支持不对齐访问，硬件需要完成数据的拆分和拼合。但若只支持对齐访问，又会使指令系统丧失一些灵活性，例如串操作经常需要进行不对齐访问，只支持对齐访问会让串操作的软件实现变得较为复杂。以X86为代表的CISC指令集通常支持不对齐访问，RISC类指令集在早期发展过程中为了简化硬件设计只支持对齐访问，不对齐的地址访问将产生异常。近些年来伴随着工艺和设计水平的提升，越来越多的RISC类指令也开始支持不对齐访问以减轻软件优化的负担。
- 灵越与访存地址相关的问题是尾端(Endian)问题。不同的机器可能使用大尾端和小尾端，最低有效字节的地址较小的是小尾端。Motorola的68000系列和IBM的System系列指令系统采用大端，X86,VAX和LoongArch等指令系统采用小端，ARM, SPARC和MIPS等指令系统同时支持大小端。
### 2.4.2.3 寻址方式
