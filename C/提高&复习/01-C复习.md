# 数组
- 数组做函数参数的退回问题：退回为一个指针。
- 结论：把数组的内存首地址和数组的有效长度传给被调用参数
- 实参a和形参a的数据类型本质不一样;在形参中的数组，编译器会把它当初指针处理，这是C语言的特色
- 形参写在函数上和写在函数内是一样的，只不过是具有对外的属性而已
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

//static void printArray(int a[7], int length) {
//static void printArray(int a[], int length) {
static void printArray(int *a, int length) {
	int i = 0;
	for (i = 0; i < length; i++) {
		printf("%d ", a[i]);
	}
	printf("\n");
}

//static void sortArray(int a[7], int length) {
//static void sortArray(int a[], int length) {
static void sortArray(int *a, int length) {
	int in_length = sizeof(a) / sizeof(a[0]);
	// in_length 32位 1，64位 2
	// 实参a和形参a的数据类型本质不一样
	// 在形参中的数组，编译器会把它当初指针处理，这是C语言的特色
	int i = 0, j = 0;
	for (i = 0; i < length; i++) {
		for (j = i + 1; j < length; j++) {
			if (a[i] <= a[j]) {
				continue;
			}
			int temp = a[j];
			a[j] = a[i];
			a[i] = temp;
		}
	}
}

// 排序
void main() {
	
	int a[] = { 33,654,4,456,6,33,4 };
	int length = sizeof(a) / sizeof(a[0]);
	printArray(a, length);
	// 排序
	sortArray(a, length);
	printArray(a, length);
	printf("hello...\n");
	system("pause");
}
```
# 数据类型
- 数据类型的本质: 固定大小内存块的别名
- 数组数据类型(1. 定义一个数组类型 2数组指针 3数组类型和数组指针类型的关系)
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a; //告诉c编译器分配4个字节的内存
	int b[10]; //告诉c编译器分配40个字节的内存
	// b:20183088, b+1:20183092, &b:20183088, &b+1:20183128
	// b+1与&b+1结果不一样；b和&b所代表的数据类型不一样
	// b代表数组首元素的地址，&b代表的是整个数组的地址
	printf("b:%d, b+1:%d, &b:%d, &b+1:%d \n", b, b+1, &b, &b+1);

	printf("sizeof(b): %d\n", sizeof(b)); // 40
	printf("sizeof(a): %d\n", sizeof(a)); // 4
	printf("hello\n");
}
```
- 数据类型别名
```c
struct Teacher {
	char name[64];
	int age;
}Teacher;

// 数据别名typedef
typedef struct Teacher2 {
	char name[64];
	int age;
}Teacher2;

typedef int u32;

void main() {
	struct Teacher t1;
	Teacher2 t2;
	printf("u32:%d\n", sizeof(u32)); // 4
	printf("hello\n");
}
```
- 数据类型的封装：void的字面意思时“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据
# 变量
- 变量的本质是一段连续内存空间的别名（是一个门牌号）
- 对内存空间能不能再取别名 C++ 引用
- 对内存可读可写；通过变量往内存读写数据；不是向变量读写数据
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a;
	// 直接赋值
	a = 10;
	printf("&a: %d\n", &a);
	// 间接赋值
	*((int*)(&a)) = 200;
	printf("%d\n", a);
	int* p;
	p = &a;
	*p = 300;
	printf("%d\n", a);
	printf("hello\n");
}
```
# 内存四区
## 静态存储区理解（全局区）
- 指针指向谁，就把谁的地址赋给指针
- 指针变量和他所指向的内存空间变量是两个不同的概念
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

char* getStr1() {
	char* p1 = "hello world2";
	return p1;
}
char* getStr2() {
	char* p2 = "hello world2";
	return p2;
}

void main() {
	char* p1 = NULL;
	char* p2 = NULL;
	p1 = getStr1();
	p2 = getStr2();
	// 打印p1, p2所指向内存空间的数据
	printf("p1: %s, p2: %s \n", p1, p2);
	//p1: hello world2, p2: hello world2
	// "hello world2"存在全局区里
	//p1: 13474924, p2 : 13474924
	// 打印p1, p2的值
	printf("p1: %d, p2: %d \n", p1, p2);
	printf("hello\n");
}
```
## 堆栈
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

//堆
char* getMem(int num) {
	char* p1 = NULL;
	p1 = (char*)malloc(sizeof(char) * num);
	if (p1 == NULL) {
		return NULL;
	}
	return p1;
}
//栈
char* getMem2() {
	char buf[64]; // 临时变量 栈区存放
	strcpy(buf, "123456789");
	printf("buf:%s\n", buf);
	return buf;
}

void main() {
	char* tmp = NULL;
	tmp = getMem(10);
	if (tmp == NULL) {
		return;
	}
	// 向tmp指向的内存空间中copy数据
	strcpy(tmp, "hello");
	printf("%s\n", tmp);

	// 不要这样使用，栈区调用完可能会被释放掉
	tmp = getMem2();
	printf("%s\n", tmp);
	printf("hello\n");
}
```