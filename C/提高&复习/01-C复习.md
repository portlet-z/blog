# 数组
- 数组做函数参数的退回问题：退回为一个指针。
- 结论：把数组的内存首地址和数组的有效长度传给被调用参数
- 实参a和形参a的数据类型本质不一样;在形参中的数组，编译器会把它当初指针处理，这是C语言的特色
- 形参写在函数上和写在函数内是一样的，只不过是具有对外的属性而已
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

//static void printArray(int a[7], int length) {
//static void printArray(int a[], int length) {
static void printArray(int *a, int length) {
	int i = 0;
	for (i = 0; i < length; i++) {
		printf("%d ", a[i]);
	}
	printf("\n");
}

//static void sortArray(int a[7], int length) {
//static void sortArray(int a[], int length) {
static void sortArray(int *a, int length) {
	int in_length = sizeof(a) / sizeof(a[0]);
	// in_length 32位 1，64位 2
	// 实参a和形参a的数据类型本质不一样
	// 在形参中的数组，编译器会把它当初指针处理，这是C语言的特色
	int i = 0, j = 0;
	for (i = 0; i < length; i++) {
		for (j = i + 1; j < length; j++) {
			if (a[i] <= a[j]) {
				continue;
			}
			int temp = a[j];
			a[j] = a[i];
			a[i] = temp;
		}
	}
}

// 排序
void main() {
	
	int a[] = { 33,654,4,456,6,33,4 };
	int length = sizeof(a) / sizeof(a[0]);
	printArray(a, length);
	// 排序
	sortArray(a, length);
	printArray(a, length);
	printf("hello...\n");
	system("pause");
}
```
# 数据类型
- 数据类型的本质: 固定大小内存块的别名
- 数组数据类型(1. 定义一个数组类型 2数组指针 3数组类型和数组指针类型的关系)
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a; //告诉c编译器分配4个字节的内存
	int b[10]; //告诉c编译器分配40个字节的内存
	// b:20183088, b+1:20183092, &b:20183088, &b+1:20183128
	// b+1与&b+1结果不一样；b和&b所代表的数据类型不一样
	// b代表数组首元素的地址，&b代表的是整个数组的地址
	printf("b:%d, b+1:%d, &b:%d, &b+1:%d \n", b, b+1, &b, &b+1);

	printf("sizeof(b): %d\n", sizeof(b)); // 40
	printf("sizeof(a): %d\n", sizeof(a)); // 4
	printf("hello\n");
}
```
- 数据类型别名
```c
struct Teacher {
	char name[64];
	int age;
}Teacher;

// 数据别名typedef
typedef struct Teacher2 {
	char name[64];
	int age;
}Teacher2;

typedef int u32;

void main() {
	struct Teacher t1;
	Teacher2 t2;
	printf("u32:%d\n", sizeof(u32)); // 4
	printf("hello\n");
}
```
- 数据类型的封装：void的字面意思时“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据
# 变量
- 变量的本质是一段连续内存空间的别名（是一个门牌号）
- 对内存空间能不能再取别名 C++ 引用
- 对内存可读可写；通过变量往内存读写数据；不是向变量读写数据
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a;
	// 直接赋值
	a = 10;
	printf("&a: %d\n", &a);
	// 间接赋值
	*((int*)(&a)) = 200;
	printf("%d\n", a);
	int* p;
	p = &a;
	*p = 300;
	printf("%d\n", a);
	printf("hello\n");
}
```
# 内存四区
## 静态存储区理解（全局区）
- 指针指向谁，就把谁的地址赋给指针
- 指针变量和他所指向的内存空间变量是两个不同的概念
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

char* getStr1() {
	char* p1 = "hello world2";
	return p1;
}
char* getStr2() {
	char* p2 = "hello world2";
	return p2;
}

void main() {
	char* p1 = NULL;
	char* p2 = NULL;
	p1 = getStr1();
	p2 = getStr2();
	// 打印p1, p2所指向内存空间的数据
	printf("p1: %s, p2: %s \n", p1, p2);
	//p1: hello world2, p2: hello world2
	// "hello world2"存在全局区里
	//p1: 13474924, p2 : 13474924
	// 打印p1, p2的值
	printf("p1: %d, p2: %d \n", p1, p2);
	printf("hello\n");
}
```
## 堆栈
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

//堆
char* getMem(int num) {
	char* p1 = NULL;
	p1 = (char*)malloc(sizeof(char) * num);
	if (p1 == NULL) {
		return NULL;
	}
	return p1;
}
//栈
//注意 return不是把内存块64个字节给return出来，而是把内存块的首地址（内存标号0xaa11）返回给tmp
//理解指针的关键是内存，没有内存哪来的指针 
char* getMem2() {
	char buf[64]; // 临时变量 栈区存放
	strcpy(buf, "123456789");
	printf("buf:%s\n", buf);
	return buf;
}

void main() {
	char* tmp = NULL;
	tmp = getMem(10);
	if (tmp == NULL) {
		return;
	}
	// 向tmp指向的内存空间中copy数据
	strcpy(tmp, "hello");
	printf("%s\n", tmp);

	// 不要这样使用，栈区调用完可能会被释放掉
	tmp = getMem2();
	printf("%s\n", tmp);
	printf("hello\n");
}
```
## 函数调用模型
```c
void fb() {}
void fa() {
	fb();
}
void main() {
	fa();
}
```
- main函数中可以在栈分配内存/可以在堆上分配内存/全局区分配内存。分配的内存可以被fa,fb使用
- fb申请的内存，可以被main使用吗？
	1. fb中在栈上分配的内存，不能被fa和main函数使用
	2. fb中malloc的内存（堆），可以被main和fa函数使用
	3. fb中全局区分配"abcdefg"内存是可以被fa和main函数使用的
- 主调函数如何使用被调用函数分配的内存（技术关键点：指针做函数参数）
# 指针
## 指针是一种数据类型
- 指针也是一种变量，占有内存空间，用来保存内存地址
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a = 10;
	char* p1 = 100; //分配4个字节的内存
	char**** p2 = 100;
	printf("a:%d, p1:%d, p2:%d\n", sizeof(a), sizeof(p1), sizeof(p2));
	printf("hello\n");
}
```
- *p 操作内存
	- 在指针声明时，* 表示所声明的变量为指针
	- 在指针使用时，* 表示操作指针所指向的内存空间中的值
	- *p 放在等号的左边赋值 （给内存赋值）
	- *p 放在等号的右边取值 （从内存获取值）
- 不断的给指针赋值，相当于不停的改变指针的指向
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a = 10;
	int* p3 = NULL;
	p3 = &a;
	*p3 = 20; // 间接的修改a的值
	// 就像一把钥匙通过一个地址&a,去修改a变量标识的内存空间
	int b = *p3; //*p放在=左边，写内存；*p放在=右边，读内存
	printf("a:%d, b:%d \n", a, b); // a:20, b:20
	printf("hello\n");
}
```
- 保证所指向的内存块能修改
```c
char* getStr() {
	char* tmp = NULL;
	tmp = "abcdefg";
	return tmp;
}

void main() {
	char* p = getStr();
	printf("p:%s\n", p);
	*(p + 2) = 'r'; //执行报错，"abcdefg"存在常量区，不能被修改
	printf("p:%s\n", p);
	printf("hello\n");
}
```
- 指针做函数参数 形参又多级指针的时候，站在编译器的角度，只需要分配4个字节的内存(32bit),当我们使用内存的时候，我们才关心指针所指向的内存是一维的还是二维的
- 指针是一种数据类型，是指它指向的内存空间的数据类型
	- 指针步长(p++),根据所指向内存空间的数据类型来确定
	- 指针的步长，根据所指向内存空间类型来定
```c
int getABC1(char* p1);
int getABC2(char** p2);
int getABC3(char*** p3);
int getABC4(char (*p4)[30]);
int getABC5(char p5[10][30]);
```