# 数组
- 数组做函数参数的退回问题：退回为一个指针。
- 结论：把数组的内存首地址和数组的有效长度传给被调用参数
- 实参a和形参a的数据类型本质不一样;在形参中的数组，编译器会把它当初指针处理，这是C语言的特色
- 形参写在函数上和写在函数内是一样的，只不过是具有堆外的属性而已
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

//static void printArray(int a[7], int length) {
//static void printArray(int a[], int length) {
static void printArray(int *a, int length) {
	int i = 0;
	for (i = 0; i < length; i++) {
		printf("%d ", a[i]);
	}
	printf("\n");
}

//static void sortArray(int a[7], int length) {
//static void sortArray(int a[], int length) {
static void sortArray(int *a, int length) {
	int in_length = sizeof(a) / sizeof(a[0]);
	// in_length 32位 1，64位 2
	// 实参a和形参a的数据类型本质不一样
	// 在形参中的数组，编译器会把它当初指针处理，这是C语言的特色
	int i = 0, j = 0;
	for (i = 0; i < length; i++) {
		for (j = i + 1; j < length; j++) {
			if (a[i] <= a[j]) {
				continue;
			}
			int temp = a[j];
			a[j] = a[i];
			a[i] = temp;
		}
	}
}

// 排序
void main() {
	
	int a[] = { 33,654,4,456,6,33,4 };
	int length = sizeof(a) / sizeof(a[0]);
	printArray(a, length);
	// 排序
	sortArray(a, length);
	printArray(a, length);
	printf("hello...\n");
	system("pause");
}
```
# 数据类型
- 数据类型的本质: 固定大小内存块的别名
- 数组数据类型(1. 定义一个数组类型 2数组指针 3数组类型和数组指针类型的关系)
```c
#include "stdlib.h"
#include "string.h"
#include "stdio.h"

void main() {
	int a; //告诉c编译器分配4个字节的内存
	int b[10]; //告诉c编译器分配40个字节的内存
	// b:20183088, b+1:20183092, &b:20183088, &b+1:20183128
	// b+1与&b+1结果不一样；b和&b所代表的数据类型不一样
	// b代表数组首元素的地址，&b代表的是整个数组的地址
	printf("b:%d, b+1:%d, &b:%d, &b+1:%d \n", b, b+1, &b, &b+1);

	printf("sizeof(b): %d\n", sizeof(b)); // 40
	printf("sizeof(a): %d\n", sizeof(a)); // 4
	printf("hello\n");
}
```
- 数据类型别名
```c
struct Teacher {
	char name[64];
	int age;
}Teacher;

// 数据别名typedef
typedef struct Teacher2 {
	char name[64];
	int age;
}Teacher2;

typedef int u32;

void main() {
	struct Teacher t1;
	Teacher2 t2;
	printf("u32:%d\n", sizeof(u32)); // 4
	printf("hello\n");
}
```
- 数据类型的封装
    - void的字面意思时“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据