## 数据类型本质分析

### 数据类型概念

- “类型”是对数据的抽象
- 类型相同的数据有相同的表示形式、存储格式以及相关的操作
- 程序中使用的所有数据都必定属于某一数据类型

### 数据类型本质的思考

- 思考数据类型和内存有关系吗？
  - 有关系，不同的数据类型在内存中所占用的空间不同
- C/C++为什么引入数据类型？
  - 为了更好的管理数据的存储和操作。数据类型定义了数据的大小、范围和存储方式，以及可以对数据执行的操作
  - 内存管理：
  - 数据范围：
  - 编译时类型检测：
  - 代码的可读性和可维护性：
  - 优化编译器

### 数据类型的本质

- 数据类型可以理解为创建变量的模具；是固定内存块大小的别名

- 数据类型的作用：编译器预算对象（变量）分配内存空间大小

- sizeof是操作符，不是函数；sizeof测量的实体大小为编译期间就已确定

- 数据类型可以理解为固定大小内存块的别名，数据类型可以起别名吗？

  ```c
  struct Teacher {
      int age;
      char name[64];
  } Teacher;
  
  //使用时必须带上struct关键字
  struct Teahcer teacher;
  
  //数据别名typedef
  typedef int u32;
  typedef struct Teacher2{
    int age;
    char name[64];
  }Teacher2;
  //使用时不必带上struct关键字
  Teacher2 teacher2;
  ```

- int b[10]; b+1, &b+1 结果不一样。b代表的数组元素首地址 &b代表的是整个数组的地址

### 数据类型的封装

- void的字面意思时“无类型”，void *则为“无类型指针”，void *可以指向任何类型的数据

- void用法

  - 数据类型的封装 int initHardEnv(void **handle);
  - 典型的如内存操作函数memcpy和memset的函数原型分别为
  - void * memcpy(void *dest, const void * src, size_t len);
  - void * memset(void *buffer, int c, size_t num);
  - 用法2：void修饰函数返回值和参数，仅表示无
  - 如果函数没有返回值，那么应该将其声明为void
  - 如果函数没有参数，应该声明其参数为void  int function(void)

- void指针的意义

  - C语言规定只有相同类型的指针才可以相互赋值
  - void * 指针作为左值用于“接收”任意类型的指针
  - void * 指针作为右值赋值给其它指针时需要强制类型转换

  ```c
  int *p1 = NULL;
  char *p2 = (char*)malloc(sizeof(char)*20);
  ```

- 不存在void类型的变量：C语言没有定义void究竟时多大内存的别名

## 变量本质分析

### 变量概念

- 概念：既能读又能写的内存对象，称为变量；若一旦初始化后不能修改的对象则称为常量

- 变量定义形式： 类型 标识符,标识符,...,标识符;

  ```c
  int x;
  int wordCut, weight, height;
  double speed, time;
  ```

### 变量本质

- 程序通过变量来申请和命名内存空间 int a = 0;
- 通过变量名访问内存空间：（一段连续）内存空间的别名（是一个门牌号）
- 修改变量的几种方法

```c
// 直接
int a;
a  = 10;
//间接赋值。内存有地址编号，拿到地址编号也可以修改内存；于是横空出世了指针
*((int*)123456) = 20;
//内存空间可以再取别名吗？C++引用
int b = 5;
int& ref = b;
ref = 8; //b的值变成了8
```

- 数据类型和变量的关旭：通过数据类型定义变量

## 程序的内存四区模型

### 内存四区的建立流程

- 操作系统把物理硬盘代码load到内存
- 操作系统把c代码分成四个区
- 操作系统找到main函数入口执行

### 函数调用模型

- 一个主程序有n个函数组成，C++编译器会建立有几个堆区，几个栈区
- 函数嵌套调用是，实参地址传给行参后，C++编译器如何管理变量的生命周期
- main -> fa -> fb main函数调用fa, fa函数调用函数fb
- main函数中可以在栈分配内存/可以在堆上分配内存，全局区分配内存。都可以被fa, fb使用
- fb申请的内存可以被main使用吗》
- fb中在栈上分配的内存，不能被fa和main函数使用
- fb中malloc的内存（堆），可以被main和fb函数使用
- fb中全局区分配内存，可以被main和fb函数使用

## 指针

### 指针是一种数据类型

- 指针也是一种变量，占用内存空间，用来保存内存地址

- *p操作内存

  - 在指针声明时，*号表示所声明的变量为指针
  - 在指针使用时，*号表示操作指针所指向的内存空间中的值
  - *p相当于通过地址(p变量的值)找到一块内存；然后操作内存
  - *p放在等号左边赋值（给内存赋值）
  - *p放在等号右边取值（从内存获取值）

- 指针变量和它指向的内存块是两个不同的概念

  - 给p赋值 p = 0x1111只会改变指针变量值，不会改变所指的内容
  - 给*p赋值 *p = 'a'; 不会改变指针变量的值，只会改变所指的内存块的值
  - =左边 *p表示给内存赋值， =右边 *p 表示取值

  ```c
  int a = 10;
  int *p = NULL;
  p = &a;
  *p = 20; //间接修改a的值 *p放在左边 写内存
  // *就像一把钥匙通过一个地址(&a),去修改a变量标示的内存空间
  int c = 0;
  c = *p; //c=20, *p放在右边 读内存
  ```

- 指针是一种数据类型，是指它指向的内存空间的数据类型

  - 指针步长(p++),根据所指内存空间数据类型来确定
  - p++ = (unsigned char)p + sizeof(a);
  - 指针的步长，根据所指内存空间类型来定
  - 建立指针指向谁，就把谁的地址赋值给指针
  - 不断的给指针变量赋值，就是不断的改变指针变量（和所指内存空间没有任何关系）

### 间接赋值(*p)是指针存在的最大意义

- 两码事：指针变量和它所指向的内存块变量

- 条件反射：指针指向某个变量，就把某个变量地址赋给指针

- *p间接赋值成立的3个条件

  - 两个变量（一个实参，一个形参）
  - 建立关系，实参取地址赋给形参指针
  - *p 形参去间接修改实参的值

  ```c
  int num = 0; //实参
  int *p = NULL; //形参
  p = &num;
  *p = 2; //通过*p形参 === 间接改变实参的值
  ```

- 引申：函数调用时，用n级指针(形参)改变n-1级指针(实参)的值

  - 指针做函数参数 形参有多级指针的时候，站在编译器的角度，只需要分配4字节(32bit平台)或8字节(64bit平台)；当我们使用的时候，我们才关心指针所指向的内存是一维的还是二维的
  - 指针做函数参数的精髓：函数调用时，形参传给实参，用实参取地址，传给形参，在被调用函数里面用*p来改变实参，把运算结果传出去

### 理解指针必须和内存四区概念相结合

- 野指针产生的原因：释放了指针所指向的内存空间，但是指针变量本身没有重置成null

- 避免方法： 

  - 定义指针的时候 初始化成NULL 
  - 释放指针所指向的内存空间后，把指针重置程NULL

  ```c
  char *p = NULL;
  p = (char *)malloc(100);
  if (p == NULL) return;
  strcpy(p, "abcd");
  printf("p: %s\n", p);
  if (p != NULL) {
    free(p);
    p = NULL;
  }
  ```

- 