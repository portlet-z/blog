## 栈

### 栈的基本操作

- InitStack(&S):初始化栈。构造一个空栈S,分配内存空间

- DestroyStack(&S):销毁栈。销毁并释放栈S所占用的内存空间

- Push(&S,x):进栈，若栈S未满，则将x加入使之成为新栈顶

- Pop(&S,&x):出栈，若栈S非空，则弹出栈顶元素，并用x返回。

- GetTop(S,&x):读栈顶元素。若栈S非空，则用x返回栈顶元素

- n个不同元素进栈，出栈元素不同排列的个数为$\frac{1}{n+1}C^n_{2n}$,上述公式称为卡特兰数(Catalan)

### 初始化操作

```cpp
#define MaxSize 10           //定义栈中元素的最大个数
typedef struct{
    ElemType data[MaxSize];  //静态数组存放栈中元素
    int top;                 //栈顶指针
}SqStack;
//初始化栈
void InitStack(SqStack &S) {
    S.top = -1;
}
//判断栈空
bool StackEmpty(SqStack S) {
    return S.top == -1;
}
```

### 进栈操作

```cpp
bool Push(SqStack& S, ElemType x) {
    if (S.top==MaxSize-1) {  //栈满，报错
        return false;
    }
    S.top = S.top + 1;       //指针先加1
    S.data[S.top] = x;       //新元素入栈
    return true;
}
```

### 出栈操作

```cpp
bool Pop(SqStack& S, ElemType& x) {
    if (S.top == -1) {  //栈空，报错
        return false;
    }
    x = S.data[S.top];  //栈顶元素先出栈
    S.top = S.top - 1;  //指针再减1
    return true;
}
```

### 读栈顶元素

```cpp
bool GetTop(SqStack S, ElemType& x) {
    if (S.top == -1) {
        return false;
    }
    x = S.data[S.top];
    return true;
}
```

## 共享栈

- 两个栈共享同一片空间

```cpp
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize];   //静态数组存放栈中元素
    int top0;                 //0好栈顶指针
    int top1;                 //1号栈顶指针
} ShStack;
//初始化栈
void InitStack(ShStack& S) {
    S.top0 = -1;
    S.top1 = MaxSize;
}
//栈满的条件
top0 + 1 == top1;
```

## 链栈的定义

```cpp
typedef struct LinkNode{
    ElemType data;           //数据域
    struct LinkNode* next;   //指针域
}*LinkStack;                 //栈类型定义
```

## 队列

### 队列的基本操作

- InitQueue(&Q):初始化队列，构造一个空队列Q

- DestroyQueue(&Q):销毁队列。销毁并释放队列Q所占用的内存空间

- EnQueue(&Q, x):入队，若队列Q未满，将x加入，使之成为新的队尾

- DeQueue(&Q, &x):出队，若队列Q非空，删除队头元素，并用x返回

- GetHead(Q, &x):读队头元素，若队列Q非空，则将队头元素赋值给x

### 队列的顺序实现

```cpp
#define MaxSize 10
typedef struct {
    ElemType data[MaxSize]; //用静态数组存放队列元素
    int front, rear;        //rear执行队尾元素的后一个位置，front指向队头元素
}
void InitQueue(SqQueue& Q) {
    Q.rear = 0;
    Q.front = 0;
}
bool QueueEmpty(SqQueue Q) {
    return Q.rear == Q.front;
}
//入队
bool EnQueue(SqQueue& Q, ElemType x) {
    if((Q.rear+1)%MaxSize == Q.front) {  //队列已满
        return false;
    }
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MaxSize;
    return true;
}
//出队
bool DeQueue(SqQueue& Q, ElemType& x) {
    if(Q.rear == Q.front) {  //队列为空
        return false;
    }
    x = Q.data[Q.front];
    Q.front = (Q.front+1) % MaxSize;
    return true;
}
//获得队头元素的值，并用x返回
bool GetHead(SqQueue Q, ElemType& x) {
    if (Q.rear == Q.front) {
        return false;
    }
    x = Q.data[Q.front];
    return true;
}
```

### 队列的链式实现

```cpp
typedef struct LinkNode{     //链式队列节点
    ElemType data;
    struct LinkNode* next;
}LinkNode;
typedef struct {             //链式队列
    LinkNode *front, *rear;  //队列的队头和队尾指针
}LinkQueue;
//初始化队列（带头结点）
void InitQueue(LinkQueue& Q) {
    //初始化时front,rear都指向头结点
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}
```

## 栈的应用

### [括号匹配](http://assets.processon.com/chart_image/624d36a9637689075c5d0b8e.png)

- 匹配失败情况：①左括号单身②右括号单身③左右括号不匹配

- 用栈实现括号匹配：一次扫描所有字符，遇到左括号入栈，遇到右括号弹出栈顶元素检查是否匹配

```cpp
bool bracketCheck(char str[], int length) {
    SqStack S;
    InitStack(S);
    for(int i=0; i<length; i++) {
        if (str[i] == '(' || str[i] == '[' || str[i] == '{') {
            Push(S, str[i]);
        } else {
            if (StackEmpty(S)) {
                return false;
            }
            char topElem;
            Pop(S, topElem);
            if(str[i] == ')' && topElem != '(') {
                return false;
            }
            if(str[i] == ']' && topElem != '[') {
                return false;
            }
            if(str[i] == '}' && topElem != '{') {
                return false;
            }
        }
    }
    return StackEmpty(S);
}
```
