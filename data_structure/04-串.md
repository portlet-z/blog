## 串的基本操作

- 假设有串T="", S="iPhone 11 Pro Max?", W="Pro"

- StrAssign(&T, chars):赋值操作。把串T赋值为chars

- StrCopy(&T,S):复制操作。由串S复制得到串T

- StrEmpty(S):判空操作。若S为空串，则返回true,否则返回false

- StrLength(S):求串长。返回串S的元素个数

- ClearString(&S):清空操作。将S清为空串

- DestroyString(&S):销毁串。将串S销毁(回收存储空间)

- Concat(&T, S1, S2):串联接。用T返回由S1和S2联接而成的新串

- SubString(&Sub, S, pos, len):求子串。用Sub返回串S的第pos个字符起长度为len的子串

- Index(S, T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0

- StrCompare(S,T):比较操作。若S>T,则返回值>0;S=T返回0，S<T返回值<0

## 串的顺序存储

```cpp
#define MAXLEN 255      //预定义最大串长255
typedef struct {
    char ch[MAXLEN];    //每个分量存储一个字符
    int length;         //串的实际长度
}SString;

typedef struct {
    char *ch;           //按串长度分配存储区，ch指向串的基地址
    int length;         //串的长度
}HString;

HString S;
S.ch = (char *)malloc(MAXLEN * sizeof(char));
```

### 串的链式存储

```cpp
typedef struct StringNode{
    char ch;                //每个节点存1个字符
    struct StringNode* next;
}StringNode, *String;       //存储密度低，每个字符串1B,每个指针4B
typedef struct StringNode{
    char ch[4];
    struct StringNode* next; //存储密度提高
}
```

### 基本操作的实现

- SubString(&Sub, S, pos, len):求子串。用Sub返回串S的第pos个字符起长度为len的子串

```cpp
#define MAXLEN 255
type struct{
    char ch[MAXLEN];
    int length;
}
bool SubString(SString &Sub, SString S, int pos, int len) {
    if(pos+len-1 > S.length) {
        return false;
    }
    for(int i=pos; i<pos+len; i++) {
        Sub.ch[i-pos+1] = S.ch[i];
    }
    Sub.length = len;
    return true;
}
```

- StrCompare(S, T):比较操作。

```cpp
int StrCompare(SString S, SString T) {
    for (int i=0; i<=S.length && i<=T.length; i++) {
        if (S.ch[i] != T.ch[i]) {
            return S.ch[i] - T.ch[i];
        }
    }
    //扫描过的所有字符都相同，则长度长的串更大
    return S.length-T.length;
}
```

- Index(S, T):定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则返回函数值0 -- 朴素模式匹配算法

```cpp
int Index(SString S, SString T) {
    int i=1; n=StrLength(S); m=StrLength(T);
    SString sub; 
    while(i<=n-m+1) {
        SubString(sub, S, i, m);
        if(StrCompare(sub, T) != 0) {
            ++i;
        } else {
            return i; //返回子串在主串中的位置
        }
    }
    return 0;  //S中不存在与T相等的子串
}
```

- 朴素模式匹配算法的缺点：当某些子串与模式串能部分匹配时，主串的扫描指针i经常回溯，导致时间开销增加

- 改进思路：主串指针不回溯，只有模式串指针回溯。

- KMP算法代码

```cpp
int Index_KMP(SString S, SString T, int next[]) {
    int i=1, j=1;
    while(i<=S.length && j<=T.length) {
        if (j==0 || S.ch[i] == T.ch[j]) {
            ++i;
            ++j;          //继续比较后继字符
        } else {
            j = next[j];  //模式串向右移动
        }
    }
    if (j > T.length) {
        return i - T.length;  //匹配成功
    } else {
        return 0;
    }
}
```
