## 1. 类文件结构

一个简单的HelloWorld.java

```java
package com.bytebuf.t2;

public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

执行`javac -parameters -d . HelloWorld.java`

编译为HelloWorld.class文件为：用`od -t xC HelloWorld.class`

```
0000000    ca  fe  ba  be  00  00  00  34  00  1f  0a  00  06  00  11  09
0000020    00  12  00  13  08  00  14  0a  00  15  00  16  07  00  17  07
0000040    00  18  01  00  06  3c  69  6e  69  74  3e  01  00  03  28  29
0000060    56  01  00  04  43  6f  64  65  01  00  0f  4c  69  6e  65  4e
0000100    75  6d  62  65  72  54  61  62  6c  65  01  00  04  6d  61  69
0000120    6e  01  00  16  28  5b  4c  6a  61  76  61  2f  6c  61  6e  67
0000140    2f  53  74  72  69  6e  67  3b  29  56  01  00  10  4d  65  74
0000160    68  6f  64  50  61  72  61  6d  65  74  65  72  73  01  00  04
0000200    61  72  67  73  01  00  0a  53  6f  75  72  63  65  46  69  6c
0000220    65  01  00  0f  48  65  6c  6c  6f  57  6f  72  6c  64  2e  6a
0000240    61  76  61  0c  00  07  00  08  07  00  19  0c  00  1a  00  1b
0000260    01  00  0b  48  65  6c  6c  6f  20  77  6f  72  6c  64  07  00
0000300    1c  0c  00  1d  00  1e  01  00  19  63  6f  6d  2f  62  79  74
0000320    65  62  75  66  2f  74  32  2f  48  65  6c  6c  6f  57  6f  72
0000340    6c  64  01  00  10  6a  61  76  61  2f  6c  61  6e  67  2f  4f
0000360    62  6a  65  63  74  01  00  10  6a  61  76  61  2f  6c  61  6e
0000400    67  2f  53  79  73  74  65  6d  01  00  03  6f  75  74  01  00
0000420    15  4c  6a  61  76  61  2f  69  6f  2f  50  72  69  6e  74  53
0000440    74  72  65  61  6d  3b  01  00  13  6a  61  76  61  2f  69  6f
0000460    2f  50  72  69  6e  74  53  74  72  65  61  6d  01  00  07  70
0000500    72  69  6e  74  6c  6e  01  00  15  28  4c  6a  61  76  61  2f
0000520    6c  61  6e  67  2f  53  74  72  69  6e  67  3b  29  56  00  21
0000540    00  05  00  06  00  00  00  00  00  02  00  01  00  07  00  08
0000560    00  01  00  09  00  00  00  1d  00  01  00  01  00  00  00  05
0000600    2a  b7  00  01  b1  00  00  00  01  00  0a  00  00  00  06  00
0000620    01  00  00  00  07  00  09  00  0b  00  0c  00  02  00  09  00
0000640    00  00  25  00  02  00  01  00  00  00  09  b2  00  02  12  03
0000660    b6  00  04  b1  00  00  00  01  00  0a  00  00  00  0a  00  02
0000700    00  00  00  09  00  08  00  0a  00  0d  00  00  00  05  01  00
0000720    0e  00  00  00  01  00  0f  00  00  00  02  00  10            
0000735
```

根据JVM规范，类文件结构如下

```java
ClassFile {
  u4               magic;
  u2               minor_version;
  u2               major_version;
  u2               const_pool_count;
  cp_info          const_pool[const_pool_count-1];
  u2               access_flags;
  u2               this_class;
  u2               super_class;
  u2               interfaces_count;
  u2               interfaces[interfaces_count];
  u2               fields_count;
  field_info       fields[fields_count];
  u2               methods_count;
  method_info      methods[methods_count];
  u2               attributes_count;
  attribute_info   attributes[attributes_count];
}
```

### 1.1 魔数

- 0-3 字节，表示它是否是【class】类型的文件

0000000    <span style='color: red'>ca  fe  ba  be</span>  00  00  00  34  00  1f  0a  00  06  00  11  09

### 1.2 版本

- 4-7 字节，表示类的版本00 34 (52) 表示是Java 8

0000000    ca  fe  ba  be  <span style='color: red'>00  00  00  34</span>  00  1f  0a  00  06  00  11  09

### 1.3 常量池

| Constant Type               | Value   |
| --------------------------- | ------- |
| CONSTANT_Class              | 7 (07)  |
| CONSTANT_Fieldref           | 9 (09)  |
| CONSTANT_Methodref          | 10 (0a) |
| CONSTANT_InterfaceMethodref | 11 (0b) |
| CONSTANT_String             | 8 (08)  |
| CONSTANT_Integer            | 3 (03)  |
| CONSTANT_Float              | 4 (04)  |
| CONSTANT_Long               | 5 (05)  |
| CONSTANT_Double             | 6 (06)  |
| CONSTANT_NameAndType        | 12 (0c) |
| CONSTANT_Utf8               | 1 (01)  |
| CONSTANT_MethodHandle       | 15 (0f) |
| CONSTANT_MethodType         | 16 (10) |
| CONSTANT_InvokeDynamic      | 18 (12) |

- 8-9 字节，表示常量池长度 00 1f (31)表示常量池有#1-#30项，注意#0项不计入，也没有值

0000000    ca  fe  ba  be  00  00  00  34 <span style='color: red'> 00  1f </span> 0a  00  06  00  11  09

- 第#1项 0a表示一个Method信息，00 06 00 11(17) 表示它引用了常量池中#6和#17项来获得这个方法的【所属类】和【方法名】

0000000    ca  fe  ba  be  00  00  00  34 00  1f  <span style='color: red'>0a  00  06  00  11</span>  09

- 第#2项09表示一个Field信息，00 12(18) 和 00 13（19）表示它引用了常量池中#18和#19项来获得这个成员变量的【所属类】和【成员变量名】

0000000    ca  fe  ba  be  00  00  00  34  00  1f  0a  00  06  00  11  <span style='color: red'> 09 </span>
0000020    <span style='color: red'>00 12 00  13</span>   08  00  14  0a  00  15  00  16  07  00  17  07

- 第#3项08表示一个字符串常量名，00 14（20）表示它引用了常量池中#20项

0000020    00 12 00  13  <span style='color: red'>08  00  14</span>  0a  00  15  00  16  07  00  17  07

- 第#4项0a表示一个Method信息，00 15（21） 和 00 16（22）表示它引用了常量池中#21和#22项来获得这个方法的【所属类】和【方法名】

0000020    00 12 00  13  08  00  14  <span style='color: red'>0a  00  15  00  16</span>  07  00  17  07

- 第#5项07表示一个Class信息，00 17（23）表示它引用了常量池中#23项

0000020    00 12 00  13  08  00  14  0a  00  15  00  16  <span style='color: red'>07  00  17</span>  07

- 第#6项07表示一个Class信息，00 18（24）表示它引用了常量池中#24项

0000020    00  12  00  13  08  00  14  0a  00  15  00  16  07  00  17  <span style='color: red'>07</span>
0000040     <span style='color: red'>00  18</span>  01  00  06  3c  69  6e  69  74  3e  01  00  03  28  29

- 第#7项01表示一个utf8串，00 06表示长度，  3c  69  6e  69  74  3e是【<init>】

0000040     00  18  <span style='color: red'>01  00  06  3c  69  6e  69  74  3e</span>  01  00  03  28  29

- 第#8项01表示一个utf8串，00 03表示长度 28 29 56是【()V】其实就是表示无参，无返回值

0000040     00  18  01  00  06  3c  69  6e  69  74  3e <span style='color: red'> 01  00  03  28  29</span>

0000060   <span style='color: red'>  56</span>  01  00  04  43  6f  64  65  01  00  0f  4c  69  6e  65  4e

- 第#9项01表示一个utf8串，00 04表示长度 43 6f 64 65是【Code】

0000060     56 <span style='color: red'> 01  00  04  43  6f  64  65</span>  01  00  0f  4c  69  6e  65  4e

- 第#10项01表示一个utf8串，00 0f（15）表示长度01   00  0f  4c  69  6e  65  4e 75  6d  62  65  72  54  61   62  6c  65是【LineNumberTable】

0000060     56 01  00  04  43  6f  64  65  <span style='color: red'> 01   00  0f  4c  69  6e  65  4e</span>

0000100    <span style='color: red'>75  6d  62  65  72  54  61   62  6c  65</span>  01  00  04  6d  61  69

- 第#11项01表示一个utf8串，00 04表示长度 6d 61 69 6e是【main】

0000100    75  6d  62  65  72  54  61   62  6c  65 <span style='color: red'> 01  00  04  6d  61  69</span>

0000120    <span style='color: red'>6e</span>  01  00  16  28  5b  4c  6a  61  76  61  2f  6c  61  6e  67

- 第#12项01表示一个utf8串，00 16(22)表示长度28  5b  4c  6a  61  76  61  2f  6c  61  6e  67 2f  53  74  72  69  6e  67  3b  29  56是【([Ljava/lang/String;)V】

0000120    6e  <span style='color: red'>01  00  16  28  5b  4c  6a  61  76  61  2f  6c  61  6e  67</span>

0000140    <span style='color: red'> 2f  53  74  72  69  6e  67  3b  29  56</span>  01  00  10  4d  65  74

- 第#13项01表示一个utf8串00 10（16）表示长度4d  65  74 68  6f  64  50  61  72  61  6d  65  74  65  72  73是【MethodParameters】

0000140    2f  53  74  72  69  6e  67  3b  29  56<span style='color: red'> 01  00  10  4d  65  74</span>  

0000160    <span style='color: red'>68  6f  64  50  61  72  61  6d  65  74  65  72  73</span>  01  00  04

- 第#14项01表示一个utf8串，00 04表示长度 61 72 67 73是【args】

0000160    68  6f  64  50  61  72  61  6d  65  74  65  72  73  <span style='color: red'>01  00  04</span>

0000200    <span style='color: red'>61  72  67  73</span>  01  00  0a  53  6f  75  72  63  65  46  69  6c

- 第#15项01表示一个utf8串，00 0a(10)表示长度53  6f  75  72  63  65  46  69  6c 65是【SourceFile】

0000200    61  72  67  73  <span style='color: red'>01  00  0a  53  6f  75  72  63  65  46  69  6c</span> 

0000220    <span style='color: red'>65</span>   01  00  0f  48  65  6c  6c  6f  57  6f  72  6c  64  2e  6a

- 第#16项01表示一个utf8串，00 0f（15）表示长度 48  65  6c  6c  6f  57  6f  72  6c  64  2e  6a  61  76  61是【HelloWorld.java】

0000220    65  <span style='color: red'>01  00   0f   48   65  6c  6c  6f  57  6f  72   6c  64  2e   6a</span> 

0000240    <span style='color: red'>61   76   61</span>   0c  00  07  00  08  07  00  19  0c  00  1a  00  1b

- 第#17项0c(12)表示一个【名+类型】，00 07 00 08表示引用了常量池中#7 #8两项

0000240    61   76   61 <span style='color: red'> 0c  00  07  00  08  </span> 07  00  19  0c  00  1a  00  1b

- 第#18项07表示一个Class信息，00 19（25）引用了常量池中#25项

0000240    61   76   61  0c  00  07  00  08 <span style='color: red'> 07  00  19 </span>  0c  00  1a  00  1b

- 第#19项0c(12)表示一个【名+类型】， 00 1a 00 1b表示引用了常量池中#26 #27两项

0000240    61   76   61  0c  00  07  00  08 07  00  19  <span style='color: red'> 0c  00  1a  00  1b </span>

- 第#20项01表示一个utf8串，00 0b(11)表示长度48  65  6c  6c  6f  20  77  6f  72  6c  64是【Hello world】

0000260   <span style='color: red'>  01  00  0b  48  65  6c  6c  6f  20  77  6f  72  6c  64</span>  07  00

- 第#21项07表示一个Class信息， 00 1c(28)引用了常量池中#28项

0000260    01  00  0b  48  65  6c  6c  6f  20  77  6f  72  6c  64  <span style='color: red'>07  00</span> 
0000300    <span style='color: red'>1c</span>   0c  00  1d  00  1e  01  00  19  63  6f  6d  2f  62  79  74

- 第#22项0c(12)表示一个【名+类型】，00 1d 00 1e表示引用了常量池中#29 #30两项

0000300    1c <span style='color: red'> 0c  00  1d  00  1e</span>   01  00  19  63  6f  6d  2f  62  79  74

- 第#23项01表示一个utf8串，00 19（25）表示长度，表示【com/bytebuf/t2/HelloWorld】

0000300    1c 0c  00  1d  00  1e <span style='color: red'> 01  00  19  63  6f  6d  2f  62  79  74</span> 
0000320    <span style='color: red'>65  62  75  66  2f  74  32  2f  48  65  6c  6c  6f  57  6f  72</span> 
0000340   <span style='color: red'> 6c  64</span>    01  00  10  6a  61  76  61  2f  6c  61  6e  67  2f  4f

- 第#24项01表示一个utf8串，00 10（16）表示长度6a  61  76  61  2f  6c  61  6e  67  2f  4f  62  6a  65  63  74是【java/lang/Object】

0000340   6c  64  <span style='color: red'> 01  00  10  6a  61  76  61  2f  6c  61  6e  67  2f  4f</span> 

0000360   <span style='color: red'>62  6a  65  63  74</span>   01  00  10  6a  61  76  61  2f  6c  61  6e

- 第#25项01表示一个utf8串，00 10（16）表示长度6a  61  76  61  2f  6c  61  6e  67  2f  53  79  73 74  65  6d是【java/lang/System】

0000360   62  6a  65  63  74  <span style='color: red'>01  00  10  6a  61  76  61  2f  6c  61  6e</span> 

0000400   <span style='color: red'>67  2f  53  79  73 74  65  6d </span> 01  00  03  6f  75  74  01  00

- 第#26项01表示一个utf8串，00 03表示长度  6f  75  74 是【out】

0000400   67  2f  53  79  73 74  65  6d<span style='color: red'> 01  00  03  6f  75  74 </span>  01  00

- 第#27项01表示一个utf8串，00 15（21）表示长度，【Ljava/io/PrintStream;】

0000400   67  2f  53  79  73 74  65  6d  01  00  03  6f  75  74 <span style='color: red'> 01  00 </span> 
0000420   <span style='color: red'>15  4c  6a  61  76  61  2f  69  6f  2f  50  72  69  6e  74  53</span>
0000440   <span style='color: red'>74  72  65  61  6d  3b </span> 01  00  13  6a  61  76  61  2f  69  6f

- 第#28项01表示一个utf8串，00 13 （19）表示长度【java/io/PrintStream】

0000440  74  72  65  61  6d  3b <span style='color: red'>01  00  13  6a  61  76  61  2f  69  6f </span> 

0000460  <span style='color: red'>2f  50  72  69  6e  74  53  74  72  65  61  6d</span>   01  00  07  70

- 第#29项01表示一个utf8串，00 07表示长度，【println】

0000460  2f  50  72  69  6e  74  53  74  72  65  61  6d <span style='color: red'> 01  00  07  70</span>  

0000500  <span style='color: red'>72  69  6e  74  6c  6e</span>  01  00  15  28  4c  6a  61  76  61  2f

- 第#30项01表示一个utf8串，00 15（21）表示长度，【(Ljava/lang/String;)V】

0000500  72  69  6e  74  6c  6e  <span style='color: red'>01  00  15  28  4c  6a  61  76  61  2f</span>  

0000520  <span style='color: red'>6c  61  6e  67  2f  53  74  72  69  6e  67  3b  29  56</span>  00  21

### 1.4 访问标识与继承信息

- 00 21表示该class是一个类，公共的

0000520  6c  61  6e  67  2f  53  74  72  69  6e  67  3b  29  56<span style='color: red'>  00  21</span> 

| Flag Name      | Value  | Interpretation                                               |
| -------------- | ------ | ------------------------------------------------------------ |
| ACC_PUBLIC     | 0x0001 | Declared public;may beaccessed from outside its package      |
| ACC_FINAL      | 0x0010 | Declared final; no subclass allowed                          |
| ACC_SUPER      | 0x0020 | Treat superclass methods specially when invoked by the invokespecial instruction |
| ACC_INTERFACE  | 0x0200 | Is an interface, not a class                                 |
| ACC_ABSTRACT   | 0x0400 | Declared abstract, must not be instantiated                  |
| ACC_SYNTHETIC  | 0x1000 | Declared synthetic; not present in the source code           |
| ACC_ANNOTATION | 0x2000 | Declared as an annotation type                               |
| ACC_ENUM       | 0x4000 | Declared as an enum type                                     |

- 00 05表示根据常量池中#5找到本类全限定名

0000540  <span style='color: red'> 00  05</span>  00  06  00  00  00  00  00  02  00  01  00  07  00  08

- 00 06根据常量池中#6找到父类全限定名

0000540  00  05 <span style='color: red'> 00  06</span>  00  00  00  00  00  02  00  01  00  07  00  08

- 00 00表示接口的数量，本类为0

0000540  00  05  00  06 <span style='color: red'> 00  00 </span> 00  00  00  02  00  01  00  07  00  08

### 1.5 Field信息

- 00 00表示成员变量数量，本类为0

0000540  00  05  00  06 00  00 <span style='color: red'> 00  00 </span>  00  02  00  01  00  07  00  08

| FieldType    | Type      | Interpretation                                               |
| ------------ | --------- | ------------------------------------------------------------ |
| B            | byte      | signed byte                                                  |
| C            | char      | Unicode character code point in the Basic Multilingual Plane, enocded with UTF-16 |
| D            | double    | double-precision floating-point value                        |
| F            | float     | single-precision floation-point value                        |
| I            | int       | Integer                                                      |
| J            | long      | long integer                                                 |
| L ClassName; | reference | an instance of class ClassName                               |
| S            | short     | signed short                                                 |
| Z            | boolean   | true of false                                                |
| [            | reference | one array dimension                                          |

### 1.6 Method信息

- 00 02表示方法数量，本类为2

0000540  00  05  00  06 00  00 00  00 <span style='color: red'> 00  02  </span> 00  01  00  07  00  08

- 一个方法由访问修饰符，名称，参数描述，方法属性数量，方法属性组成
- 00 01表示访问修饰符，public

0000540  00  05  00  06 00  00 00  00 00  02 <span style='color: red'>00  01  </span> 00  07  00  08

- 00 07表示引用了常量池中#07项作为方法名称【<init>】

0000540  00  05  00  06 00  00 00  00 00  02  00  01  <span style='color: red'>00  07  </span> 00  08

- 00 08表示引用了常量池中#08项作为方法参数描述【()V】

0000540  00  05  00  06 00  00 00  00 00  02  00  01  00  07  <span style='color: red'>00  08 </span>

- 00 01表示方法属性数量

0000560   <span style='color: red'> 00  01</span>  00  09  00  00  00  1d  00  01  00  01  00  00  00  05

- 00 09表示引用了常量池中#09项作为方法属性【Code】

0000560  00  01  <span style='color: red'> 00  09</span>   00  00  00  1d  00  01  00  01  00  00  00  05

- 00 00 00 1d(29)表示此属性的长度为29

0000560  00  01  00  09 <span style='color: red'>  00  00  00  1d</span>   00  01  00  01  00  00  00  05

- 00 01表示【操作数栈】的最大深度

0000560  00  01  00  09  00  00  00  1d <span style='color: red'> 00  01</span>  00  01  00  00  00  05

- 00 01表示【局部变量表】最大槽（slot）数

0000560  00  01  00  09  00  00  00  1d  00  01 <span style='color: red'>00  01</span>  00  00  00  05

- 00 00 00 05表示字节码长度

0000560  00  01  00  09  00  00  00  1d  00  01 00  01 <span style='color: red'> 00  00  00  05</span>

- 2a b7 00 01 b1是字节码指令

0000600   <span style='color: red'> 2a  b7  00  01  b1</span>  00  00  00  01  00  0a  00  00  00  06  00

- 00 00 00 01表示方法细节属性数量

0000600  2a  b7  00  01  b1 <span style='color: red'>00  00  00  01</span>   00  0a  00  00  00  06  00

- 00 0a表示引用了常量池#10项，发现是【LineNumberTable】

0000600  2a  b7  00  01  b100  00  00  01 <span style='color: red'>00  0a</span>  00  00  00  06  00

- 00 00 00 06表示此属性的总长度

0000600  2a  b7  00  01  b100  00  00  0100  0a <span style='color: red'>00  00  00  06 </span> 00

- 00 01表示【LineNumberTable】长度

0000600  2a  b7  00  01  b100  00  00  0100  0a  00  00  00  06 <span style='color: red'>00 </span>

0000620   <span style='color: red'>01 </span>  00  00  00  07  00  09  00  0b  00  0c  00  02  00  09  00

- 00 00 表示【字节码】行号， 00 07表示【java源码行号】

0000620   01 <span style='color: red'> 00  00  00  07</span>  00  09  00  0b  00  0c  00  02  00  09  00

- 00 09表示访问修饰符public static

0000620   01 00  00  00  07 <span style='color: red'>  00  09</span>   00  0b  00  0c  00  02  00  09  00

- 00 0b 表示方法名称，引用了常量池#11项【main】

0000620   01 00  00  00  07   00  09 <span style='color: red'> 00  0b</span>   00  0c  00  02  00  09  00

- 00 0c表示引用了常量池中#12项作为方法参数描述【([Ljava/lang/String;)V】

0000620   01 00  00  00  07   00  09 00  0b<span style='color: red'>  00  0c </span> 00  02  00  09  00

- 00 02表示方法属性数量

0000620   01 00  00  00  07   00  09 00  0b  00  0c <span style='color: red'> 00  02 </span> 00  09  00

- 00 09表示引用了常量池中#09项作为方法属性【Code】

0000620   01 00  00  00  07   00  09 00  0b  00  0c  00  02 <span style='color: red'> 00  09 </span>  00

- 00 00 00 25(37)表示此属性的长度为37

0000620   01 00  00  00  07   00  09 00  0b  00  0c  00  02  00  09 <span style='color: red'>  00 </span>

0000640   <span style='color: red'>00  00  25  </span> 00  02  00  01  00  00  00  09  b2  00  02  12  03

- 00 02表示【操作数栈】的最大深度
- 00 01表示【局部变量表】最大槽（slot）数

0000640   00  00  25 <span style='color: red'> 00  02  00  01 </span>  00  00  00  09  b2  00  02  12  03

- 00 00 00 09表示字节码指令长度，b2  00  02  12  03  b6  00  04  b1是字节码指令

0000640   00  00  25  00  02  00  01 <span style='color: red'>00  00  00  09  b2  00  02  12  03 </span> 

0000660  <span style='color: red'>b6  00  04  b1 </span>   00  00  00  01  00  0a  00  00  00  0a  00  02

- 00 00 00 01表示方法细节属性属性

0000660  b6  00  04  b1 <span style='color: red'> 00  00  00  01</span>  00  0a  00  00  00  0a  00  02

- 00 0a表示引用了常量池#10项，【LineNumberTable】

0000660  b6  00  04  b1  00  00  00  01  <span style='color: red'>00  0a </span> 00  00  00  0a  00  02

- 00 00 00 0a表示此属性的总长度，本例10

0000660  b6  00  04  b1  00  00  00  01  00  0a  <span style='color: red'>00  00  00  0a  </span>  00  02

- 00 02表示【LineNumberTable】长度

0000660  b6  00  04  b1  00  00  00  01  00  0a  00  00  00  0a<span style='color: red'>  00  02  </span>

- 00 00 表示【字节码】行号， 00 09表示【java源码行号】

0000700    <span style='color: red'>00  00  00  09  </span>  00  08  00  0a  00  0d  00  00  00  05  01  00

- 00 08 表示【字节码】行号， 00 0a表示【java源码行号】

0000700    00  00  00  09  <span style='color: red'> 00  08  00  0a  </span> 00  0d  00  00  00  05  01  00

## 2. 字节码指令

### 2.1 入门

- 构造方法`public HelloWorld();`的字节码指令`2a b7 00 01 b1`
  - 2a => aload_0加载slot 0的局部变量，即this,作为下面的invokespecial构造方法调用的参数
  - b7 => invokespecial预备调用构造方法，
  - 00 01 引用常量池中#1即【java/lang/Object.<init> : ()V】
  - b1表示返回
- 另一个是 public static void main(java.lang.String[]);主方法的字节码指令`b2  00  02  12  03  b6  00  04  b1`
  - b2 => getstatic 用来加载静态变量
  - 00 02 引用常量池中#2即【java/lang/System.out : Ljava/io/PrintStream;】
  - 12 => ldc加载参数
  - 03 引用常量池中#3项即【Hello world】
  - b6 => invokespecial预备调用成员方法
  - 00 04 引用常量池中#4项即【java/io/PrintStream.println : (Ljava/lang/String;)V】
  - b1表示返回

### 2.2 javap

- `javap -v HelloWorld`

```java
Classfile /Users/portlet/Developer/personal/jvm/src/main/java/com/bytebuf/t2/com/bytebuf/t2/HelloWorld.class
  Last modified 2022-6-27; size 477 bytes
  MD5 checksum b9520b10c36afa9d5b6552a94306abb3
  Compiled from "HelloWorld.java"
public class com.bytebuf.t2.HelloWorld
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #6.#17         // java/lang/Object."<init>":()V
   #2 = Fieldref           #18.#19        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #20            // Hello world
   #4 = Methodref          #21.#22        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = Class              #23            // com/bytebuf/t2/HelloWorld
   #6 = Class              #24            // java/lang/Object
   #7 = Utf8               <init>
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               main
  #12 = Utf8               ([Ljava/lang/String;)V
  #13 = Utf8               MethodParameters
  #14 = Utf8               args
  #15 = Utf8               SourceFile
  #16 = Utf8               HelloWorld.java
  #17 = NameAndType        #7:#8          // "<init>":()V
  #18 = Class              #25            // java/lang/System
  #19 = NameAndType        #26:#27        // out:Ljava/io/PrintStream;
  #20 = Utf8               Hello world
  #21 = Class              #28            // java/io/PrintStream
  #22 = NameAndType        #29:#30        // println:(Ljava/lang/String;)V
  #23 = Utf8               com/bytebuf/t2/HelloWorld
  #24 = Utf8               java/lang/Object
  #25 = Utf8               java/lang/System
  #26 = Utf8               out
  #27 = Utf8               Ljava/io/PrintStream;
  #28 = Utf8               java/io/PrintStream
  #29 = Utf8               println
  #30 = Utf8               (Ljava/lang/String;)V
{
  public com.bytebuf.t2.HelloWorld();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String Hello world
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 9: 0
        line 10: 8
    MethodParameters:
      Name                           Flags
      args
}
```

### 2.3图解方法执行流程

- 原始java代码

```java
public class Demo2 {
    public static void main(String[] args) {
        int a = 10;
        int b = Short.MAX_VALUE + 1;
        int c = a + b;
        System.out.println(c);
    }
}
```

- 编译后的的字节码文件`javap -v Demo2`

```java
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        10
         2: istore_1
         3: ldc           #3                  // int 32768
         5: istore_2
         6: iload_1
         7: iload_2
         8: iadd
         9: istore_3
        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        13: iload_3
        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
        17: return
      LineNumberTable:
        line 9: 0
        line 10: 3
        line 11: 6
        line 12: 10
        line 13: 17
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      18     0  args   [Ljava/lang/String;
            3      15     1     a   I
            6      12     2     b   I
           10       8     3     c   I
    MethodParameters:
      Name                           Flags
      args
```

- 常量池载入运行时常量池
- 方法字节码载入方法区
- main线程开始运行，分配栈桢内存（stack=2, locals=4）
- 执行引擎开始执行字节码

![](./images/图解方法执行流程.jpg)

### 2.4 条件判断指令

| 指令 | 助记符    | 含义           |
| ---- | --------- | -------------- |
| 0x99 | ifeq      | 判断是否==0    |
| 0x9a | ifne      | 判断是否!=0    |
| 0x9b | iflt      | 判断是否 < 0   |
| 0x9c | ifge      | 判断是否 >= 0  |
| 0x9d | ifgt      | 判断是否>0     |
| 0x9e | ifle      | 判断是否<=0    |
| 0x9f | if_icmpeq | 两个int是否==  |
| 0xa0 | if_icmpne | 两个int是否!=  |
| 0xa1 | if_cmplt  | 两个int是否<   |
| 0xa2 | if_cmpge  | 两个int是否>=  |
| 0xa3 | if_icmgt  | 两个int是否>   |
| 0xa4 | if_icmle  | 两个int是否<=  |
| 0xa5 | if_acmpeq | 两个引用是否== |
| 0xa6 | if_acmpne | 两个引用是否!= |
| 0xc6 | ifnull    | 判断是否==null |
| 0xc7 | ifnonnull | 判断是否!=null |

- byte, short, char都会按int比较，因为操作数栈都是4字节
- goto用来进行跳转到指定行号的字节码

### 2.5 循环控制指令

### 2.6 构造方法

- <cinit>()V: 编译器会按从上至下的顺序，收集所有static静态代码块和静态成员赋值的代码，合并成为一个特殊的方法<cinit>()V
- <cinit>()V方法会在类加载的初始化阶段被调用
- <init>()V:编译器会按从上至下的顺序，收集所有{}代码块和成员变量赋值的代码，形成新的构造方法，但原始构造方法内的代码总是在最后

### 2.7 方法调用

### 2.8 多态的原理

- `java -cp .lib/sa-jdi.jar sum.jvm.hotspot.HSDB`

### 2.9 异常处理

- javap -v反编译多处理一个Exception table结构，[from, to)是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过type匹配异常类型，进入target所指示行号

## 3. 编译期处理

- 所谓语法糖，其实就是指java编译器把\*.java源码编译为\*.class字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是java编译器给我们的一个额外福利
- 注意，以下代码借助了javap工具，idea的反编译功能，idea插件jclasslib等工具。另外，编译器转换的结果直接就是class字节码，只是为了便于阅读，给出了几乎等于java的源代码，并不是编译器还会转换出中间的java源码

### 3.1 默认构造器

```java
public class Candy1 {}
```

编译后成class后的代码

```java
public class Candy1 {
  //这个无参构造是编译器帮助我们加上的
  public Candy1() {
    super(); //即调用父类Object的无参构造方法，即调用java/lang/Object."<init>":()V
  }
}
```

### 3.2 自动拆装箱

这个特性是JDK5开始加入的，代码片段1

```java
public class Candy2 {
  public static void main(String[] args) {
    Integer x = 1;
    int y = x;
  }
}
```

这段代码在JDK5之前是无法编译通过的，必须改写为代码片段2

```java
public class Candy2 {
  public static void main(String[] args) {
    Integer x = Integer.valueOf(1);
    int y = x.intValue();
  }
}
```

显然之前版本的代码太麻烦了，需要在基本类型和包装类之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在JDK5以后都由编译器阶段完成。即代码片段1都会在编译器被转换为代码片段2

### 3.3 泛型集合取值

泛型也是在JDK5开始加入的特性，但java在编译泛型代码后会执行泛型擦除的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都当做了Object类型来处理

```java
public class Candy3 {
  public static void main(String[] args) {
    List<Integer> list = new ArrayList<>();
    list.add(0); //实际调用的是list.add(Object e);
    Integer x = list.get(0); //实际调用的是Object obj = list.get(int index);
  }
}
```

所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作

```java
//需要将Object转为Integer
Integer x = (Integer)list.get(0));
```

如果前面的x变量类型修改为int基本类型，那么最终生成的字节码是

```java
int x = ((Integer)list.get(0)).intValue();
```

```java
  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: new           #2                  // class java/util/ArrayList
         3: dup
         4: invokespecial #3                  // Method java/util/ArrayList."<init>":()V
         7: astore_1
         8: aload_1
         9: iconst_0
        10: invokestatic  #4                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        13: invokeinterface #5,  2            // InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z
        18: pop
        19: aload_1
        20: iconst_0
        21: invokeinterface #6,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;
        26: checkcast     #7                  // class java/lang/Integer
        29: astore_2
        30: return
      LineNumberTable:
        line 12: 0
        line 13: 8
        line 14: 19
        line 15: 30
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      31     0  args   [Ljava/lang/String;
            8      23     1  list   Ljava/util/List;
           30       1     2     x   Ljava/lang/Integer;
      LocalVariableTypeTable:
        Start  Length  Slot  Name   Signature
            8      23     1  list   Ljava/util/List<Ljava/lang/Integer;>;
    MethodParameters:
      Name                           Flags
      args

```

擦除的是字节码上的泛型信息，可以看到LocalVariableTypeTable任然保留了方法参数泛型的信息

使用泛型仍然能够获得这些信息

### 3.4 可变参数

可变参数也是JDK5开始加入的新特性

```java
public class Candy4 {
  public static void foo(String... args) {
    String[] array = args; //直接赋值
    System.out.println(array);
  }
  public void main(String[] args) {
    foo("hello", "world");
  }
}
```

可变参数String... args其实是一个String[] args,从代码中的赋值语句中就可以看出来。同样java编译器会在编译期间将上述代码变换为

```java
public class Candy4 {
  public static void foo(String[] args) {
    String[] array = args;
    System.out.println(array);
  }
  public static void main(String[] args) {
    foo(new String[]{"hello", "world"});
  }
}
```

注意；如果调用了foo()则等价代码为foo(new String[]{}),创建了一个空的数组，而不会传递null进去

### 3.5 foreach循环

仍是JDK5开始引入的语法糖，数组的循环

```java
public class Candy5_1{
  public static void main(String[] args) {
    int[] array = {1, 2, 3, 4, 5}; //数组赋初值的简化写法也是语法糖
    for(int e : array) {
      System.out.println(e);
    }
  }
}
```

会被编译器转换为
```java
public class Candy5_1 {
  public Candy5_1(){}
  public static void main(String[] args) {
    int[] array = new int[]{1, 2, 3, 4, 5};
    for(int i=0; i<array.length; i++) {
      int e = array[i];
      System.out.println(e);
    }
  }
}
```

而集合的循环：

```java
public class Candy5_2 {
  public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
    for(int i : list) {
      System.out.println(i);
    }
  }
}
```

实际被编译器转换为对迭代器的调用

```java
public class Candy5_2 {
  public Candy5_2(){}
  public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 2, 3, 4, 5);
    Iterator iter = list.iterator();
    while(iter.hasNext()) {
      Integer e = (Integer)iter.next();
      System.out.println(e);
    }
  }
}
```

注意：foreach循环写法，能给配合数组，以及所有实现了Iterable接口的集合类一起使用，其中Iterable用来获取集合的迭代器(Iterator)

### 3.6 switch字符串

从JDK7开始，switch可以作用于字符串和枚举类，这个功能其实也是语法糖，例如

```java
public class Candy6_1 {
  public static void choose(String str) {
    switch(str) {
      case "hello":
 				System.out.println("h");
        break;
      case "world""
        System.out.println("w");
        break;
    }
  }
}
```

注意：switch配合枚举使用时，变量不能为null

会被编译器转换为：

```java
public class Candy6_1 {
  public Candy6_1(){}
  public static void choose(String str) {
    byte x = -1;
    switch(str.hashCode()) {
      case 99162322: // hello的hashCode
        if(str.equals("hello")) {
          x = 0;
        }
        break;
      case 113318802: //world的hashCode
        if(str.equals("world")) {
          x = 1;
        }
        break;
    }
    switch(x) {
      case 0:
        System.out.println("h");
        break;
      case 1:
        System.out.println("w");
        break;
    }
  }
}
```

可以看到执行了两遍switch，第一遍是根据字符串的hashCode和equals将字符串转换为相应的byte类型，第二遍才是利用byte执行进行比较

为什么第一遍必须既比较hashCode,又利用equals比较呢？hashCode是为了提高效率，减少可能的比较；而equals是为了防止hashCode冲入，例如BM和C. ,这两个字符串的hashCode值都是2123，如果有如下的代码

```java
public class Candy6_2 {
  public static void choose(String str) {
    switch(str) {
      case "BM":
        System.out.println("h");
        break;
      case "C.":
        System.out.println("w");
        break;
    }
  }
}
```

会被编译为：

```java
public class Candy6_2 {
  public Candy6_2(){}
  public static void choose(String str) {
    byte x = -1;
    switch(str.hashCode()) {
      case 2123:
        if(str.equals("C.")) {
          x = 1;
        } else if (str.equals("BM")) {
          x = 0
        }
      default:
        switch(x) {
          case 0:
            System.out.println("h");
            break;
          case 1:
            System.out.println("w");
            break;
        }
    }
  }
}
```

### 3.7 switch 枚举类



## 4. 类加载阶段

## 5. 类加载器

## 6. 运行期优化

