## 1. 如何判断对象可以回收

### 1.1引用计数法

### 1.2 可达性分析算法

- Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象
- 扫描堆中的对象，看是否能够沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收
- 哪些对象可以作为GC Root
  1. 虚拟机栈中引用的对象：比如各个线程被调用的方法中使用到的参数，局部变量等
  2. 本地方法栈内JNI引用的对象
  3. 方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量
  4. 方法区中常量引用的对象：比如：字符串常量池String Table里的引用
  5. 所有被同步锁synchronized持有的对象
  6. Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象(NullPointerException, OutOfMemoryException),系统加载类
  7. 反映Java虚拟机内部情况的JMXBean, JVM中注册的回调，本地代码缓存等
  8. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收Partial GC.。如果只针对Java堆中的某一块区域进行垃圾回收(典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性
  9. 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root
  10. 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须Stop The World的一个重要原因。即使是号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的

```java
public class Demo1 {
    public static void main(String[] args) throws IOException {
        List<Object> list = new ArrayList<>();
        list.add("a");
        list.add("b");
        System.out.println(1);
        System.in.read();

        list = null;
        System.out.println(2);
        System.in.read();
        System.out.println("end...");
    }
}
```

`jmap -dump:format=b,live,file=1.bin 82058`

### 1.3 四种引用

- 强引用
  - 只有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收
- 软引用(SoftReference)
  - 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象
  - 可以配合引用队列来释放软引用自身
- 弱引用(WeakReference)
  - 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象
  - 可以配合引用队列来释放弱引用自身
- 虚引用(PhantomReference)
  - 必须配合引用队列使用，主要配合ByteBuffer使用，被引用对象回收时，会将虚引用入队，由ReferenceHandler线程调用虚引用相关方法释放直接内存
- 终结器引用(FinalReference)
  - 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找打被引用对象并调用它的finialize方法，第二次GC时才能回收被引用对象

##2. 垃圾回收算法

### 2.1 标记清除

- Mark Sweep
- 速度快，会造成内存碎片

### 2.2 标记整理

- Mark Compact
- 速度慢，没有内存碎片

### 2.3 复制

- Copy
- 不会有内存碎片，需要占用双倍内存空间

## 3. 分代垃圾回收

- 对象首先分配在Eden区域
- 新生代空间不足时，触发minor gc，Eden和from存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to
- minor gc会引发stop the world,暂停其它用户线程，等待回收结束，用户线程才恢复运行
- 当对象寿命超过阈值时，会晋升至老年代，最大寿命15
- 当老年代空间不足，会先尝试触发minor gc,如果之后扔空间不足，那么会触发full gc, STW的时间更长

### 3.1相关VM参数

| 参数                                                      | 含义               |
| --------------------------------------------------------- | ------------------ |
| -Xms                                                      | 堆初始大小         |
| -Xmx或-XX:MaxHeapSize=size                                | 堆最大大小         |
| -Xmn或(-XX:NewSize=size -XX:MaxNewSize=size)              | 新生代大小         |
| -XX:InitialSurvivorRatio=ratio -XX:+UseAdaptiveSizePolicy | 幸存区比例（动态） |
| -XX:SurvivorRation=ratio                                  | 幸存区比例         |
| -XX:MaxTenuringThreshold=threshold                        | 晋升阈值           |
| -XX:+PrintTenuringDistribution                            | 晋升详情           |
| -XX:+PrintGCDetails -verbose:gc                           | GC详情             |
| -XX:+ScavengeBeforeFullGC                                 | FullGC前MinorGC    |

## 4. 垃圾回收器

### 4.1串行

- 单线程
- 堆内存较小，适合个人电脑

### 4.2吞吐量优先

- 多线程
- 堆内存较大，多核CPU
- 让单位时间内，STW的时间最短0.2 0.2 = 0.4

### 4.3响应时间优先

- 多线程
- 堆内存较大，多核CPU
- 尽可能让单次STW的时间最短 0.1 0.1 0.1 0.1 0.1 = 0.5

## 5. 垃圾回收调优

