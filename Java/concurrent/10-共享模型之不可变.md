## 日期转换的问题

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
  new Thread(() -> {
    try {
      log.debug("{}", sdf.parse("2022-07-20"));
    } catch (Exception e) {
      log.error("{}", e);
    }
  }).start();
}
```

运行会报`java.lang.NumberFormatException: For input string: ""`

解决方案一：给sdf加锁,性能会很差

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
for (int i = 0; i < 10; i++) {
  new Thread(() -> {
    synchronized (sdf) {
      try {
        log.debug("{}", sdf.parse("2022-07-20"));
      } catch (Exception e) {
        log.error("{}", e);
      }
    }
  }).start();
}
```

解决方案二：用DateTimeFormatter替换SimpleDateFormat

```java
@Slf4j
public class TestDateTimeFormatter {
    public static void main(String[] args) {
        DateTimeFormatter sdf = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        for (int i = 0; i < 10; i++) {
            new Thread(() -> {
                try {
                    log.debug("{}", sdf.parse("2022-07-20"));
                } catch (Exception e) {
                    log.error("{}", e);
                }
            }).start();
        }
    }
}
```

## 不可变设计

String类是不可变的。设计要素

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
  private final char value[];
  private int hash;
}
```

### final的使用

String类中value属性是用final修饰的

- 属性用final修饰保证了该属性是只读的，不能修改
- 类用final修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性

### 保护性拷贝

以String.substring(int index)为例：

```java
    public String substring(int beginIndex) {
        if (beginIndex < 0) {
            throw new StringIndexOutOfBoundsException(beginIndex);
        }
        int subLen = value.length - beginIndex;
        if (subLen < 0) {
            throw new StringIndexOutOfBoundsException(subLen);
        }
        return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);
    }
```

发现其内部是调用了String的构造方法创建了一个新字符串，再进入这个构造看看，是否对final char[] value做出了修改

```java
    public String(char value[], int offset, int count) {
        if (offset < 0) {
            throw new StringIndexOutOfBoundsException(offset);
        }
        if (count <= 0) {
            if (count < 0) {
                throw new StringIndexOutOfBoundsException(count);
            }
            if (offset <= value.length) {
                this.value = "".value;
                return;
            }
        }
        // Note: offset or count might be near -1>>>1.
        if (offset > value.length - count) {
            throw new StringIndexOutOfBoundsException(offset + count);
        }
        this.value = Arrays.copyOfRange(value, offset, offset+count);
    }
```

结果发现也没有，构造新字符串对象时，会生成全新的char[] value,对内容进行复制。这种通过创建副本对象来避免共享的手段称之为【保护性拷贝（defensive copy）】