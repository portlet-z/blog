## 概述

线程安全集合类可以分为三大类

- 遗留的线程安全集合如HashTable, Vector
- 使用Collections装饰的线程安全集合
  - Collections.synchronizedCollection
  - Collections.synchronizedList
  - Collections.synchronizedMap
  - Collections.synchronizedSet
  - Collections.synchronizedNavigableMap
  - Collections.synchronizedNavigableSet
  - Collections.synchronizedSortedMap
  - Collections.synchronizedSortedSet
- java.util.concurrent.*

重点介绍java.util.concurrent.*下的线程安全集合类，可以发现它们的规律，里面包含三类关键词：Blocking, CopyOnWrite, Concurrent

- Blocking大部分实现基于锁，并提供用来阻塞的方法
- CopyOnWrite之类容器修改开销相对较重
- Concurrent类型容器
  - 内部很多操作使用cas优化，一般可以提供较高吞吐量
  - 弱一致性
    1. 遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的
    2. 求大小弱一致性，size操作未必是100%准确
    3. 读取弱一致性

> 遍历时如果发生了修改，对于非安全容器来说，使用fail-fast机制也就是让遍历立刻失败，抛出ConcurrentModificationException,不再继续遍历

## ConcurrentHashMap

生成测试数据

```java
public class TestGenericData {
    static final String ALPHA = "abcdefghijklmnopqrstuvwxyz";
    public static void main(String[] args) {
        int length = ALPHA.length();
        int count = 200;
        List<String> list = new ArrayList<>(length * count);
        for (int i = 0; i < length; i++) {
            char ch = ALPHA.charAt(i);
            for (int j = 0; j < count; j++) {
                list.add(String.valueOf(ch));
            }
        }
        Collections.shuffle(list);
        for (int i = 0; i < 26; i++) {
            try (PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(new FileOutputStream((i + 1) + ".txt")))) {
                String collect = list.subList(i * count, (i + 1) * count).stream().collect(Collectors.joining("\n"));
                printWriter.write(collect);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
```

```java
@Slf4j
public class WordCount {
    public static void main(String[] args) {
        demo(
                // 创建map集合
                () -> new ConcurrentHashMap<String, LongAdder>(26),
                (map, words) -> {
                    for (String word : words) {
                        LongAdder value = map.computeIfAbsent(word, (key) -> new LongAdder());
                        value.increment();
                      // 以下三行代码不是原子性操作，及时使用了ConcurrentHashMap也不对
//                        Integer counter = map.get(word);
//                        int newValue = counter == null ? 1 : counter + 1;
//                        map.put(word, newValue);
                    }
                }
        );
    }
    public static <V> void demo(Supplier<Map<String, V>> supplier, BiConsumer<Map<String, V>, List<String>> consumer) {
        Map<String, V> counterMap = supplier.get();
        List<Thread> ts = new ArrayList<>();
        for (int i = 1; i <= 26; i++) {
            int idx = i;
            Thread thread = new Thread(() -> {
                List<String> words = readFromFile(idx);
                consumer.accept(counterMap, words);
            });
            ts.add(thread);
        }
        ts.forEach(Thread::start);
        ts.forEach(thread -> {
            try {
                thread.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
        log.debug("{}", counterMap);
    }
    private static List<String> readFromFile(int i) {
        List<String> words = new ArrayList<>();
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(i + ".txt")))) {
            while (true) {
                String word = reader.readLine();
                if (word == null) {
                    break;
                }
                words.add(word);
            }
        } catch (IOException e) {
        }
        return words;
    }
}
```

### 重要属性和内部类

```java
// 默认为0
// 当初始化时，为-1
// 当扩容时，为-(1 + 扩容线程数)
// 当初始化或扩容完成后，为下一次的扩容的阈值大小
private transient volatile int sizeCtl;
//整个ConcurrentHashMap就是一个Node[]
static class Node<K, V> implements Map.Entry<K, V>{}
// hash表
transient volatile Node<K, V>[] table;
//扩容时的新hash表
private transient volatile Node<K.V>[] nextTable;
// 扩容时如果某个bin迁移完毕，用ForwardingNode作为旧table bin 的头结点
static final class ForwardingNode<K, V> extends Node<K,V> {}
// 用在compute以及computeIfAbsent时，用来占位，计算完成后替换为普通Node
static final class ReservationNode<K, V> extends Node<K, V> {}
// 作为treebin的头结点，存储root和first
static final class TreeBin<K, V> extends Node<K, V> {}
// 作为treebin的结点，存储parent, left, right
static final class TreeNode<K, V> extends Node<K, V> {}
```

### 重要方法

```java
// 获取Node[]中第i个Node
static final <K,V> Node<K, V> tabAt(Node<K,V>[] tab, int i);
// cas修改Node[]中第i个Node的值，c为旧值，v为新值
static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i, Node<K,V> c, Node<K,V> v);
// 直接修改Node[]中第i个Node的值，v为新值
static final <K, V> boolean setTabAt(Node<K,V>[] tab, int i, Node<K, V> v);
```

