## 非阻塞 vs 阻塞

### 阻塞

- 阻塞模式下，相关方法都会导致线程暂停
  - ServerSocketChannel.accept会在没有连接建立时让线程暂停
  - SocketChannel.read会在没有数据可读时让线程暂停
  - 阻塞的表现其实就是线程暂停了，暂停期间不会占用CPU,但线程相当于闲置

- 单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持
- 但多线程下，有新的问题，体现在以下方面
  - 32位JVM一个线程320k, 64位JVM一个线程1024K, 如果连接数过多，必然导致OOM, 并且线程太多，反而会因为频繁上下文切换导致性能降低
  - 可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间inactive(无效)，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接


```java
@Slf4j
public class Server {
    public static void main(String[] args) throws IOException {
        // 使用NIO来理解阻塞模式，单线程
        // 1. 准备ByteBuffer
        ByteBuffer buffer = ByteBuffer.allocate(16);
        // 2. 创建了服务器
        ServerSocketChannel ssc = ServerSocketChannel.open();
        // 3. 绑定监听端口
        ssc.bind(new InetSocketAddress(8080));
        // 4. 连接集合
        List<SocketChannel> channels = new ArrayList<>();
        while (true) {
            // 5. accept 建立与客户端连接，SocketChannel 用来与客户端之间通信
            log.debug("connecting...");
            SocketChannel sc = ssc.accept();
            log.debug("connected...{}", sc);
            channels.add(sc);
            for (SocketChannel channel : channels) {
                // 6. 接收客户端发送的数据
                log.debug("before read...{}", channel);
                channel.read(buffer);
                buffer.flip();
                debugAll(buffer);
                buffer.clear();
                log.debug("after read...{}", channel);
            }
        }
    }
}
public class Client {
    public static void main(String[] args) throws IOException {
        SocketChannel sc = SocketChannel.open();
        sc.connect(new InetSocketAddress("localhost", 8080));
        sc.write(StandardCharsets.UTF_8.encode("hello world"));
        System.in.read();
    }
}
```

### 非阻塞

- 非阻塞模式下，相关方法都会不会让线程暂停
  - 在ServerSocketChannel.accept在没有连接建立时，会返回null,继续运行
  - SocketChannel.read在没有数据可读时，会返回0，但线程不会阻塞，可以去执行其它SocketChannel的read或是去执行ServerSocketChannel.accpet
  - 写数据时，线程只是等待数据写入Channel即可，无需等待Channel通过网络把数据发送出去

- 但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了CPU
- 数据复制过程中，线程实际还是阻塞的(AIO改进的地方)
- 以下代码如果没有客户端连接，会导致CPU一直空转

```java
@Slf4j
public class Server {
    public static void main(String[] args) throws IOException {
        // 使用NIO来理解阻塞模式，单线程
        // 1. 准备ByteBuffer
        ByteBuffer buffer = ByteBuffer.allocate(16);
        // 2. 创建了服务器
        ServerSocketChannel ssc = ServerSocketChannel.open();
        // 非阻塞模式
        ssc.configureBlocking(false);
        // 3. 绑定监听端口
        ssc.bind(new InetSocketAddress(8080));
        // 4. 连接集合
        List<SocketChannel> channels = new ArrayList<>();
        while (true) {
            // 5. accept 建立与客户端连接，SocketChannel 用来与客户端之间通信
            log.debug("connecting...");
            SocketChannel sc = ssc.accept();
            if (sc != null) {
                log.debug("connected...{}", sc);
                // 非阻塞，线程还会继续运行，如果没有连接建立，但sc会为null
                sc.configureBlocking(false);
                channels.add(sc);
            }
            for (SocketChannel channel : channels) {
                // 6. 接收客户端发送的数据
                log.debug("before read...{}", channel);
                // 非阻塞，线程仍然会继续运行，如果没有读到数据，read会返回0
                int read = channel.read(buffer);
                if (read > 0) {
                    buffer.flip();
                    debugAll(buffer);
                    buffer.clear();
                    log.debug("after read...{}", channel);
                }
            }
        }
    }
}
```

## 多路复用

线程必须配合Selector才能完成对多个Channel可读可写事件的监控，这称之为多路复用

- 多路复用仅针对网络IO, 普通文件IO没法利用多路复用
- 如果不用Selector的非阻塞模式，那么Channel读取到的字节很多时候都是0， 而Selector保证了有可读事件才去读取
  - 有可连接事件时才去连接
  - 有可读事件才去读取
  - 有可写事件才去写入
  - 限于网络传输能力，Channel未必时时可写，一旦Channel可写，会触发Selector的可写事件
- Channel输入的数据一旦准备好，会触发Selector的可读事件

## Selector

```mermaid
graph TD
subgraph selector版
t(thread) --> s(selector)
s --> c1(channel)
s --> c2(channel)
s --> c3(channel)
end
```

### 优点

- 一个线程配合selector就可以监控多个channel的事件，事件发生线程才去处理。避免非阻塞模式下所作无用功
- 让这个线程能够被充分利用
- 节约了线程的数量
- 减少了线程上下文切换
