## redis

`set name zhang`

```
*3    // 代表数组长度
$3    // 代表下一个单词的长度
set
$4    // 下一个单词的长度
name
$5    // 下一个单词的长度
zhang
```

```java
public class TestRedis {
    public static final byte[] LINE = "\r\n".getBytes();
    public static void main(String[] args) {
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try {
            ChannelFuture channelFuture = new Bootstrap()
                    .group(worker)
                    .channel(NioSocketChannel.class)
                    .handler(new ChannelInitializer<NioSocketChannel>() {
                        @Override
                        protected void initChannel(NioSocketChannel channel) throws Exception {
                            channel.pipeline().addLast(new LoggingHandler());
                            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
                                @Override
                                public void channelActive(ChannelHandlerContext ctx) throws Exception {
                                    ByteBuf buffer = ctx.alloc().buffer();
                                    buffer.writeBytes("*3".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("$3".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("set".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("$4".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("name".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("$5".getBytes());
                                    buffer.writeBytes(LINE);
                                    buffer.writeBytes("zhang".getBytes());
                                    buffer.writeBytes(LINE);
                                    ctx.writeAndFlush(buffer);
                                }
                            });
                        }
                    }).connect("localhost", 6379);
            channelFuture.sync().channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            worker.shutdownGracefully();
        }
    }
}
```

打印结果

```
09:21:24.465 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x4fe11c22, L:/127.0.0.1:62875 - R:localhost/127.0.0.1:6379] WRITE: 34B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 2a 33 0d 0a 24 33 0d 0a 73 65 74 0d 0a 24 34 0d |*3..$3..set..$4.|
|00000010| 0a 6e 61 6d 65 0d 0a 24 35 0d 0a 7a 68 61 6e 67 |.name..$5..zhang|
|00000020| 0d 0a                                           |..              |
+--------+-------------------------------------------------+----------------+
09:21:24.466 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x4fe11c22, L:/127.0.0.1:62875 - R:localhost/127.0.0.1:6379] FLUSH
09:21:24.474 [nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x4fe11c22, L:/127.0.0.1:62875 - R:localhost/127.0.0.1:6379] READ: 5B
         +-------------------------------------------------+
         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |
+--------+-------------------------------------------------+----------------+
|00000000| 2b 4f 4b 0d 0a                                  |+OK..           |
+--------+-------------------------------------------------+----------------+
```

从redi命令行可以看到设置的结果

```
127.0.0.1:6379> get name
"zhang"
```

## HTTP

Netty内部内置了Http的编解码器HttpServerCodec

SimpleChannelInboundHandler继承自ChannelInboundHandlerAdapter，可以处理特定类型的msg

```java
@Slf4j
public class TestHttp {
    public static void main(String[] args) {
        NioEventLoopGroup boss = new NioEventLoopGroup(1);
        NioEventLoopGroup worker = new NioEventLoopGroup();
        try {
            ChannelFuture channelFuture = new ServerBootstrap()
                    .group(boss, worker)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new ChannelInitializer<NioSocketChannel>() {
                        @Override
                        protected void initChannel(NioSocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new LoggingHandler());
                            ch.pipeline().addLast(new HttpServerCodec());
                            ch.pipeline().addLast(new SimpleChannelInboundHandler<HttpRequest>() {
                                @Override
                                protected void channelRead0(ChannelHandlerContext ctx, HttpRequest msg) throws Exception {
                                    log.debug("uri is {}", msg.uri());
                                    // 返回响应
                                    DefaultFullHttpResponse response = new DefaultFullHttpResponse(msg.protocolVersion(), HttpResponseStatus.OK);
                                    byte[] bytes = "<h1>HELLO, WORLD</h1>".getBytes(StandardCharsets.UTF_8);
                                    response.headers().set(CONTENT_LENGTH, bytes.length);
                                    response.content().writeBytes(bytes);
                                    ctx.writeAndFlush(response);
                                }
                            });
                        }
                    }).bind(8080);
            channelFuture.sync().channel().closeFuture().sync();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            boss.shutdownGracefully();
            worker.shutdownGracefully();
        }
    }
}
```

浏览器访问`http://127.0.0.1:8080`可以看到页面上显示了HELLO, WORLD

## 自定义协议要素

- 魔数，用来在第一时间判定是否是无效数据包
- 版本号，可以支持协议的升级
- 序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如:json, protobuf, hessian, jdk
- 指令类型，是登录，注册，单聊，群聊。。。跟业务相关
- 请求序号，为了双工通信，提供异步能力
- 正文长度
- 消息正文

```java
@Data
public abstract class Message {
    private int sequenceId;
    private int messageType;
    public abstract int getMessageType();
    public static final int LoginRequestMessage = 0;
    public static final int LoginResponseMessage = 1;
}
@Data
@ToString(callSuper = true)
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestMessage extends Message implements Serializable {
    private String username;
    private String password;
    private String nickname;

    @Override
    public int getMessageType() {
        return LoginRequestMessage;
    }
}
@Slf4j
public class MessageCodec extends ByteToMessageCodec<Message> {
    @Override
    protected void encode(ChannelHandlerContext ctx, Message msg, ByteBuf out) throws Exception {
        // 1. 4字节的魔数
        out.writeInt(0xCAFEBABE);
        // 2. 1字节的版本
        out.writeByte(1);
        // 3. 1字节的序列化方式 jdk 0, json 1, protobuf 2
        out.writeByte(0);
        // 4. 1字节的指令类型
        out.writeByte(msg.getMessageType());
        // 5. 4个字节序列号
        out.writeInt(msg.getSequenceId());
        // 为了凑齐16字节的头，多加一个无效的字节
        out.writeByte(0xff);
        // 6. 获取内容的字节数组
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bos);
        oos.writeObject(msg);
        byte[] bytes = bos.toByteArray();
        // 7. 内容长度
        out.writeInt(bytes.length);
        // 8. 写入内容
        out.writeBytes(bytes);
    }

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        int magicNumber = in.readInt();
        byte version = in.readByte();
        byte serializedVersion = in.readByte();
        byte messageType = in.readByte();
        int sequenceId = in.readInt();
        in.readByte();
        int contentLength = in.readInt();
        byte[] bytes = new byte[contentLength];
        in.readBytes(bytes, 0, contentLength);
        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
        Message message = (Message) ois.readObject();
        log.debug("magicNumber: {}, version: {}, serializedVersion: {}, messageType: {}, sequenceId: {}, contentLength: {}", magicNumber, version, serializedVersion, messageType, sequenceId, contentLength);
        log.debug("message {}", message);
        out.add(message);
    }
}
@Slf4j
public class TestMessageCodec {
    public static void main(String[] args) throws Exception {
        EmbeddedChannel channel = new EmbeddedChannel(
                new LengthFieldBasedFrameDecoder(1024, 12, 4, 0, 0),
                new LoggingHandler(), new MessageCodec()
        );

        // encode
        LoginRequestMessage message = new LoginRequestMessage("zhang", "123", "admin");
        channel.writeOutbound(message);

        // decode
        ByteBuf buffer = ByteBufAllocator.DEFAULT.buffer();
        new MessageCodec().encode(null, message, buffer);
        // channel.writeInbound(buffer);

        ByteBuf buffer1 = buffer.slice(0, 100);
        ByteBuf buffer2 = buffer.slice(100, buffer.readableBytes() - 100);
        buffer1.retain(); // 引用计数加1，调用channel.writeInbound(buffer)会将buffer的引用计数减一
        channel.writeInbound(buffer1);
        channel.writeInbound(buffer2);
    }
}
```

## @Sharable

- 当处理器(handler)不保存状态时，就可以安全的被多个channel所共享
- 但要注意对于编解码器类，不能继承ByteToMessageCodec或CombinedChannelDuplexHandler父类，他们的构造方法对@Sharable有限制
- 如果能够确保编解码器不会保存状态，可以继承MessageToMessageCodec父类