- 一些显卡驱动实际上会为你提供一个默认的着色器，在你实际上没有提供字节着色器的时候。
- 着色器就是一个运行在显卡上的一个程序（代码），可以在计算机上以文本或字符串形式编写的代码，然后我们可以把它给OpenGL,可以把它发到显卡上，像其他程序一样编译，链接，运行。但是，不同的是，它实际上是在显卡上运行的，而不是像c++程序那样在我们的CPU上。
- 对于大多数图形编程，重点放在顶点着色器和片段着色器。片段着色器也被称为像素着色器。还有其他的着色器类型，细分曲面着色器，几何着色器，计算着色器等等。
- 我们在CPU上写了一堆数据，我们已经向显卡发送了一些数据，我们已经发出了一个叫做DrawCall指令，在发出DrawCall指令之前，我们也绑定了某些状态，最后我们进入了着色器的阶段，或者说显卡实际处理DrawCall指令并在屏幕上绘制一些东西。这个特定的过程基本上就是渲染管道(rendering pipeline)
- 顶点着色器和片段着色器是顺着管道的两种不同的着色器类型，当我们真正发出DrawCall指令时，顶点着色器会被调用，然后片段着色器会被调用，然后我们会在屏幕上看到结果。顶点着色器会为我们试图渲染的每个顶点调用，在例子中，绘制一个三角形，有三个顶点，这意味着顶点着色器会被调用三次。顶点着色器主要目的时告诉OpenGL,你希望这个顶点在屏幕空间的什么位置，它指定了你想要的位置的方式，它也被用来解析数据从属性到下一阶段，在我们的例子中，下一阶段时片段着色器
- 一旦我们在顶点着色器中访问了那个位置，我们基本上就可以告诉OpenGL,我想让你把这个顶点定位到属性中指定的位置
- 片段着色器会为每个需要光栅化的像素运行一次，光栅化实际上是画在屏幕上的。窗口是由像素组成的，就像一个像素数组。需要发生的是我们指定的那三个顶点组成我们的三角形，现在需要用实际的像素填充，这就是光栅化(rasterization)阶段所做的。并且片段着色器，就是对三角形中需要填充的每个像素调用一次，并且片段着色器的主要目的是决定这个像素应该是什么颜色。
- 片段着色器里面的东西代价要高的多，因为片段着色器会为每个像素运行。有些东西显然需要按像素计算，特别是光源，如果你在计算光源，每个像素都有一个颜色值，这个值是由很多东西决定的，例如，光源，环境，纹理，提供给表面的材质，所有这些的定西，一起来决定一个特定像素的正确颜色。你在片段着色器中所有的决定，是单个像素的颜色，这就是片段着色器的作用。它是一个程序，运行来确定这个像素应该是什么颜色。
- OpenGL着色器中的一起都是基于状态机工作的，当你想要启动一个着色器，要画一个三角形，想让它用一个特定的着色器来画那个三角形，你启动那个着色器，你也可以发送一些数据到着色器，就像我们从CPU发送这个顶点数据一样，以顶点 缓冲区的形式发送给GPU,我们也可以通过uniform的形式发送数据到我们的着色器，这也来自CPU.所以我们设置了所有状态，启用着色器，然后画出三角形