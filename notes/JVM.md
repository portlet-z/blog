### JVM的架构模型

Java编译器输入的指令流基本上是一种基于栈的指令集架构，另一种指令集架构则是基于寄存器的指令集架构

- 基于栈式架构的特点
  - 设计和实现更简单，适用于资源受限的系统
  - 避开了寄存器分配难题，使用零地址指令方式分配
  - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现
  - 不需要硬件支持，可移植性更好，更好实现跨平台
- 基于寄存器架构的特点
  - 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机
  - 指令集架构则完全依赖于硬件，可移植性差
  - 性能优秀和执行更高效
  - 花费更少的指令去完成一项操作
  - 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令，二地址指令，三地址指令为主，而基于栈式架构的的指令集却是以零地址为主



```assembly
iconst_2 //常量2入栈
istore_1
iconst_3 //常量3入栈
istore_2
iload_1
iload_2
iadd    //常量2、3出栈，执行相加
istore_0 //结果5入栈
```

```assembly
mov eax,2  //将eax寄存器的值设为2
add eax,3  //使eax寄存器的值加3
```



### 类加载器

#### 类加载器子系统作用

- 类加载器子系统负责从文件系统或者网络中加载class文件,class文件所在文件开头有特定的文件标识
- ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定
- 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量

#### 类加载器ClassLoader角色

- class file存在于本地磁盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候要加载到JVM当中来根据这个文件实例化出n个一模一样的实例
- class file加载到JVM中，被称为DNA原数据模板，放在方法区
- 在.class文件 -> JVM -> 最终称为元数据模板，此过程要有一个运输工具(类装载器Class Loader),扮演一个快递员的角色

#### 类的加载过程

- 通过一个类的全限定名获取定义此类的二进制字节流
- 将这个字节流所代表的静态存储结构转化为方法去的运行时数据结构
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问接口

#### 加载.class文件的方式

- 从本地系统中直接加载
- 通过网络获取，典型场景Web Applet
- 从zip压缩包读取，jar,war
- 运行时计算生成，使用最多的是动态代理技术
- 由其他文件生成 JSP
- 从专有数据库中提取.class文件，比较少见
- 从加密文件中获取，典型的防止class文件被反编译的保护措施

#### 链接过程

- 验证Verify
  - 目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全
  - 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证
- 准备Prepare
  - 为类变量分配内存并且设置该类变量的默认初始值，即零值
  - 这里不包含用final修饰的static,因为final在编译的时候就会分配了，准备阶段会显式初始化
  - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中
- 解析Resolve
  - 将常量池内的符号引用转换为直接引用的过程
  - 事实上，解析操作往往会伴随着JVM在执行完成初始化之后再执行
  - 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
  - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info, CONSTANT_Field_info, CONSTANT_Methodref_info等

#### 初始化过程

- 初始化阶段就是执行类构造器方法<clinit>()的过程
- 此方法不需要定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- <clinit>()不同于类的构造器(关联：构造器是虚拟机视角下的<init>())
- 若该类具有父类，JVM 会保证子类的<clinit>()执行前，父类的<clinit>()已经执行完成
- 虚拟机必须保证一个类的<clinit>()方法在多线程下被同步加锁

#### 类加载器分类

- JVM支持两种类型的加载器，分别为引导类加载器Bootstrap Class Loader和自定义加载器User-Defined Class Loader
- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器
- 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个Bootstrap Class Loader,Extension Class Loader, System Class Loader

#### 虚拟机自带的加载器

- 启动类加载器(引导类加载器 Bootstrap ClassLoader)
  - 这个类加载使用C/C++语言实现的，嵌套在JVM内部
  - 它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar, resources.jar或sun.boot.class.path路径下的内容)，用于提供JVM自身需要的类
  - 并不继承自java.lang.ClassLoader，没有父加载器
  - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器
  - 出于安考虑，Bootstrap启动类加载器只加载包名为java,javax,sun等开头的类
- 扩展类加载器（Extension ClassLoader）
  - Java语言编写，由sun.misc.Launcher$ExtClassLoader实现
  - 派生于ClassLoader类
  - 父类加载器为启动类加载器
  - 从java.ext.dir系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录(扩展目录)下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载
- 应用程序类加载器(系统类加载器，AppClassLoader)
  - Java语言编写，由sun.misc.Launcher$AppClassLoader实现
  - 派生于ClassLoader类
  - 父类加载器为扩展类加载器
  - 它负责加载环境变量classpath或系统属性，java.class.path指定路径下的类库
  - 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
  - 通过ClassLoader#getSystemClassLoader()方法可以获取到该类加载器

#### 用户自定义类加载器实现步骤

- 开发人员可以通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊需求
- 在JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中
- 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁

#### 为什么要自定义类加载器

- 隔离加载类
- 修改类加载的方式
- 扩展加载源
- 防止源码泄露



### 双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式

#### 工作原理

- 如果一个类加载器收到了类加载器请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行
- 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器
- 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式

#### 优势

- 避免类的重复加载
- 保护程序安全，防止核心API被随意篡改
  - 自定义类：java.lang.String
  - 自定义类：java.lang.MyStart (java.lang.SecurityExceptioni: Prohibited package name: java.lang)

#### 沙箱安全机制

自定义java.lang.String类，但是在加载自定义java.lang.String类的时候会率先使用引导类加载器加载，而引导类在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制



### 运行时数据区(Runtime Data Area)

#### 线程

Java虚拟机定义了若干程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁

- 线程是一个程序里的运行单元。JVM允许一个应用有多个线程并行的执行
- 在Hotspot JVM里，每个线程都与操作系统的本地线程直接映射。当一个Java线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java线程执行中止后，本地线程也会回收
- 操作系统复制所有线程的安排调度到任何一个可用的CPU上。一旦本地线程初始化成功，他就会调用Java线程中的run()方法

JVM里主要有以下几个线程

- 虚拟机线程：这种线程的操作是需要JVM达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要JVM达到安全点，这样堆才不会变好。这种线程的执行类型包括stop-the world的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销
- 周期任务线程：这种线程是时间周期事件的提现(比如中断)，他们一般用于周期性操作的调度执行
- GC线程：这种线程对在JVM里不同种类的垃圾收集行为提供了支持
- 编译线程：这种线程在运行时会将字节码编译成本地代码
- 信号调度线程：这种线程接受信号并发送给JVM,在它内部通过调用适当的方法进行处理

#### 程序计数器(PC寄存器)

JVM中的PC寄存器是对物理PC寄存器的一种模拟。寄存器存储指令相关的现场信息，CPU只有把数据装载到寄存器才能够运行

- 作用：PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令
- 它是一块很小的内存空间，几乎可以忽略不计。也是运行速度最快的存储区域
- 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致
- 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是执行native方法，则是未指定值undefined
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 它是唯一一个Java虚拟机规范中没有OutOfMemoryError情况的区域
- 使用PC寄存器存储字节码指令地址的作用
  - 因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行
  - JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令
- PC寄存器为什么会被设定线程私有
  - 为了能够准确的记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况
  - 由于CPU时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令
  - 这样必然会导致经常中断或回复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈桢，程序计数器在各个线程之间互不影响

#### 虚拟机栈

- 背景及优缺点

  - 由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的
  - 优点是跨平台，指令集小，编译器容易实现
  - 缺点是性能下降，实现同样的功能需要更多的指令
- 内存中的栈与堆

  - 栈是运行时的单位，而堆是存储的单位。即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放，放在哪
- 定义：Java Virtual Machine Stack.每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈桢Stack Frame.对应着一次次的Java方法调用，是线程私有的
- 生命周期和线程一致
- 作用：主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回
- 特点

  - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
  - JVM直接对Java栈的操作只有两个
    - 每个方法执行，伴随着进栈(入栈、压栈)
    - 执行结束后的出栈工作
  - 对于栈来说不存在垃圾回收问题
- 栈中可能出现的异常。Java虚拟机规范允许Java栈的大小是动态的或者固定不变的

  - 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常
  - 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个OutOfMemoryError异常
- 设置栈内存大小 -Xss
- 栈的存储单位

  - 栈中存储什么
    - 每个线程都有自己的栈，栈中的数据都是以栈桢Stack Frame的格式存在
    - 在这个线程上正在执行的每个方法都各自对应一个栈桢Stack Frame
    - 栈桢是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息
- 栈运行原理

  - JVM直接对Java栈的操作只有两个，就是对栈桢的压栈和出栈，遵循先进后出，后进先出的原则
  - 在一条活动线程中，一个时间点上，只会有一个活动的栈桢。即只有当前正在执行的方法的栈桢（栈顶栈桢）是有效的，这个栈桢被称为当前栈桢Current Frame,与当前栈桢对应的方法就是当前方法Current Method,定义这个方法的类就是当前类Current Class
  - 执行引擎运行的所有字节码指令只针对当前栈桢进行操作
  - 如果在该方法中调用了其他方法，对应的新的栈桢会被创建出来，放在栈的顶端，成为新的当前帧
  - 不同线程中所包含的栈桢是不允许存在相互引用的，即不可能在一个栈桢之中引用另外一个线程的栈桢
  - 如果当前方法调用了其他方法，方法返回之际，当前栈桢会传回此方法的执行结果给前一个栈桢，接着，虚拟机会丢弃当前栈桢，使得前一个栈桢重新成为当前栈桢
  - Java方法有两种返回函数的方式，一种是正常的函数返回，使用return指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈桢被弹出
- 栈桢的内部结构

  - 局部变量表Local Variables
    - 局部变量表也被称为局部变量数组或本地变量表
    - 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用reference，以及returnAddress类型
    - 由于局部变量表是建立在线程的栈上，是线程私有数据，因此不存在数据安全问题
    - 局部变量表所需的容量大小是在编译期确定下来的，并保存方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小
    - 方法嵌套调用的次数有栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈桢就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少
    - 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈桢的销毁，局部变量表也会随之销毁
    - 关于Slot的理解
      1. 参数值的存放总是在局部变量数组的Index0开始，到数组长度-1的所有结束
      2. 局部变量表，最基本的存储单元是Slot(变量槽)
      3. 局部变量表中存放编译期可知的各种基本数据类型，引用类型reference，returnAddress类型的变量
      4. 在局部变量表里，32位以内的类型只占一个slot（包括returnAddress类型），64位的类型(long,double)占用两个slot
         - byte short char在存储前被转换为int, boolean也被转换为int,0表示false,非0表示true
         - long和double则占据两个slot
      5. JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
      6. 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个slot上
      7. 如果需要方法局部变量表中一个64bit的局部变量值时只需要使用前一个索引即可
      8. 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列
      9. 栈桢中的局部变量表中的槽位是可以重用的，如果一个局部变量表过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的
    - 变量的分类按照数据类型分基本数据类型和引用数据类型。按照在类中声明的位置分：
      1. 成员变量：在使用前，都经历过默认初始化赋值
         - 类变量：linking的prepare阶段：给类变量默认赋值  ---> initial阶段：给类变量显示赋值即静态代码块赋值
         - 实例变量：随着对象的创建，会在堆空间中分配实例变量空间，并进行默认赋值
      2. 局部变量：在使用前必须要进行显示赋值的！否则编译不通过
    - 在栈桢中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递
    - 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收
  - 操作数栈 Operand Stack 或表达式栈
    - 每一个独立的栈桢中除了包含局部变量表以外，还包含一个后进先出的Last-In-First-Out的操作数栈，也可以称之为表达式栈Expression Stack
    - 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据即入栈push 出栈pop
      1. 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈
      2. 执行复制、交换、求和等操作
    - 操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
    - 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈桢也会随之被创建出来，这个方法的操作数栈是空的
    - 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的code属性中，为max_stack的值
    - 栈中的任何一个元素都是可以任意的Java数据类型
      1. 32bit的类型占用一个栈单位深度
      2. 64bit的类型占用两个栈单位深度
    - 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈出栈操作来完成一次数据访问
    - 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈桢的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令
    - 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证
    - 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈
  - 栈顶缓存技术 Top of Stack Cashing
    - 基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派instruction dispatch次数和内存读写次数
    - 由于操作数是存储在内存中的，因此频繁地执行内存读写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者提出了栈顶缓存ToS,将栈顶元素全部缓存在物理CPU的寄存器中，以降低对内存的读写次数，提升执行引擎的执行效率
  - 动态链接 Dynamic Linking 或指向运行时常量池的方法引用
    - 每一个栈桢内部都包含一个指向运行时常量池中该栈桢所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接。比如invokedynamic指令
    - 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用
    - 常量池的作用就是为了提供一些符号和常量，便于指令的识别
  - 方法的调用
    - 在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关
    - 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接
    - 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接
    - 对应的方法的绑定机制为：早期绑定Early Binding和晚期绑定Late Binding.绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次
    - 早期绑定：早期绑定就是被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用
    - 晚期绑定：如果被调用的方法在编译期无法确定下来，只能够在程序运行期间根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定
    - 非虚方法：
      1. 如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法
      2. 静态方法，私有方法、final方法、实例构造器、父类方法都是非虚方法
      3. 其他方法称为虚方法
    - 虚拟机中提供了以下几条方法调用指令
      - 普通调用指令
        1. invokestatic: 调用静态方法，解析阶段确定唯一方法版本
        2. invokespecial: 调用<init>方法，私有及父类方法，解析阶段确定唯一方法版本
        3. invokevirtual: 调用所有虚方法
        4. invokeinterface: 调用接口方法
      - 动态调用指令
        5. invokedynamic: 动态解析出需要调用的方法，然后指向
      - 前四条指令固话在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法
    - 方法重写的本质：
      1. 找到操作数栈顶的第一个元素所执行的对象的实际类型，记为C
      2. 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常
      3. 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程
      4. 如果始终没有找到合适的方法，则跑出java.lang.AbstractMethodError异常
      5.  IllegalAccessError:程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生再运行时，就说明一个类发生了不兼容的改变
    - 虚方法表
      1. 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表virtual method table（非虚方法不会出现在表中）来实现。使用索引表来代替查找
      2. 每个类中都有一个虚方法表，表中存放着各个方法的实际入口
      3. 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕
  - 方法返回地址Return Address 或方法正常退出或者异常退出的定义
    - 存放调用该方法的pc寄存器的值
    - 一个方法的结束有两种方式：正常执行完成，出现未处理的异常非正常退出
    - 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈桢中一般不会保存这部分信息
    - 正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值
    - 当一个方法开始执行后，只有两种方式可以退出这个方法
      1. 执行引擎遇到任意一个方法返回的字节码指令return，会有返回值传递给上层的方法调用者，简称正常完成出口。ireturn(当返回值是boolean,byte,char,short,int类型时使用)，lreturn,freturn,dreturn以及areturn,另外还有一个return指令供声明为void的方法，实例初始化方法，类和接口初始化方法使用
      2. 异常完成出口，方法执行过程中抛出异常时的异常处理，存储在一个异常处理表，方便再发生异常的时候找到处理异常的代码
  - 一些附加信息

#### 本地方法栈Native Method Stack

- 什么是本地方法
  - 简单地讲，一个Native Metod就是一个Java调用非Java代码的接口。一个Native Method是这样的一个Java方法：该方法的实现由非Java语言实现，比如C.这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern C,告知C++编译器去调用一个C的函数
  - A native method is a Java method whose implementation is provided by non-java code
  - 在定义一个native method时，并不提供实现体，因为其实现是由非java语言在外面实现的
  - 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序
  - 标识符native可以与所有其它的java标识符连用，但是abstract除外
  - 有时java应用需要与java外面的环境交互，这是本地方法存在的主要原因，与操作系统交互
- Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用
- 本地方法栈也是线程私有的
- 允许被实现成固定或者是可动态扩展的内存大小（在内存溢出方面是相同的）
- 本地方法是使用C语言实现的
- 它的具体做法是Natvie Method Stack中登记native方法，在Execution Engine执行时加载本地方法库
- 当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限
  - 本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区
  - 它甚至可以直接使用本地处理器中的寄存器
  - 直接从本地内存的堆中分配任意数量的内存
- 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈
- 在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一

#### 堆

- 核心概念

  - 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域
  - Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存大小是可以调节的
  - 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的
  - 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区Thread Local Allocation Buffer, TLAB
  - 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。The heap is the run-time data area from which which memory for all class instances and arrays is allocated(几乎所有的对象实例都在堆上分配)
  - 数组和对象可能永远不会存储在栈上，因为栈桢中保存引用，这个引用指向对象或者数组在堆中的位置
  - 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除
  - 堆是GC Garbage Collection执行垃圾回收的重点区域
  - 内存细分：Java7及以前新生代，老年代，永久代。Java8及以后的分为新生代，老年代，元空间

- 堆空间大小的设置

  - -Xms用于表示堆区的起始内存，等价于-XX: InitialHeapSize 。  -X 是jvm的运行参数； ms: memory start

    ```java
    long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
    ```

    

  - -Xmx用于表示堆区的最大内存，等价于-XX: MaxHeapSize

    ```java
    long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;
    ```

    

  - 一旦堆区中的内存大小超过-Xmx所指定的最大内存时，将会跑出OutOfMemoryError异常

  - 通常会将-Xms和-Xmx两个参数设置的相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能

  - 默认情况下，初始内存大小：物理电脑内存/64;最大内存大小：物理内存 / 4

  - jstat -gc pid 或者 -XX: +PrintGCDetails

- 年轻代与老年代

  - 存储在JVM中的Java对象可以被划分为两类：一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速，另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致
  - Java堆区进一步细分的话，可以划分为年轻代YoungGen和老年代OldGen
  - 其中年轻代又可以划分为Eden空间，Survivor0空间和Survivor1空间（有时候也叫做from区，to区）
  - 配置新生代与老年代在堆结构的占比
    1. 默认 -XX: NewRatio=2,表示新生代占1， 老年代占2，新生代占整个堆的1/3
    2. 可以修改-XX: NewRation=4,表示新生代占1，老年代占4，新生代占整个堆的1/5
    3. jinfo -flag NewRatio pid
    4. 在HotSpot中，Eden空间和另外两个Survivor空间占比8:1:1
    5. 几乎所有的Java对象都是在Eden区被new出来的
    6. 绝大部分的Java对象的销毁都在新生代进行了。
    7. 可以使用-Xmn设置新生代最大内存大小

- 对象分配过程

  - new的对象先放Eden区。此区大小限制
  - 当Eden区的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对Eden区进行垃圾回收Minor GC,将Eden区中的不再被其他对象引用的对象进行销毁。再加载新的对象放到Eden区
  - 然后将Eden区中的剩余对象移到Survivor0区
  - 如果再次出发垃圾回收，此时上次幸存下来的放到Survivor0区的，如果没有回收，就会放到Survivor1区
  - 如果再次经历垃圾回收，此时会重新放回Survivor0区，接着再去Survivor1区
  - -XX: MaxTenuringThreshold=<N>进行设置次数，默认15次，对象就到了老年区
  - 当老年代内存不足时，再次触发GC: Major GC，进行老年代的内存清理
  - 若老年代执行了Major GC之后发现依然无法进行对象的保存就会产生OOM异常。java.lang.OutOfMemoryError: Java heap space

- 常用的调优工具

  - JDK命令行
  - Eclipse: Memory Analyzer Tool
  - Jconsole
  - VisualVM
  - JProfiler
  - Java Flight Recorder
  - GCViewer
  - GC Easy

- Minor GC,Major GC, Full GC

  - 部分收集，不是完整的收集整个Java堆的垃圾收集。其中又分为：
    - 新生代收集(Minor GC/Young GC):只是新生代(Eden,S0/S1)的垃圾收集
    - 老年代收集(Major GC/Old GC):只是老年代的垃圾收集。目前，只有CMS GC会有单独收集老年代的行为。注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收
  - 混合收集(Mixed GC):收集整个新生代以及部分老年代的垃圾收集
    - 目前只有G1 GC会有这种行为
  - 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集
  - Minor GC触发机制：
    1. 当年轻代空间不足时，就会触发Minor GC,这里的年轻代满指的是Eden满，Survivor满不会引发GC.每次Minor GC会清理年轻代的内存
    2. 因为Java对象大多都具备朝生夕死的特性，所以Minor GC非常频繁，一般回收速度也会比较快。
    3. Minor GC会引发STW,暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行
  - Major GC/Full GC触发机制
    1. 只发生在老年代的GC,对象从老年代消失时，我们说Major GC或Full GC发生了
    2. 出现了Major GC,经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就直接进行Major GC的策略选择过程）。也就是老年代空间不足时，会先尝试触发Minor GC.如果之后空间还不足，则触发Major GC
    3. Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长
    4. 如果Major GC之后，内存还不足，就报OOM
  - Full GC触发机制
    1. 调用System.gc()时，系统建议执行Full GC,但是不必然执行
    2. 老年代空间不足
    3. 方法区空间不足
    4. 通过Major GC后进入老年代的平均大小大于老年代的可用内存
    5. 由Eden区，survivor space0(From Space)区向survivor space1(To Space)区复制时，对象大小大于 To Space可用内存，则把对象转存到老年代，且老年代的可用内存小于该对象大小
    6. full GC是开发或调优中尽量要避免的。这样暂停时间会短一些

- 内存分配策略

  - 优先分配到Eden
  - 大对象直接分配到老年代，尽量避免程序中出现过多的大对象
  - 长期存活的对象分配到老年代
  - 动态对象年龄判断：如果Survivor区中相同年龄的所有对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄
  - 空间分配担保：-XX:HandlePromotionFailure

- TLAB(Thread Local Allocation Buffer)

  - 为什么有TLAB

    - 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据

    - 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的

    - 为避免多个线程操作同一地址，需要使用加锁机制，进而影响分配速度

  - 什么是TLAB

    - 从内存模型而不是垃圾收集的角度，对Eden区继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内
    - 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略
    - OpenJDK衍生出来的JVM一般都提供了TLAB的设计

  - TLAB的说明

    - 尽管不是所有的对象实例都能给在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选
    - 在程序中，开发人员可以公共选项-XX:UseTLAB设置是否开启TLAB空间（默认开启）
    - 默认情况下，TLAB空间的内存非常小，仅占整个Eden空间的1%，当然我们可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小
    - 一旦对象在TLAB空间分配失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存

- 堆空间的参数设置

  - -XX:+PrintFlagsInitial:查看所有的参数的默认初始值
  - -XX:+PrintFlagsFinal: 查看所有的参数的最终值(可能会修改，不再是初始值)
  - 具体查看个某参数的指令： jinfo -flag SurvivorRatio pid
  - -Xms: 初始堆空间内存（默认物理内存的1/64）
  - -Xmx:最大堆空间内存（默认物理内存的1/4）
  - -Xmn:设置新生代的大小
  - -XX:NewRatio: 配置新生代与老年代在堆结构的占比
  - -XX:SurvivorRatio:设置新生代中Eden和S0/S1空间的比例
  - -XX:MaxTenuringThreshold:设置新生代垃圾的最大年龄
  - -XX:+PrintGCDetails:输出详细的GC处理日志 打印gc简要信息：-XX:+PrintGC  -verbose:gc
  - -XX:HandlePromotionFailure:是否设置空间分配担保
  - 在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间
    - 如果大于，则此次Minor GC是安全的
    - 如果小于，则虚拟机会查看-XX:HandlePromotionFailure设置值是否允许担保失败。如果HandlerPromotionFailure=true,那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。如果大于，则尝试进行一次Minor GC，但这次Minor GC依然是有风险的。如果小于，则改为进行一次Full GC。如果HandlePromotionFailure=false,则改为进行一次Full GC
    - 在JDK6 Update24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化，虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC

- 堆是分配对象存储的唯一选择吗

  - 在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着JIT编译期的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么绝对了
  - 在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是如果经过逃逸分析Escape Analysis后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也就是最常见的堆外存储技术
  - 此外，前面提到的基于OpenJDK深度定制的TaoBaoVM,其中创新的GCIH(GC invisible heap)技术实现off-heap,将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的

- 逃逸分析概述

  - 如何将堆上的对象分配到栈，需要使用逃逸分析手段

  - 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法

  - 通过逃逸分析，Java HotSpot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上

  - 逃逸分析的基本行为就是分析对象动态作用域：

    - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸
    - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中

  - 在JDK6u23版本之后，HotSpot中默认已经开启了逃逸分析

  - 如果使用的是较早的版本可以通过-XX:+DoEscapeAnalysis打开

  - -XX:+PrintEscapseAnalysis查看逃逸分析的筛选结果

  - 开发中能使用局部变量的，就不要使用在方法外定义

  - 代码优化

    1. 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配

       - JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了
       - 场景的不在栈上分配的场景。逃逸出方法：给成员变量赋值，方法返回值，实例引用传递

    2. 同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步

       - 线程同步的代价是相当高的，同步的后果是降低并发性和性能
       - 在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除

    3. 分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分或全部可以不存储在内存，而是存储在CPU寄存器中

       - 标量Scalar是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量

       - 相对的，那些还可以分解的数据叫做聚合量Aggregate,Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量

       - 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换

       - 标量替换的好处：可以大大减少堆内存的占用。因为一旦不需要创建对象了，就不再需要分配堆内存了

       - -XX:+EliminateAllocations 开启标量替换(默认是开启的)

       - -server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations

         a. -server: 启动Server模式，因为在Server模式下，才可以启用逃逸分析

         b. -XX:+DoEscapeAnalysis:启用逃逸分析

         c. -XX:+PrintGC 打印GC日志

         d. -XX:+EliminateAllocations: 开启标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有id和name两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配
#### 方法区

- 基本概念

  - 《Java虚拟机规范》中明确说明：尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。所以，方法区看作是一块独立于Java堆的内存空间

  - 方法区Method Area与Java堆一样，是各个线程共享的内存区域
  - 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的
  - 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展
  - 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutOfMemoryError: PermGen space或者java.lang.OutOfMemoryError: Metaspace
  - 关闭JVM就会释放这个区域的内存
  - 在jdk7及以前，习惯上把方法区称为永久代。jdk8开始，使用元空间取代了永久代
  - 元空间不在虚拟机设置的内存中，而是使用本地内存

- 方法区大小设置和OOM

  -  jdk7及以前
    1. -XX:PermSize来设置永久代初始分配空间。默认值20.75M
    2. -XX:MaxPermSize来设定永久代最大可分配空间。32位默认是64M,64位机器默认是82M
    3. 当JVM加载的类信息容量超过了这个值，会报OutOfMemoryError: PermGen space
  - jdk8及以后
    1. -XX:MetaspaceSize和-XX:MaxMetaspaceSize来代替
    2. 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M,-XX:MaxMetaspaceSize的值是-1，没有限制
    3. 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出OutOfMemoryError: Metaspace
    4. -XX:MetaspaceSize:设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize的值为21M.这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对于的类加载器不再存活)，然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspaceSize时，适当提高该值。如果释放空间过多，则适当降低该值
    5. 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC,建议将-XX:MetaspaceSize设置为一个相对较高的值

- 如何解决OOM

  - 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具如Eclipse Memory Analyzer对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄露Memory Leak还是内存溢出Memory Overflow
  - 如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收他们的。掌握了泄露对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置
  - 如果不存在内存泄露，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数-Xmx和-Xms与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长，持有状态时间过长的情况，尝试减少程序运行期的内存消耗

- 方法区内部结构

  - 用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等
  - 类型信息：对每个加载的类型class, interface,enum,annotation。JVM必须在方法区中存储以下类型信息
    1. 这个类型的完整有效名称（全名=包名.类名）
    2. 这个类型直接父类的完整有效名(对于interface或是java.lang.Object都没有父类)
    3. 这个类型的修饰符(public, abstract, final的某个子集)
    4. 这个类型直接接口的一个有序列表
  - 域(Field)信息
    1. JVM必须在方法区中保存类型的所有域的相关信息以及域的生命顺序
    2. 域的相关信息包括:域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集)
  - 方法(Method)信息
    1. 方法名称
    2. 方法的返回类型(或void)
    3. 方法参数的数量和类型(按顺序)
    4. 方法的修饰符(public,private,protected,static,final,synchronzied,native,abstract的一个子集)
    5. 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)
    6. 异常表(abstract和native方法除外)。每个异常处理的开始位置，结束位置，代码处理在程序计数器中的偏移地址，被捕获的异常类的常量池索引
  - non-final的类变量
    1. 静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分
    2. 类变量被类的所有实例共享，即使没有类实例也可以访问
  - 全局常量 staic final: 被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就被分配了
  - 运行时常量池vs常量池
    1. 方法区，内部包含了运行时常量池
    2. 字节码文件，内部包含了常量池
    3. 要弄清楚方法区，需要理解清楚ClassFile,因为加载类的信息都在方法区
    4. 要弄清楚方法区的运行时常量池，需要理解清楚ClassFile中的常量池
    5. 常量池(Constant Pool Table)包括各种字面量和对类型、域和方法的符号引用
  - 常量池
    1. 一个Java源文件中的类、接口编译后产生的一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存储到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池。
    2. 常量池内存储的数据类型包括：数量值，字符串值，类引用，字段引用，方法引用
    3. 常量池可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型
  - 运行时常量池
    1. 运行时常量池Runtime Constant Pool是方法区的一部分
    2. 常量池表Constant Pool Table是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
    3. 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池
    4. JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的
    5. 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。运行时常量池相对于Class文件常量池的另一重要特征是：具备动态性 String.intern()
    6. 运行时常量池类似于传统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些
    7. 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛出OutOfMemoryError异常

- HotSpot方法区的演进

  - 1.6及以前：有永久代permanent generation,静态变量存放在永久代上
  - 1.7有永久代，但已经逐步去永久代，字符串常量池、静态变量，保存在堆中
  - 1.8及以后：无永久代，类型信息、字段、方法、常量保存在本地内存的元空间，单字符串常量池、静态变量仍在堆中

- 永久代为什么要被元空间替换

  - 随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间Metaspace
  - 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间
  - 为永久代设置空间大小是很难确定的。在某些场景下，如果动态加载类过多，容易产生Perm区的OOM.比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。而元空间和永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制
  - 对永久代进行调优是很困难的

- StringTable为什么要调整

  - jdk7中将StringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足，永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收

- 静态引用对应的对象实体始终在堆空间

  - JDK7及其以后的版本HotSpot虚拟机选择把静态变量与类型在Java语言一端的映射Class对象存放在一起，存储于Java堆之中

- 方法区的垃圾收集

  - 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型
  - 方法区内常量池之中主要存放两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串，被声明为final的常量值。而符号引用则属于编译原理方面的概念，包括下面三类常量：类和接口的全限定名，字段的名称和描述符，方法的名称和描述符
  - HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以回收
  - 回收废弃常量与回收Java堆中的对象非常类似
  - 判断一个常量是否废弃还是相对简单，而要判断一个类型是否属于不再使用的类的条件就比较苛刻了。需要同时满足下面三个条件
    1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例
    2. 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGI,JSP的冲加载等，否则很难达成的
    3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
  - Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是和对象一样，没有引用了就必然回收。关于是否要对类型进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading, -XX:+TraceClassUnLoading查看类加载和卸载信息
  - 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGI这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力



### 对象的实例化内存布局与访问定位

#### 对象的实例化

- 对象创建的方式
  - new 
  - Class的newInstance()
  - Constructor的newInstance(Xxx)
  - 使用clone()
  - 使用反序列话
  - 第三方库Objenesis
- 对象创建的步骤
  - 判断对象对应的类是否加载，链接，初始化。虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象
  - 为对象分配内存。
    - 如果内存规整：使用指针碰撞。如果内存是规整的，那么虚拟机将采用的是指针碰撞法Bump The Pointer来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial,ParNew这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有compact整理过程的收集器时，使用指针碰撞
    - 如果内存不规整：虚拟机需要维护一个列表，空闲列表分配。如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空姐划分给对象实例，并更新列表上的内容。这种分配方式称为空闲列表Free List
    - 说明：选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
  - 处理并发安全问题：采用CAS配上失败重试保证更新的原子性；每个线程预先分配一块TLAB。在分配内存空间时，另外一个问题是及时保证new对象时候的线程安全性：创建对象是非常频繁的操作，虚拟机需要解决并发问题。虚拟机采用了两种方式解决并发问题：
    - CAS(Compare And Swap)失败重试，区域加锁；保证指针更新操作的原子性
    - TLAB把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区,虚拟机是否使用TLAB,可以通过-XX:+UseTLAB参数来设定
  - 初始化分配到的空间：所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用。内存分配结束，虚拟机将分配到的内存空间都初始化为零值(不包括对象头)，这一步保证了对象的实例字段在Java代码中可以不用赋初始值就可以直接使用，程序能访问到这些字段的数据类型为所对应的零值
  - 设置对象的对象头：将对象的所属类(即类的元数据信息)、对象的hashCode和对象的GC信息，锁信息等数据存储在对象的对象头中。这个过程的具体设置放是取决于JVM
  - 执行init方法进行初始化:在Java程序的视角来看，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量，因此一般来说(有字节码中是否跟随有invokespecial指令所决定)，new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来
- 对象内存布局
- 对象访问定位
- 直接内存 Direct Memory
  - 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域
  - 直接内存是在Java堆外的、直接向系统申请的内存区间
  - 来源于NIO,通过存在堆外中的DirectByteBuffer操作Native内存
  - 通常，访问直接内存的速度会优于Java堆。即读写性能搞。因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
  - 也可能导致OutOfMemory异常:Direct buffer memory 
  - 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存
  - 分配回收成本高，不受JVM内存回收管理
  - 直接内存大小可以通过MaxDirectMemorySize设置
  - 如果不指定，默认与堆的最大值-Xmx参数值一致
- Java process memory = java heap + native memory(metaspace+direct memory)



### 执行引擎

#### 概述

- 执行引擎是Java虚拟机核心组成部分之一
- 虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件的制约的定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式
- JVM的主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被JVM所识别的字节码指令、符号表，以及其他辅助信息
- 那么，如果想要让一个Java程序运行起来，执行引擎Execution Engine的任务就是将字节码指令解释、编译为对应平台上的本地机器指令才可以。简单来说，JVM中的执行引擎充当了将高级语言翻译为机器语言的译者

#### 执行引擎工作过程

- 执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于PC寄存器
- 每当执行完一项指令操作后，PC寄存器就会更新下一条需要被执行的指令地址
- 当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在Java堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息
- 从外观上来看，所有的Java虚拟机的执行引擎输入输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果

#### Java代码编译和执行的过程

- 解释器：当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行

- JIT(Just In Time Compiler)编译器：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言

- 为什么说Java是半编译半解释型语言：JDK1.0时代，将Java语言定位为解释执行还是比较准确的。再后来Java也发展出可以直接生成本地代码的编译器。现在JVM在执行Java代码的时候，通常都会将解释执行与编译执行二者结合起来执行

#### 机器码、指令、汇编语言

- 机器码

  - 各种用二进制编码方式表示指令，叫做机器指令码。开始，人们就用它编写程序，这就是机器语言
  - 机器语言虽然能给被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用他编程容易出差错
  - 用他编写的程序一经输入计算机，CPU直接读取运行，因此和其他语言遍的程序相比，执行速度最快
  - 机器指令与CPU紧密相关，所以不同种类的CPU所对应的机器指令也就不同

- 指令

  - 由于机器码是由0和1组成的二进制序列，可读性太差，于是人们发明了指令。
  - 指令就是把机器码中特定的0，1序列，简化成对应的指令，可读性好
  - 由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令，对应的机器码也可能不同

- 指令集

  - 不同的硬件平台，各自支持的指令是有差别的。因此每个平台所支持的指令，称为对应平台的指令集
  - x86指令集，ARM指令集
  
- 汇编语言
  
  - 由于指令的可读性还是太差，于是人们又发明了汇编语言
  - 在汇编语言中，用助记符Mnemonics代替机器指令的操作码，用地址符号Symbol或标号Label代替指令或操作数的地址
  - 在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。由于计算机只认识指令码，所以用汇编语言编写的程序还必须翻译成机器指令码，计算机才能识别和执行

#### 解释器  

#### JIT编译器



### StringTable

#### String基本特效

- String:字符串，使用""引起来表示
- String声明为final,不可被继承
- String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小
- String在jdk8及以前内部定义了final char[] value用于存储字符串数据，jdk9改为byte[]
- String代表不可变的字符序列。简称：不可变性
  1. 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值
  2. 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
  3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值
- 通过字面量的方式(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中
- 字符串常量池中是不会存储相同内容的字符串的
- String的String Pool是一个固定大小的Hashtable,默认值大小长度是1009.如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern()时性能会大幅下降
- 使用-XX:StringTableSize可设置StringTable的长度
- 在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求
- 在jdk7中StringTable的长度默认值是60013
- jdk8设置StringTable长度的话，1009是可设置的最小值
- str.intern():如果字符串常量池中没有对应的str的字符串的话，则在常量池中生成

#### String的内存分配

- 在Java语言中有8种基本类型和一种比较特殊的类型String.这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念
- 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种
  - 直接使用双引号声明出来的String对象会直接存储在常量池中。
  - 如果不是用双引号声明的String对象，可以使用String提供的intern()方法
- StringTable为什么要调整
  - permSize默认比较小
  - 永久代垃圾回收效率比较低
- 字符串拼接操作
  - 常量与常量的拼接结果在常量池，原理是编译器优化
  - 常量池中不会存在相同内容的常量
  - 只有其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
  - 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象的地址

#### intern()的使用

- interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。

  

### 垃圾回收

#### 概述

- 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾
- An object is considered garbage when it can no longer be reached from any pointer in the running program
- 如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序中，被保留的空间无法被其他对象使用。甚至可能导致内存溢出

#### 垃圾回收相关算法

- 标记阶段

  - 垃圾标记阶段：对象存活判断
  - 在堆里存放着几乎所有的Java对象实例，在GC执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为已经死亡的对象，GC才会在执行垃圾回收时，释放掉所占用的内存空间，因此这个过程我们可以称为垃圾标记阶段
  - 当一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡
  - 判断对象存活一般有两种方式：引用计数算法和可达性分析算法
- 标记阶段：引用计数算法

  1. 应用计数算法Reference Counting比较简单，对每个多选保存一个整型的引用计数器属性。用于记录对象被引用的情况
  2. 对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加1；当引用失效时，引用计数器就减1.只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收
  3. 优点：实现简单，垃圾对象便于识别；判定效率高，回收没有延迟性
  4. 缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销；每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销；引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法
- 标记阶段：可达性分析（根搜索算法、追踪性垃圾收集）
  - 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄露的发生
  - 相较于引用计数算法，这里的可达性分析就是Java,C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集 Tracing Garbage Collection
  - 可达性分析算法是以根对象集合GC Roots为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
  - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链Reference Chain
  - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象已经死亡，可以标记为垃圾对象
  - 在可达性分析算法中，只有能给被根对象集合直接或间接连接的对象才是存活对象
  - GC Roots
    1. 虚拟机栈中引用的对象：比如各个线程被调用的方法中使用到的参数，局部变量等
    2. 本地方法栈内JNI引用的对象
    3. 方法区中类静态属性引用的对象。比如：Java类的引用类型静态变量
    4. 方法区中常量引用的对象：比如：字符串常量池String Table里的引用
    5. 所有被同步锁synchronized持有的对象
    6. Java虚拟机内部的引用。基本数据类型对应的Class对象，一些常驻的异常对象(NullPointerException, OutOfMemoryException),系统加载类
    7. 反映Java虚拟机内部情况的JMXBean, JVM中注册的回调，本地代码缓存等
    8. 除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。比如：分代收集和局部回收Partial GC.。如果只针对Java堆中的某一块区域进行垃圾回收(典型的只针对新生代)，必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入GC Roots集合中去考虑，才能保证可达性分析的准确性
    9. 由于Root采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root
    10. 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须Stop The World的一个重要原因。即使是号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的
- 对象的finialization机制
  - Java语言提供了对象终止finalization机制来允许开发人员提供对象被销毁之前的自定义处理逻辑
  - 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法
  - Finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件，套接字和数据库连接等
  - 永远不要主动调用某个对象的finialize()方法，应该交给垃圾回收机制调用。
    1. 在finalize()时可能会导致对象复活
    2. finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC,则finalize()方法将没有执行机会
    3. 一个糟糕的finialize()会严重影响GC的性能
  - 从功能上来说，finalize()方法与C++中的析构函数比较类似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于C++中的析构函数
  - 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态
    1. 可触及的：从根节点开始，可以到达这个对象
    2. 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活
    3. 不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及的状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次
  - 判断一个对象objA是否可回收，至少要经历两次标记过程
    1. 如果对象objA到GC Roots没有引用链，则进行一次标记
    2. 进行筛选，判断此对象是否有必要执行finalize()方法
       - 如果对象objA没有重写finalize()方法，或者finalize()方法已经被虚拟机调用过，则虚拟机视为没有必要执行，objA被判定为不可触及的
       - 如果对象objA重写了finalize()方法，并且还为执行过，那么objA会被插入到F-Queue队列中，由一个虚拟机自动创建的，低优先级的Finalizer线程触发其finalize()方法执行
       -  Finalize()方法是对象逃脱死亡的最后机会，稍后GC会对F-Queue队列中的对象进行第二次标记。如果objA在finalize()方法中与引用链上的任何一个对象建立了联系，那么第二次标记时，objA会被移出即将回收集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize()方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，一个对象的finalize方法只会被调用一次
- MAT与JProfiler的GC Roots溯源
  - 获取dump文件
    1. jmap -dump:format=b,live,file=test.bin pid
    2. JVisualVM导出。
- 垃圾清除阶段
  - 当成功区分出内存中存活对象和死亡对象后，GC接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存
  - 目前在JVM中比较常见的饿三种垃圾收集算法是标记-清除算法Mark-Sweep，复制算法Copying，标记-压缩算法Mark-Compact
- 标记-清除(Mark-Sweep)算法
  - 背景：标记-清除算法是一种非常基础和常见的垃圾收集算法，该算法被J.McCarthy等人在1960年提出并应用于Lisp语言
  - 执行过程：当堆中的有效内存空间available memory被耗尽的时候，就会停止整个程序(stop the world),然后进行两项工作，第一项则是标记，第二项是清除
    1. 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象
    2. 清除：Collector对堆内存从头到尾进行线性遍历，如果发现某个对象在Header中没有标记为可达对象，则将其回收
  - 缺点：
    1. 效率不算高
    2. 在进行GC的时候，需要停止整个应用程序，导致用户体验差
    3. 这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表
- 复制Copying算法
  - 将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清楚正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收
  - 优点：没有标记和清除的过程，实现简单，运行高效；复制过去以后保证空间的连续性，不会出现碎片问题
  - 缺点：需要两倍的内存空间。对于G1这种分拆成为大量region的GC,复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。
  - 如果系统中的垃圾对象很多，复制算法需要复制的存活对象数量并不会太大，或者说非常低才行
  - 应用场景：在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间，回收性价比很高。
- 标记压缩算法
  - 第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象。第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后清理边界外所有的空间。
  - 优点：消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。消除了复制算法当中，内存减半的高额代价
  - 缺点：从效率上来说，标记-整理算法要低于复制算法；移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址；移动过程中，需要全程暂停用户应用程序，即：STW
- 分代收集算法
  - 年轻代：复制算法
  - 老年代：Mark-Sweep-Compact
  - 以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial Old回收器作为补偿措施：当内存回收不佳(碎片导致的Concurrent Mode Failure时)，将采用Serial Old执行Full GC以达到对老年代内存的整理。
- 增量收集算法
  - 上述现有的算法，在垃圾回收过程中，应用软件将处于一中Stop The World的状态。在Stop The World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集Increment Collecting算法的诞生
  - 如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。一次反复，直到垃圾收集完成。总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。
  - 缺点：使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间，但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。
- 分区算法
  - 一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。
  - 分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小空间
  - 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间

#### 垃圾回收相关概念

- System.gc()的理解
  - 在默认 情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC,同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存
  - 然后System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用
  - JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc()
- 内存溢出与内存泄露
  - 内存溢出相对于内存泄露来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一
  - 由于GC一直在发展，所有一般情况下，除非应用程序所占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现OOM的情况
  - 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用
  - javadoc中对OutOfMemory的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存
  - 堆内存不够：Java虚拟机的堆内存设置不够；代码中创建了大量大对象，并且长时间不能被垃圾收集器收集(存在被引用)
  - 内存泄露，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄露。
  - 但实际情况很多时候一些不太好的实践或疏忽会导致对象的生命周期变得很长甚至导致OOM,也可以叫做宽泛意义上的内存泄露。
  - 单例模式：单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄露的产生
  - 一些提供close的资源未关闭导致内存泄露，数据库连接，网络连接，和IO连接必须手动close，否则是不能被回收的
- Stop The World
  - 停顿产生时整个应用程序线程都会被暂停，没有任何响应。
  - 可达性分析算法中枚举根节点会导致所有Java执行线程停顿。
    1. 分析工作必须在一个能确保一致性的快照中进行
    2. 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
    3. 如果分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
  - 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。
  - STW事件和采用哪款GC无关，所以的GC都有这个事件
  - 哪怕是G1也不能完全避免STW情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
  - STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。
  - 开发中不要用System.gc();会导致STW的发生
- 垃圾回收的并行与并发
  - 并行Parallel:指多条垃圾收集线程并行工作，但此时用户线程扔处于等待状态。ParNew,Parallel Scavenge,Parallel Old
  - 串行Serial:相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程
  - 并发Concurrent:指用户线程与垃圾收集线程同时执行，垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序运行于另一个CPU上；如CMS,G1
- 安全点与安全区域
  - 程序执行时并非在所有地方都能停顿下来开始GC,只有在特定的位置才能停顿下来开始GC,这些位置称为安全点Safepoint
  - Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据是否具有让程序长时间执行的特征为标准。比如：选择一些执行时间较长的指令作为Safe Point,如方法调用、循环跳转和异常跳转等。
  - 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来呢
    1. 抢先式中断：目前没有虚拟机采用了。首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点
    2. 主动式中断：设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起
  - Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序不执行的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，走到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域Safe Region来解决
  - 安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint
  - 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC,JVM会忽略标识为Safe Region的状态的线程；当线程即将离开Safe Region时，会检查JVM是否已经完成GC,如果完成了，则继续进行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止
- 强引用
  - 最传统的引用定义，是指在程序代码中普遍存在的引用赋值，即Object obj = new Object();无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象
  - 强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象
  - 强引用是造成Java内存泄露的主要原因之一
- 软引用 - 内存不足即回收
  - 在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常
- 弱引用 - 发现即回收
  - 被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
- 虚引用
  - 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联目的就是能在这个对象被收集器回收时收到一个系统通知
  - 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
  - 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。
- 终结器引用
  - 它用以实现对象的finalize()方法，也可以称为终结器引用
  - 无需手动编码，其内部配合引用队列使用
  - 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象

#### 垃圾回收器

- GC分类与性能指标

  - 按线程数分，可以分为串行垃圾回收器和并行垃圾回收器
  - 按工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器
  - 按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器
  - 按工作的内存区域分，可分为年轻代垃圾回收器和老年代垃圾回收器
  - 评估GC的性能指标
    1. 吞吐量：运行用户代码的时间占总运行时间的比例
    2. 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例
    3. 暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间
    4. 收集频率：相对于应用程序的执行，收集操作发生的频率
    5. 内存占用：Java堆区所占的内存大小
    6. 快速：一个对象从诞生到被回收所经历的时间

- 不同的垃圾回收器概述

  - 串行回收器： Serial , Serial Old

  - 并行回收器：ParNew, Parallel Scavenge, Parallel Old
  - 并发回收器：CMS, G1
  - 查看默认回收器：+XX:PrintCommandLineFlags

- Serial回收器 - 串行回收

  - Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代的唯一选择
  - Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器
  - Serial收集器采用复制算法、串行回收和Stop The World机制的方式执行内存回收
  - 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和Stop The World机制，只不过内存回收算法使用的是标记-压缩算法
  - Serial Old是运行在Client模式下默认的老年代的垃圾回收器
  - Serial Old在Server模式下主要有两个用途：与新生代的Parallel Scavenge配合使用；作为老年代CMS收集器的后备垃圾收集方案 
  - 这个收集器是一个单线程收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束Stop The World
  - 优势：简单高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率
  - 在用户的桌面应用场景中，可用内存一般不大，可以在较短时间内完成垃圾收集，只要不频繁发生，使用串行回收是可以接受的
  - -XX:+UseSerialGC指定年轻代和老年代都使用串行回收器

- ParNew回收器 - 并行回收

  - Par是Parallel的缩写，New:只能处理新生代
  - ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器
  - 除Serial之外，目前只有ParNew GC能与CMS收集器配合工作

- Parallel回收器 - 吞吐量优

  - 高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理，订单处理，工资支付，科学计算的应用程序

  - Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代Serial Old收集器
  - Parallel Old收集器采用了标记-压缩算法，但同样也是基于并行回收和Stop The World机制
  - -XX:+UseParallelGC 手动指定年轻代视频并行收集器执行内存回收任务
  - -XX:+UseParallelOldGC手动指定老年代
  - -XX:ParallelGCThreads设置年轻代并行垃圾收集器的线程数 CPU < 8 , ParallelGCThreads = CPU; CPU > 8, ParallelGCThreads=3+(5*CPU)/8
  - -XX:MaxGCPauseMillis设置垃圾收集器最大停顿时间(即STW的时间)。单位ms
  - -XX:GCTimeRatio垃圾收集时间所占时间的比例 1 / (N + 1)。0 - 100，默认99，也就是垃圾回收时间不超过1%
  - -XX:+UseAdaptiveSizePolicy设置Parallel Scavenge收集器具有自适应调节策略

- CMS回收器 - 低延迟

  - JDK1.5, Concurrent Mark Sweep，是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用于线程同时工作
  - CMS采用标记-清除算法，并且也会STW
  - CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短(低延迟)就越适合于用户交互的程序，良好的响应速度能提升用户体验。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短。
  - 初始标记 Initial Mark阶段：在这个阶段中，程序中所有的工作线程都将会因为STW机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记处GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联的对象比较小，所以这里的速度非常快
  - 并发标记Concurrent Mark阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时比较长，但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行
  - 重新标记Remark阶段:由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
  - 并发消除Concurrent Sweep阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
  - 由于最耗时间的并发标记和并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的
  - 优点：并发收集，低延迟
  - 缺点：会产生内存碎片，CMS收集器对CPU资源非常敏感，CMS收集器无法处理浮动垃圾
  - -XX:+UseConcMarkSweepGC手动指定使用CMS收集器。开启该参数后自动将-XX:+UseParNewGC打开。即ParNew(Young) + CMS(old) + Serial Old的组合
  - -XX:CMSInitiatingOccupanyFraction设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5以前默认68，JDK6及以后默认92。如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数
  - -XX:+UseCMSCompactAtFullCollection用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。
  - -XX:CMSFullGCsBeforeCompaction设置在执行多少次Full GC后对内存空间进行压缩整理
  - -XX:ParallelCMSThreads设置CMS的线程数量默认 (ParallelGCThreads + 3) / 4

- G1回收器 - 区域化分代式

  - G1是一款面向服务端应用的垃圾收集器，主要针对配备多核CPU及大容量内存的机器，以极高概率满足GC停顿时间的同时，还兼具高吞吐量的性能特征
  - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力，此时用户STW
  - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况
  - 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代是连续的，也不再坚持固定大小和固定数量
  - 将堆空间分为若干个区域，这些区域中包含了逻辑上的年轻代和老年代
  - 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代或者老年代
  - 空间整合：G1将内存划分为一个个的region.内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩算法。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显
  - 可预测的停顿时间模型(即软实时soft real-time):这是G1相较于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒
    1. 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制
    2. G1跟踪各个Region里面的垃圾堆的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region.保证了G1收集器在有限的时间内可以获取尽可能高的收集效率
    3. 相比于CMS GC, G1未必能做到CMS在最好情况下的延迟停顿，但是最差情况要好很多
  - 缺点：相较于CMS，G1还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1无论是为了垃圾收集产生的内存占用Footprint还是程序运行时的额外执行负载Overload,都要比CMS要高。从经验上来说，在小内存应用上CMS的表现大概率由于G1,而G1在大内存应用上则发挥其优势。平衡点在6-8GB之间
  - -XX:+UseG1GC
  - -XX:G1HeapRegionSize.设置每个region大小。默认堆内存的1/2000.值是2的幂，范围1MB-32MB
  - -XX:MaxGCPauseMillis设置期望达到的最大GC停顿时间指标。默认200ms
  - -XX:ParallelGCThread 设置STW工作线程数的值。最大8
  - -XX:ConcGCThreads 设置并发标记的线程数。
  - -XX:InitiatingHeapOccupancyPercent设置触发并发GC周期的Java堆占用率阈值。超过此值，就出发GC,默认45
  - G1回收器的操作步骤：1.开启G1 2.设置堆的最大内存 3.设置最大的停顿时间
  - G1垃圾收集器还增加了一种新的内存区域，Humongous内存区域，用于存储大对象。如果超过1.5个Region,就放到H
  - 年轻代回收过程：扫描根，更新RSet，处理RSet，复制对象，处理引用
  - 并发标记过程：初始标记，根区域扫描，并发标记，再次标记，独占清理，并发清理
  - 混合回收

- 总结

- GC日志分析



### 字节码文件

#### Class文件

- 字节码指令byte code: Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的操作码opcode以及跟随其后的零至多个代表此操作所需参数的操作数operand所构成。虚拟机中许多指令并不包含操作数，只有一个操作码

- Class 类的本质：任何一个Class文件都对应着唯一一个类或接口定义信息，但反过来说，Class文件实际上它并不一定以磁盘文件的形式存在。Class文件是一组以8bit字节为基础单位的二进制流

- Class文件格式采用一种类似于C语言结构体的方式进行数据存储，这种结构只有两种数据类型：无符号数和表。

  - 无符号数属于基本的数据类型，以u1,u2,u4,u8来分别代表1个字节，2个字节，4个字节，8个字节的无符号数，无符号数可以用来描述数字，索引引用，数量值或者按照UTF-8编码构成字符串值
  - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯地以_info结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。由于表没有固定长度，所以通常会在其签名加上个数说明

- Class文件结构：

  - 魔数: magic(u4)

  - Class文件版本:  minor_version(u2) , major_version(u2)

  - 常量池 :  constant_pool_count(u2) , constant_pool[constant_pool_count - 1]

    | 类型                             | 标识或标志 | 描述                 |
    | -------------------------------- | ---------- | -------------------- |
    | CONSTANT_utf8_info               | 1          | UTF-8编码的字符串    |
    | CONSTANT_Integer_info            | 3          | 整型字面量           |
    | CONSTANT_Float_info              | 4          | 浮点型字面量         |
    | CONSTANT_Long_info               | 5          | 长整型字面量         |
    | CONSTANT_Double_info             | 6          | 双精度浮点型字面量   |
    | CONSTANT_Class_info              | 7          | 类或接口的符号引用   |
    | CONSTANT_String_info             | 8          | 字符串类型字面量     |
    | CONSTANT_Fieldref_info           | 9          | 字段的符号引用       |
    | CONSTANT_Methodref_info          | 10         | 类中方法的符号引用   |
    | CONSTANT_InterfaceMethodref_info | 11         | 接口中方法的符号引用 |
    | CONSTANT_NameAndType_info        | 12         | 字段或方法的符号引用 |
    | CONSTANT_MethodHandle_info       | 15         | 表示方法句柄         |
    | CONSTANT_MethodType_info         | 16         | 表示方法类型         |

    1. 常量池主要存放两大类常量：字面量Literal和符号引用Symbolic Reference

    2. 字面量：文本字符串，声明为final的常量值

    3. 符号引用：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符

    4. 描述符的作用是用来描述字段的数据类型，方法的参数列表(数量，类型，顺序)和返回值。

       | 标志符 | 含义                                       |
       | ------ | ------------------------------------------ |
       | B      | byte                                       |
       | C      | char                                       |
       | D      | double                                     |
       | F      | float                                      |
       | I      | int                                        |
       | J      | long                                       |
       | S      | short                                      |
       | Z      | boolean                                    |
       | V      | void                                       |
       | L      | 对象类型，比如 Ljava/lang/Object;          |
       | [      | 数组类型，代表一维数组。比如double[] is [D |
       
       
  
  - 访问标志 : access_flags(u2)
  
  - 类索引，父类索引，接口索引集合: this_class(u2), super_class(u2), interfaces_count(u2), interfaces(u2)
  
  - 字段表集合: fields_count(u2), fields[fields_count]
  
  - 方法表集合:methods_count(u2), methods[methods_count]
  
  - 属性表集合: attributes_count(u2), attributes[attributes_count]

