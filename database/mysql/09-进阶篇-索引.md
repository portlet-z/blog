## 索引概述

### 介绍

- 索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

### 优缺点

- 优势：
  - 提高数据检索的效率，降低数据库的IO成本
  - 通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗
- 劣势
  - 索引也是要占用空间的
  - 索引大大提高了查询效率，同时也降低了更新表的速度，如对表进行INSERT, UPDATE, DELETE时，效率降低

## 索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree索引          | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash索引            | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
| R-Tree(空间索引)    | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene, Solr, ES |

| 索引       | InnoDB          | MyISAM | Memory |
| ---------- | --------------- | ------ | ------ |
| B+Tree索引 | 支持            | 支持   | 支持   |
| Hash索引   | 不支持          | 不支持 | 支持   |
| R-Tree索引 | 不支持          | 支持   | 不支持 |
| Full-text  | 5.6版本之后支持 | 支持   | 不支持 |

### 二叉树

- 二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢
- 红黑树：大数据量情况下，层级较深，检索速度慢

## B-Tree

- B-Tree(多路平衡查找树)：以一颗最大度数(max-degree)为5(5阶)的b-tree为例(每个节点最多存储4个key, 5个指针)
- 树的度数指的是一个节点的子节点个数

![](./images/B-tree.png)

### B+Tree

相对于B-Tree区别

- 所有的数据都会出现在叶子节点
- 叶子节点形成一个单向链表

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree,提高区间访问的性能。

![](./images/B+Tree.png)

### Hash索引

- 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中
- 如果两个（或多个）键值，映射到同一个槽位上，他们就产生了hash冲突，可以通过链表来解决
- hash索引特点
  - Hash索引只能用于对等比较(=, in),不支持范围查询(between, >, <, ...)
  - 无法利用索引完成排序操作
  - 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引
- 存储引擎支持：在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的

### InnoDB引擎选择B+Tree索引结构原因

- 相对于二叉树，层级更少，搜索效率高
- 对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
- 相对于hash索引，B+Tree支持范围匹配及排序操作

## 索引分类

| 分类     | 含义                                                 | 特点                     | 关键字    |
| -------- | ---------------------------------------------------- | ------------------------ | --------- |
| 主键索引 | 针对表中主键创建的索引                               | 默认自动创建，只能有一个 | PRIMARY   |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE    |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |           |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULL TEXT |

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种

| 分类                      | 含义                                                       | 特点                 |
| ------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

聚集索引选取规则

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引
- 如果表没有主键，或者没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

思考：InnoDB主键索引的B+Tree高度为多高

假设：一行数据大小为1K, 一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint,占用字节数为8

高度为2：n * 8 + (n + 1) * 6 = 16 * 1024, 算出n约为1170

1171 * 16 = 18736

高度为3： 1171 * 1171 * 16 = 21939856

## 索引语法

- 创建索引

```sql
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);
```

- 查看索引

```sql
SHOW INDEX FROM table_name;
```

- 删除索引

```sql
DROP INDEX index_name ON table_name;
```

## SQL性能分析

### SQL执行频率

- MySQL客户端连接成功后，通过show [session|global] status命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT, UPDATE, DELETE, SELECT的访问频次

```sql
SHOW GLOBAL STATUS LIKE 'Com_______';
```

### 慢查询日志

- 慢查询日志记录了所有执行时间超过指定参数(long_query_time, 单位：秒，默认10秒)的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件(/etc/my.cnf)中配置如下信息

```
# 开启MySQL慢日志查询开关
slow_query_log = 1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time = 2
```

- 配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 /var/lib/mysql/localhost-slow.log

### profile详情

- show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MySQL是否支持profile操作

```sql
SELECT @@have_profiling;
```

- 默认profiling是关闭的，可以通过set语句在session/global级别开启profiling

```sql
SET profiling = 1;
```

- 执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时

```sql
# 查看每一条SQL的耗时基本情况
show profiles;
# 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
# 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```

### explain执行计划

- EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括SELECT语句执行过程中如何连接和连接的顺序。

```sql
# 直接在select语句之前加上关键字explian / desc
explain select 字段 from 表名 where 条件;
```

- explain执行计划各个字段的含义
  - id: select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同值越大，越先执行)
  - select_type: 表示SELECT的类型，常见的取值有SIMPLE(简单表，即不使用表连接或者子查询)，PRIMARY(主查询，即外层的查询)，UNION(UNION中的第二个或者后面的查询语句)，SUBQUERY(SELECT/WHERE之后包含了子查询)等
  - type: 表示连接类型，性能由好到差的连续类型为NULL, system, const, eq_ref, ref, range, index, all
  - possible_key: 显示可能应用在这张表上的索引，一个或多个
  - key: 实际使用的索引，如果为NULL,则没有使用索引
  - key_len: 表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好
  - rows: MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估值，可能并不总是准确的
  - filtered: 表示返回结果的行数占需要读取行数的百分比，filtered的值越大越好

## 索引使用



## 索引设计原则