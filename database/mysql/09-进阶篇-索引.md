## 索引概述

### 介绍

- 索引(index)是帮助MySQL高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引

### 优缺点

- 优势：
  - 提高数据检索的效率，降低数据库的IO成本
  - 通过索引对数据进行排序，降低数据排序的成本，降低CPU的消耗
- 劣势
  - 索引也是要占用空间的
  - 索引大大提高了查询效率，同时也降低了更新表的速度，如对表进行INSERT, UPDATE, DELETE时，效率降低

## 索引结构

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree索引          | 最常见的索引类型，大部分引擎都支持B+树索引                   |
| Hash索引            | 底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效，不支持范围查询 |
| R-Tree(空间索引)    | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引，快速匹配文档的方式，类似于Lucene, Solr, ES |

| 索引       | InnoDB          | MyISAM | Memory |
| ---------- | --------------- | ------ | ------ |
| B+Tree索引 | 支持            | 支持   | 支持   |
| Hash索引   | 不支持          | 不支持 | 支持   |
| R-Tree索引 | 不支持          | 支持   | 不支持 |
| Full-text  | 5.6版本之后支持 | 支持   | 不支持 |

### 二叉树

- 二叉树缺点：顺序插入时，会形成一个链表，查询性能大大降低。大数据量情况下，层级较深，检索速度慢
- 红黑树：大数据量情况下，层级较深，检索速度慢

## B-Tree

- B-Tree(多路平衡查找树)：以一颗最大度数(max-degree)为5(5阶)的b-tree为例(每个节点最多存储4个key, 5个指针)
- 树的度数指的是一个节点的子节点个数

![](./images/B-tree.png)

### B+Tree

相对于B-Tree区别

- 所有的数据都会出现在叶子节点
- 叶子节点形成一个单向链表

MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加了一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree,提高区间访问的性能。

![](./images/B+Tree.png)

### Hash索引

- 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中
- 如果两个（或多个）键值，映射到同一个槽位上，他们就产生了hash冲突，可以通过链表来解决
- hash索引特点
  - Hash索引只能用于对等比较(=, in),不支持范围查询(between, >, <, ...)
  - 无法利用索引完成排序操作
  - 查询效率高，通常只需要一次检索就可以了，效率通常要高于B+Tree索引
- 存储引擎支持：在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的

### InnoDB引擎选择B+Tree索引结构原因

- 相对于二叉树，层级更少，搜索效率高
- 对于B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低
- 相对于hash索引，B+Tree支持范围匹配及排序操作

## 索引分类

| 分类     | 含义                                                 | 特点                     | 关键字    |
| -------- | ---------------------------------------------------- | ------------------------ | --------- |
| 主键索引 | 针对表中主键创建的索引                               | 默认自动创建，只能有一个 | PRIMARY   |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE    |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |           |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULL TEXT |

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种

| 分类                      | 含义                                                       | 特点                 |
| ------------------------- | ---------------------------------------------------------- | -------------------- |
| 聚集索引(Clustered Index) | 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据 | 必须有，而且只有一个 |
| 二级索引(Secondary Index) | 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 | 可以存在多个         |

聚集索引选取规则

- 如果存在主键，主键索引就是聚集索引
- 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引
- 如果表没有主键，或者没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引

思考：InnoDB主键索引的B+Tree高度为多高

假设：一行数据大小为1K, 一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint,占用字节数为8

高度为2：n * 8 + (n + 1) * 6 = 16 * 1024, 算出n约为1170

1171 * 16 = 18736

高度为3： 1171 * 1171 * 16 = 21939856

## 索引语法

- 创建索引

```sql
CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name (index_col_name,...);
```

- 查看索引

```sql
SHOW INDEX FROM table_name;
```

- 删除索引

```sql
DROP INDEX index_name ON table_name;
```

## SQL性能分析

## 索引使用

## 索引设计原则