## 变量与可变性

- 声明变量使用let关键字
- 默认情况下，变量是不可变的(immutable)
- 声明变量时，在变量前面加上mut, 就可以使变量可变

### 变量与常量

- 常量(constant),常量在绑定值以后也是不可变的，但是它与不可变的变量有很多区别
  - 不可以使用mut，常量永远都是不可变的
  - 声明常量使用const关键字，它的类型必须被标注
  - 常量可以在任何作用域内进行声明，包括全局作用域
  - 常量只可以绑定到常量表达式，无法绑定到函数的调用结果或只能在运行时才能计算出的值
- 在程序运行期间，常量在其声明的作用域内一直有效
- 命令规范：Rust常量使用全大写字母，每个单词直接用下划线分开，例如：MAX_POINTS
- 例子: const MAX_POINTS: u32 = 100_000;

### Shadowing(隐藏)

- 可以使用相同的名字声明新的变量，新的变量就会shadow(隐藏)之前声明的同名变量
  - 在后续的代码中这个变量名代表的就是新的变量
- shadow和把变量标记为mut是不一样的
  - 如果不使用let关键字，那么重新给非mut的变量赋值就会导致编译时错误
  - 而使用let声明的同名新变量，也是不可变的
  - 使用let声明的同名新变量，它的类型可以与之前不同

## 数据类型

- Rust是静态编译语言，在编译时必须知道所有变量的类型
  - 基于使用的值，编译器通常能够推断出它的具体类型
  - 但如果可能的类型比较多(例如把String转为整数的parse方法)，就必须添加类型的标注，否则会编译报错

### 标量类型

- 一个标量类型代表一个单个的值

#### 整数类型

- 整数类型没有小数部分
- 例如u32就是一个无符号的整数类型，占据32位的空间
- 无符号整数类型以u开头
- 有符号整数类型以i开头

| length  | singned | unsigned |
| ------- | ------- | -------- |
| 8-bit   | i8      | u8       |
| 16-bit  | i16     | u16      |
| 32-bit  | i32     | u32      |
| 64-bit  | i64     | u64      |
| 128-bit | i128    | u128     |
| arch    | isize   | usize    |

- 每种都分i和u, 以及固定的位数

- isize和usize类型的位数由程序运行的计算机的架构所决定

- 使用isize和usize的主要场景是对某种集合进行索引操作

- 整数字面值

  - 除了byte类型外，所有的数字字面值都允许使用类型后缀，例如57u8
  - 如果你不太清楚应该使用哪种类型，可以使用Rust相应的默认类型
  - 整数的默认类型就是i32: 总体上来说速度很快，即使在64位操作系统中

  | Number literals | Example     |
  | --------------- | ----------- |
  | Decimal         | 98_222      |
  | Hex             | 0xff        |
  | Octal           | 0o77        |
  | Binary          | ob1111_0000 |
  | Byte(u8 only)   | b'A'        |

- 整数溢出

  - u8的范围是0-255，如果你把一个u8的变量设为256，那么
  - 调试模式下编译：Rust会检查整数溢出，如果发生溢出，程序在运行时就会panic
  - 发布模式下(--release)编译: Rust不会检查可能导致panic的整数溢出，如果发生溢出: Rust会执行"环绕"操作：256变成0，257变成1，但程序不会panic

#### 浮点类型

- Rust由两种基础的浮点类型，也就是含有小数部分的类型
  - f32, 32位，单精度
  - f64, 64位，双精度
- Rust的浮点类型使用了IEEE-754标准来表述
- f64是默认类型，因为现代CPU上f64和f32的速度差不多，而且精度更高

#### 布尔类型

- true和false
- 一个字节大小
- 符合是bool

#### 字符类型

- Rust语言中char类型被用来描述语言中最基础的单个字符
- 字符类型的字面值使用单引号
- 占用4个字节大写
- 是Unicode标量值，可以表示比ASCII多得多得字符内容：拼音，中日韩文，零长度空白字符，emoji表情等
  - U+0000 到 U+D7ff
  - U+e000 到 U+10FFFF
- 但Unicode中并没有"字符"的概念，所以直觉上认为的字符也许与Rust中的概念并不相符

### 复合类型

- 符合类型可以将多个值放在一个类型里
- Rust提供了两种基础的符合类型: 元组(tuple), 数组

### Tuple

- Tuple可以将多个类型的的多个值放在一个类型里

- Tuple的长度是固定的：一旦声明就无法改变

- 创建tuple

  - 在小括号里，将值用逗号分开
  - tuple中的每个位置都对应一个类型，tuple中各元素的类型不必相同

  ```rust
  let tup: (i32, f64, u8) = (500, 6.4, 1)
  println!("{}, {}, {}", tup.0, tup.1, tup.2);
  ```

- 获取tuple的元素值

  - 可以使用模式匹配来解构(destructure)一个tuple来获取元素的值

  ```rust
  let tup: (i32, f64, u8) = (500, 6.4, 1)
  let (x, y, z) = tup;
  println!("{}, {}, {}", x, y, z);
  ```

- 访问tuple的元素：在tuple变量使用点标记法，后接元素的索引号

### 数组

- 数组也可以将多个值放在一个类型里
- 数组中的每个元素的类型必须相同
- 数组的长度也是固定的
- 数组的用处
  - 如果想让你的数据存放在stack(栈)上而不是heap(堆)上，或者想保证由固定数量的元素，这时使用数组更有好处
  - 数组没有Vector灵活：Vector和数组类似，它由标准库提供；Vector的长度可以改变; 如果你不确定应该用数组还是Vector那么就用Vector
- 数组的类型：[类型; 长度] let a:[i32; 5] = [1,2,3,4,5];
- 如果数组的元素每个元素值都相同 let a = [3; 5]; 相当于 let a = [3, 3, 3, 3, 3];
- 数组是stack上分配的单个块的内存
- 可以使用索引来访问数组的元素
- 如果访问的索引超出了数组的范围
  - 编译会通过
  - 运行会报错(runtime会panic): Rust不会允许其继续访问相应地址的内存

## 函数

## 注释

## 控制流

